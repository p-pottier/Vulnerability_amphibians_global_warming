

#######################
#  supporting functions
######################

# these functions below are from: https://github.com/matthiasspeidel/hmi

#' Standardizing function
#'
#' Function to standardize variables that are numeric (continuous and count variables) but no rounded continuous, semicontinuous, intercepts or categorical variables.
#' @param X A n times p data.frame with p fixed (or random) effects variables.
#' @return A n times p data.frame with the standardized versions of the numeric variables.
#' @export
stand <- function(X){
  # if(!is.data.frame(X)) stop("X has to be a data.frame.")
  # if(ncol(X) == 0) return(X)
  # types <- array(NA, dim = ncol(X))
  # for(i in 1:length(types)){
  #   types[i] <- get_type(X[, i])
  # }
  # need_stand_X <- types %in% c("cont", "count", "roundedcont", "semicont")
  X_stand <- X
  tmp <- scale(X)
  X_stand <- matrix(tmp, ncol = ncol(tmp)) # this avoids having attributes delivered by scale().
  return(X_stand)
}

#' Sample imputation.
#'
#' Function to sample values in a variable from other (observed) values in this variable.
#' So this imputation does not use further covariates.
#' @param variable A vector of size \code{n} with missing values.
#' @return A list with a n times 1 data.frame without missing values and
#'  a list with the chains of the Gibbs-samples for the fixed effects and variance parameters.
#' @examples
#' set.seed(123)
#' sample_imp(c(1, NA, 3, NA, 5))
#' @export
sample_imp <- function(variable){
  
  if(is.data.frame(variable)){
    stop("You passed a data.frame instead of a vector to sample_imp.")
  }
  if(all(is.na(variable))) stop("Variable consists only of NAs.")
  
  ret <- data.frame(target = variable)
  
  
  
  need_replacement <- is.na(variable) | is.infinite(variable)
  ret[need_replacement, 1] <- sample(size = sum(need_replacement),
                                     variable[!need_replacement], replace = TRUE)
  return(ret)
}





#####################
# imputation function
#####################

# inter = muitplier for iteration 
b_mice <- function(cycle = 1, 
                   data = dat, 
                   Ainv = Ainv,
                   iter1 = 10, 
                   iter2 = 20, 
                   iter3 = 60){
  
  


  
  # Standard deviation of thermal tolerance estimates (sd_UTL)
  #######################
  
  # formula
  forms_sd_UTL <- as.formula(paste("ln_sd_UTL ~ 
                                    life_stage_tested +", 
                                   "acclimation_temp", "+",
                                   "endpoint2", "+",
                                   "acclimated", "+",
                                   paste0("ln_acclimation_time_stand",  cycle), "+",
                                   paste0("medium_test_temp2_fill", cycle), "+",
                                   paste0("ramping_stand", cycle), "+",
                                   paste0("mean_UTL_stand", cycle)))
  
  prior_sd_UTL<- list(R = list(V = 1, nu = 0.002), 
                      G = list( G1 = list(V = 1, nu = 0.002, 
                                          alpha.mu = 0, 
                                          alpha.V = 1000)))
  # model
  mod_sd_UTL <- MCMCglmm(forms_sd_UTL,
                         random = ~ species,
                         pl = TRUE,
                         pr = TRUE,
                         nitt=13000*iter1, 
                         thin=10*iter1, 
                         burnin=3000*iter1,
                         singular.ok=TRUE,
                         verbose=FALSE,
                         prior = prior_sd_UTL,
                         data = data)
  # processing
  pre_sd_UTL <- as.vector(predict(mod_sd_UTL, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]] <- 
    data$ln_sd_UTL
  # filling in with predicted values
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]][sd_UTL_mpos] <- 
    pre_sd_UTL[sd_UTL_mpos]
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]] <-
    stand(data[[paste0("ln_sd_UTL_stand", cycle + 1)]])[,1]
  
  # Adding variance column 
  data[[paste0("var_UTL_stand", cycle + 1)]] <- 
    (data[[paste0("ln_sd_UTL_stand", cycle + 1)]])^2
  
  
  
  #data
  print("1 out of 5 models done")
  
  
  
  
  # Acclimation time
  #######################
  
  # formula
  forms_acclimation_time <- as.formula(paste("ln_acclimation_time ~ 
                                              life_stage_tested +", 
                                             paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                             paste0("mean_UTL_stand", cycle)))
  
  prior_acclimation_time<- list(R = list(V = 1, nu = 0.002), 
                                G = list( G1 = list(V = 1, nu = 0.002, 
                                                    alpha.mu = 0, 
                                                    alpha.V = 1000)))
  # model
  mod_acclimation_time <- MCMCglmm(forms_acclimation_time,
                                   random = ~ species,
                                   pl = TRUE,
                                   pr = TRUE,
                                   nitt=13000*iter1, 
                                   thin=10*iter1, 
                                   burnin=3000*iter1,
                                   singular.ok=TRUE,
                                   verbose=FALSE,
                                   prior = prior_acclimation_time,
                                   data = data)
  # processing
  pre_acclimation_time <- as.vector(predict(mod_acclimation_time, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]] <- 
    data$ln_acclimation_time
  # filling in with predicted values
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]][acclimation_time_mpos] <- 
    pre_acclimation_time[acclimation_time_mpos]
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]] <-
    stand(data[[paste0("ln_acclimation_time_stand", cycle + 1)]])[,1]
  
  #data
  print("2 out of 5 models done")
  
  
  # Ramping rate
  ################
  
  # formula
  forms_ramping <- as.formula(paste("ramping ~ 
                                    life_stage_tested +",
                                    paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                    paste0("mean_UTL_stand", cycle)))
  
  # prior
  prior_ramping <- list(R = list(V = 1, nu = 0.002), 
                        G = list( G1 = list(V = 1, nu = 0.002, 
                                            alpha.mu = 0, 
                                            alpha.V = 1000)))
  # model
  mod_ramping <- MCMCglmm(forms_ramping,
                          random = ~ species,
                          pl = TRUE,
                          pr = TRUE,
                          nitt=13000*iter1, 
                          thin=10*iter1, 
                          burnin=3000*iter1,
                          singular.ok=TRUE,
                          prior = prior_ramping,
                          verbose=FALSE,
                          data = data)
  # processing
  pre_ramping <- as.vector(predict(mod_ramping, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ramping_stand", cycle + 1)]] <- 
    data$ramping
  # filling in with predicted values
  data[[paste0("ramping_stand", cycle + 1)]][ramping_mpos] <- 
    pre_ramping[ramping_mpos]
  data[[paste0("ramping_stand", cycle + 1)]] <-
    stand(data[[paste0("ramping_stand", cycle + 1)]])[,1]
  
  #data
  print("3 out of 5 models done")
  
  # Medium for measuring CTmax (ambient, water/body)
  ################
  
  # formula
  forms_medium <- as.formula(paste("medium_test_temp2 ~ 
                                   life_stage_tested +", 
                                   paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                   paste0("mean_UTL_stand", cycle)))
  
  forms_medium_prior  <- as.formula(paste(" ~ life_stage_tested +",
                                          paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                          paste0("mean_UTL_stand", cycle)))
  
  
  # prior
  prior_medium <-list(B = list(mu = rep(0,4), 
                               V=gelman.prior(forms_medium_prior,
                                              data = data, 
                                              scale=sqrt(1+1))),
                      R = list(V=1, fix =1), 
                      G = list(G1 = list(V = 1, nu = 0.002, 
                                         alpha.mu = 0, 
                                         alpha.V = 1000)))
  # model
  mod_medium <- MCMCglmm(forms_medium,
                         random = ~ species,
                         ginverse=list(tip.label = Ainv),
                         pl = TRUE,
                         pr = TRUE,
                         family = "threshold", 
                         nitt=13000*iter3, 
                         thin=10*iter3, 
                         burnin=3000*iter3,
                         singular.ok=TRUE,
                         prior = prior_medium,
                         verbose=FALSE,
                         data = data)
  # processing
  pre_medium <- as.vector(predict(mod_medium, marginal = NULL)) # prediction
  pre_medium_b<- levels(data$medium_test_temp2)[round(pre_medium,0)+1]
  # creating a new variable
  data[[paste0("medium_test_temp2_fill", cycle + 1)]] <- 
    data$medium_test_temp2
  # filling in with predicted values
  data[[paste0("medium_test_temp2_fill", cycle + 1)]][medium_test_temp2_mpos] <- 
    pre_medium_b[medium_test_temp2_mpos]
  
  #data 
  print("4 out of 5 models done")
  
  # Thermal tolerance (mean_UTL)
  ################
  
  # formula
  forms_mean_UTL <- as.formula(paste("mean_UTL ~ 
                                   acclimation_temp_stand +", 
                                   paste0("ln_acclimation_time_stand",  cycle + 1), "+",
                                   paste0("ramping_stand",  cycle + 1), "+",
                                   paste0("medium_test_temp2_fill", cycle + 1), "+",
                                   "endpoint2", "+",
                                   "acclimated" , "+",
                                   "life_stage_tested", "+",
                                   "ecotype"))
  
  # prior
  prior_mean_UTL <- list(R = list(V = 1, nu = 0.002), 
                         G = list( G1 = list(V = diag(2)/2, nu = 2, 
                                             alpha.mu = rep(0,2), 
                                             alpha.V = diag(2)*1000),
                                   G2 = list(V = diag(2)/2, nu = 2, 
                                             alpha.mu = rep(0,2), 
                                             alpha.V = diag(2)*1000))
  )
  
  
  mev <- noquote(paste0("var_UTL_stand", cycle + 1)) # Variance for mev argument
  
  
  # model
  mod_mean_UTL <- MCMCglmm(forms_mean_UTL,
                           random = ~
                             us(1+acclimation_temp_stand):tip.label + 
                             us(1+acclimation_temp_stand):species,
                           ginverse=list(tip.label = Ainv),
                           pl = TRUE,
                           pr = TRUE,
                           nitt=13000*iter3, 
                           thin=10*iter3, 
                           burnin=3000*iter3,
                           singular.ok=TRUE,
                           prior = prior_mean_UTL,
                           verbose=FALSE,
                           mev=data$mev,
                           data = data)
  
  print("5 out of 5 models done")
  
  # processing
  predictions <- predict(mod_mean_UTL, marginal = NULL, interval = "confidence") # prediction
  pre_mean_UTL <- predictions[ , 1]
  data[["lower_mean_UTL"]] <- predictions[ , 2]
  data[["upper_mean_UTL"]] <- predictions[ , 3]
  # creating a new variable
  data[[paste0("mean_UTL_stand", cycle + 1)]] <- 
    data$mean_UTL
  # filling in with predicted values
  data[[paste0("mean_UTL_stand", cycle + 1)]][mean_UTL_mpos] <- 
    pre_mean_UTL[mean_UTL_mpos]
  data[[paste0("mean_UTL_stand", cycle + 1)]] <-
    data[[paste0("mean_UTL_stand", cycle + 1)]]
  data[[paste0("filled_mean_UTL", cycle)]] <- 
    data[[paste0("mean_UTL_stand", cycle + 1)]] # row estimation
  data[[paste0("mean_UTL_stand", cycle + 1)]] <- 
    stand(data[[paste0("mean_UTL_stand", cycle + 1)]])[,1]
  
  data
}  
