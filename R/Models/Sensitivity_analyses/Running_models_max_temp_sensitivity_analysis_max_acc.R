
# Load packages
pacman::p_load(tidyverse, 
               mgcv,
               gamm4,
               future,
               future.apply, 
               furrr,
               futile.logger,
               MCMCglmm,
               ape,
               phytools,
               lmerTest,
               emmeans)

# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_max_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_max_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_max_acc_future4C.rds")


# Function to run population-level max_temp models in parallel 
run_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(max_temp ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    max_temp = NA, 
    max_temp_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/max_temp/sensitivity_analyses/predictions_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


########################################
# Run analyses with MCMCglmm to estimate mean max_temp in each microhabitat and scenario
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

plan(sequential) 

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(max_temp ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(max_temp_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_max_acc.rds")
saveRDS(predictions, file = "RData/Models/max_temp/sensitivity_analyses/predictions_MCMCglmm_max_temp_max_acc.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(max_temp_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_contrast_max_acc.rds")


#######################################

# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C.rds")

community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C.rds")

# Function to run community-level max_temp models in parallel 
run_community_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(community_max_temp ~ s(lat, bs = "tp"),
                        data = data,
                        weights = 1/(data$community_max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    community_max_temp = NA, 
    community_max_temp_se = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_GAM_community_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_MER_community_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/max_temp/sensitivity_analyses/predictions_community_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  pond_current = community_pond_current,
  pond_future2C = community_pond_future2C,
  pond_future4C = community_pond_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

plan(multicore(workers=3)) 

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

########################################

# Now run models with MCMCglmm 
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  community_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  community_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  community_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

all_community_data <- as.data.frame(all_community_data)

prior_community  <- list(R = list(V = 1, nu = 0.002), 
                         G = list(G4 = list(V = 1, fix = 1)))

# Intercept-less model 
model_MCMC_community <- MCMCglmm(community_max_temp ~ habitat_scenario - 1, # No intercept
                                 random = ~ idh(community_max_temp_se):units, 
                                 singular.ok=TRUE,
                                 prior = prior_community,
                                 verbose=FALSE,
                                 data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC_community, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_community_max_temp_max_acc.rds")
saveRDS(predictions, file = "RData/Models/max_temp/sensitivity_analyses/predictions_MCMCglmm_community_max_temp_max_acc.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_MCMC_community_contrast <- MCMCglmm(community_max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # Contrast
                                          random = ~ idh(community_max_temp_se):units, 
                                          singular.ok=TRUE,
                                          prior = prior_community,
                                          verbose=FALSE,
                                          data = all_community_data)

saveRDS(model_MCMC_community_contrast, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_community_max_temp_contrast_max_acc.rds")
