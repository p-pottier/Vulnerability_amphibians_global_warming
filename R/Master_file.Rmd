---
title: "**Vulnerability of amphibians to global warming**"
author: Patrice Pottier, Michael R. Kearney, Nicholas C. Wu, Julie E. Rej, Alexander R. Gunderson, A. Nayelli Rivera-Villanueva, Pietro Pollo, Samantha Burke, Szymon M. Drobniak, Shinichi Nakagawa
date: "latest update: `r format(Sys.time(), '%d %B %Y')`"
output: 
  rmdformats::downcute:
    code_folding: show
    code_download: true
    toc_depth: 6
    toc_float:
      collapsed: false
    lightbox: true
    thumbnails: false
    downcute_theme: "chaos"
    code_overflow: wrap
editor_options: 
  chunk_output_type: console
---


<style>
#toc ul.nav li ul li {
    display: none;
    max-height: none;
}

#toc ul.nav li.active ul li  {
    display: block;
    max-height: none;
}

#toc ul.nav li ul li ul li {
    max-height: none;
    display: none !important;
}

#toc ul.nav li ul li.active ul li {
    max-height: none;
    display: block !important;
    
}

h1, h2, h3, h4, h5, h6 {
    color: deeppink !important;

</style>



```{r setup, include = FALSE}
# knitr setting
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE, 
  tidy = TRUE,
  cache = TRUE,
  echo=TRUE
)
```

# **Introduction**

This is the master file for the data processing, analysis and visualization for *Pottier et al. 2024. Vulnerability of amphibians to global warming*

This code goes through every step of the pipeline used to assess the vulnerability of amphibians to global warming.
**However**, it is not entirely reproducible. This code requires extensive computational power and most computations used the computational cluster Katana supported by Research Technology Services at UNSW Sydney (https://research.unsw.edu.au/katana). All code ran on Katana are indicated under each header, along with the location of the specific files one can use to reproduce the results.

Therefore, the present file is mostly here to walk the reader through the analyses. Where one wants to reproduce the analysis, please see the folder **/R**, where the files used to produce these results in an HPC environment are provided. The **/pbs** folder also describes the resources requested to run each individual R file, and these can be adapted to different supercomputers.

This file contains nearly 35,000 lines of code, and it is highly recommended to navigate the knitted version of the code (html file; or https://p-pottier.github.io/Vulnerability_amphibians_global_warming/). If opening this code in Rstudio or VScode, please use the headers to navigate this document. 
At the bottom of the headers on the knitted page, you also have the option to visualize this document using a **light**  or **dark** theme.

While not all **data** and **RData** files are provided in this repository due to memory size limits in Github, all files are available upon request. Outputs from intermediate files are also presented throughout. Please feel free to contact Patrice Pottier (p.pottier@unsw.edu.au) if you have any questions, find mistakes in the code, or if you would like to access specific files. We will also archive all files to a permanent repository upon journal acceptance.

Note that species level occurrences are named "populations" in this code, and assemblages are referred to as "communities".

# **Data processing** 

## **Load packages and data** {.tabset .tabset_fade .tabset_pills}

### **Load packages**

```{r}
pacman::p_load(tidyverse,
               kableExtra,
               viridis,
               viridisLite,
               maps,
               ape,
               naniar,
               patchwork,
               R.utils,
               ggtree, # devtools::install_github("YuLab-SMU/ggtree")
               ggtreeExtra, # devtools::install_github("xiangpin/ggtreeExtra")
               phytools,
               tidytree,
               ggnewscale, 
               RColorBrewer,
               ggdist,
               ggstatsplot,
               here,
               ggExtra,
               ggbeeswarm,
               raster,
               sp,
               rasterSp,# remotes::install_github("RS-eco/rasterSp", build_vignettes = T)
               rgeos,
               letsR, 
               rredlist,
               taxize,# remotes::install_github("ropensci/taxize")
               rredlist, #remotes::install_github("ropensci/rredlist")
               rgdal,
               rgeos,
               purrr,
               parallel,
               doParallel,
               abind,
               curl,
               zoo,
               sf,
               data.table,
               purrr,
               RNetCDF, 
               NicheMapR, # devtools::install_github("https://github.com/mrke/NicheMapR")
               microclima,
               letsR,
               MCMCglmm,
               mgcv, 
               gamm4,
               rlang,
               future,
               furrr,
               future.apply, 
               futile.logger,
               rnaturalearth,
               rnaturalearthdata,
               rnaturalearthhires,
               metafor,
               ggspatial,
               lwgeom,
               cowplot,
               lme4,
               ggeffects,
               optimx,
               emmeans)  

'%!in%' <- function(x,y)!('%in%'(x,y)) # Function opposite of %in%
```

### **Load data and phylogenetic tree**

```{r, eval=F}
d <- read_csv("data/data_Pottier_et_al_2022.csv") # Curated data from Pottier et al. (2022) Scientific Data
tree <- read.tree("data/Jetz_Pyron_2018_consensus.tre") # Load consensus tree from Jetz and Pyron (2018) Nature Ecology and Evolution
tree_metadata <- read_csv("data/Jetz_Pyron_metadata_tree.csv") # Metadata for species in the tree
Johnson <- read_csv("data/data_Johnson_et_al_2023.csv") # Body mass data from Johnson et al. (2023) Global Ecology and Biogeography
ecotype <- read_csv("data/ecotype_data.csv") # Ecotype data from Wu et al. (2024). in prep; and supplemented by data from Pietro Pollo and A. Nayelli Rivera-Villanueva

```

### **Load and process data from the IUCN**

```{r, eval=F}
IUCN_polygons<- shapefile('data/amphibian_IUCN_maps/AMPHIBIANS.shp')

IUCN_polygons<-IUCN_polygons[IUCN_polygons$presence==1,] # Only keep extant amphibians
IUCN_polygons<-IUCN_polygons[IUCN_polygons$category!="EX", ] # Remove extinct species 
IUCN_polygons<-IUCN_polygons[IUCN_polygons$category!="EW", ]
IUCN_polygons@data$binomial <- IUCN_polygons@data$sci_name

saveRDS(IUCN_polygons, file="RData/General_data/raster_IUCN_polygons.rds")

# create a table with IUCN species names, taxonomic information, and threat status
IUCN_data<- data.frame(tip.label = IUCN_polygons@data$binomial, 
                       order = IUCN_polygons@data$order_, 
                       family = IUCN_polygons@data$family,
                       IUCN_status = IUCN_polygons@data$category)
```

###

## **Process training data for the imputation**  {.tabset .tabset_fade .tabset_pills}

Here, we generate a dataset with 3 acclimation temperatures per species with ~90% missing data (5213 species in total).

### **Filtering training data**

Here, we focus on data for which we possess the acclimation or acclimatisation temperatures

```{r, eval=F}
# Process data from Pottier et al. 2022
d.training <- filter(d, 
                      d$acclimation_temp!="NA"|
                        ambient_temp!="NA"|
                        substrate_temp!="NA"|
                        water_temp!="NA"|
                        field_body_temp!="NA", # Remove data without acclimation or acclimatisation temperatures
                     life_stage_tested=="adults"|life_stage_tested=="larvae") # Take data from both adults and larvae

# Take the acclimatisation temperature (preferably the field body temperature or microenvironmental temperature) as the acclimation temperature
d.training <- d.training %>% 
  mutate(acclimation_temp = ifelse(!is.na(acclimation_temp), acclimation_temp, # Take acclimation temperature when available
                                   ifelse(!is.na(field_body_temp), field_body_temp, # Otherwise take the field body temperature
                                          ifelse(!is.na(substrate_temp), substrate_temp, # Otherwise take the substrate temperature
                                                 ifelse(!is.na(water_temp), water_temp, ambient_temp))))) # Otherwise take the water temperature or ambient temperature


```


### **Match species names with the IUCN red list**

```{r, eval=F}

d.training$tip.label <- d.training$species # Rename species name to tip.label

tree$tip.label <- gsub("_", " ", tree$tip.label) # Remove underscore between species names in the tree

d.training <- data.frame(d.training[d.training$tip.label %in% tree$tip.label, ] ) # Only get species for which we have phylogenetic information

d.not_IUCN <- d.training[d.training$tip.label %!in% IUCN_data$tip.label, ] # Identify species not listed in the IUCN
d.not_IUCN$tip.label <- as.factor(d.not_IUCN$tip.label) # 63 species not matching IUCN red list 

# Rename species name in the data and phylogenetic tree to match IUCN data

### Dendropsophus labialis --> Dendropsophus molitor in redlist 
d.training$tip.label[d.training$tip.label =="Dendropsophus labialis"] <- "Dendropsophus molitor"
tree$tip.label[tree$tip.label =="Dendropsophus labialis"] <- "Dendropsophus molitor"

### Hyla andersonii --> Dryophytes andersonii in redlist
d.training$tip.label[d.training$tip.label =="Hyla andersonii"] <- "Dryophytes andersonii"
tree$tip.label[tree$tip.label =="Hyla andersonii"] <- "Dryophytes andersonii"

### Hyla chrysoscelis --> Dryophytes chrysoscelis in redlist 
d.training$tip.label[d.training$tip.label =="Hyla chrysoscelis"] <- "Dryophytes chrysoscelis"
tree$tip.label[tree$tip.label =="Hyla chrysoscelis"] <- "Dryophytes chrysoscelis"

### Hyla cinerea --> Dryophytes cinereus in redlist
d.training$tip.label[d.training$tip.label =="Hyla cinerea"] <- "Dryophytes cinereus"
tree$tip.label[tree$tip.label =="Hyla cinerea"] <- "Dryophytes cinereus"

### Hyla squirella --> Dryophytes squirellus in redlist 
d.training$tip.label[d.training$tip.label =="Hyla squirella"] <- "Dryophytes squirellus"
tree$tip.label[tree$tip.label =="Hyla squirella"] <- "Dryophytes squirellus"

### Hyla versicolor --> Dryophytes versicolor in redlist 
d.training$tip.label[d.training$tip.label =="Hyla versicolor"] <- "Dryophytes versicolor"
tree$tip.label[tree$tip.label =="Hyla versicolor"] <- "Dryophytes versicolor"

### Hyla walkeri --> Dryophytes walkeri in redlist 
d.training$tip.label[d.training$tip.label =="Hyla walkeri"] <- "Dryophytes walkeri"
tree$tip.label[tree$tip.label =="Hyla walkeri"] <- "Dryophytes walkeri"

### Hynobius fuca --> Hynobius fucus in redlist 
d.training$tip.label[d.training$tip.label =="Hynobius fuca"] <- "Hynobius fucus"
tree$tip.label[tree$tip.label =="Hynobius fuca"] <- "Hynobius fucus"

### Hypsiboas cinerascens --> Boana cinerascens in redlist 
d.training$tip.label[d.training$tip.label =="Hypsiboas cinerascens"] <- "Boana cinerascens"
tree$tip.label[tree$tip.label =="Hypsiboas cinerascens"] <- "Boana cinerascens"

### Hypsiboas faber ---> Boana faber in redlist 
d.training$tip.label[d.training$tip.label =="Hypsiboas faber"] <- "Boana faber"
tree$tip.label[tree$tip.label =="Hypsiboas faber"] <- "Boana faber"

### Hypsiboas geographicus --> Boana geographica in redlist 
d.training$tip.label[d.training$tip.label =="Hypsiboas geographicus"] <- "Boana geographica"
tree$tip.label[tree$tip.label =="Hypsiboas geographicus"] <- "Boana geographica"

### Hypsiboas lanciformis --> Boana lanciformis in redlist
d.training$tip.label[d.training$tip.label =="Hypsiboas lanciformis"] <- "Boana lanciformis"
tree$tip.label[tree$tip.label =="Hypsiboas lanciformis"] <- "Boana lanciformis"

### Hypsiboas punctatus --> Boana punctata in redlist 
d.training$tip.label[d.training$tip.label =="Hypsiboas punctatus"] <- "Boana punctata"
tree$tip.label[tree$tip.label =="Hypsiboas punctatus"] <- "Boana punctata"

### Pachymedusa dacnicolor --> Agalychnis dacnicolor in redlist 
d.training$tip.label[d.training$tip.label =="Pachymedusa dacnicolor"] <- "Agalychnis dacnicolor"
tree$tip.label[tree$tip.label =="Pachymedusa dacnicolor"] <- "Agalychnis dacnicolor"

### Rana berlandieri --> Lithobates berlandieri in redlist 
d.training$tip.label[d.training$tip.label =="Rana berlandieri"] <- "Lithobates berlandieri"
tree$tip.label[tree$tip.label =="Rana berlandieri"] <- "Lithobates berlandieri"

### Rana catesbeiana --> Lithobates catesbeianus in redlist
d.training$tip.label[d.training$tip.label =="Rana catesbeiana"] <- "Lithobates catesbeianus"
tree$tip.label[tree$tip.label =="Rana catesbeiana"] <- "Lithobates catesbeianus"

### Rana clamitans --> Lithobates clamitans in redlist 
d.training$tip.label[d.training$tip.label =="Rana clamitans"] <- "Lithobates clamitans"
tree$tip.label[tree$tip.label =="Rana clamitans"] <- "Lithobates clamitans"

### Rana palmipes --> Lithobates palmipes in redlist 
d.training$tip.label[d.training$tip.label =="Rana palmipes"] <- "Lithobates palmipes"
tree$tip.label[tree$tip.label =="Rana palmipes"] <- "Lithobates palmipes"

### Rana palustris --> Lithobates palustris in redlist 
d.training$tip.label[d.training$tip.label =="Rana palustris"] <- "Lithobates palustris"
tree$tip.label[tree$tip.label =="Rana palustris"] <- "Lithobates palustris"

### Rana pipiens --> Lithobates pipiens in redlist 
d.training$tip.label[d.training$tip.label =="Rana pipiens"] <- "Lithobates pipiens"
tree$tip.label[tree$tip.label =="Rana pipiens"] <- "Lithobates pipiens"

### Rana sphenocephala --> Lithobates sphenocephalus in redlist 
d.training$tip.label[d.training$tip.label =="Rana sphenocephala"] <- "Lithobates sphenocephalus"
tree$tip.label[tree$tip.label =="Rana sphenocephala"] <- "Lithobates sphenocephalus"

### Rana sylvatica --> Lithobates sylvaticus in redlist 
d.training$tip.label[d.training$tip.label =="Rana sylvatica"] <- "Lithobates sylvaticus"
tree$tip.label[tree$tip.label =="Rana sylvatica"] <- "Lithobates sylvaticus"

### Rana virgatipes --> Lithobates virgatipes in redlist 
d.training$tip.label[d.training$tip.label =="Rana virgatipes"] <- "Lithobates virgatipes"
tree$tip.label[tree$tip.label =="Rana virgatipes"] <- "Lithobates virgatipes"

### Rana warszewitschii --> Lithobates warszewitschii in redlist
d.training$tip.label[d.training$tip.label =="Rana warszewitschii"] <- "Lithobates warszewitschii"
tree$tip.label[tree$tip.label =="Rana warszewitschii"] <- "Lithobates warszewitschii"

### Rhinella schneideri ---> Rhinella diptycha in redlist
d.training$tip.label[d.training$tip.label =="Rhinella schneideri"] <- "Rhinella diptycha"

### Syncope bassleri --> Chiasmocleis bassleri in redlist
d.training$tip.label[d.training$tip.label =="Syncope bassleri"] <- "Chiasmocleis bassleri"
tree$tip.label[tree$tip.label =="Syncope bassleri"] <- "Chiasmocleis bassleri"

### Ecnomiohyla miotympanum --> Rheohyla miotympanum in redlist 
d.training$tip.label[d.training$tip.label =="Ecnomiohyla miotympanum"] <- "Rheohyla miotympanum"
tree$tip.label[tree$tip.label =="Ecnomiohyla miotympanum"] <- "Rheohyla miotympanum"

### Eupemphix nattereri --> Physalaemus nattereri in redlist
d.training$tip.label[d.training$tip.label =="Eupemphix nattereri"] <- "Physalaemus nattereri"
tree$tip.label[tree$tip.label =="Eupemphix nattereri"] <- "Physalaemus nattereri"

### Hylarana labialis --> Chalcorana labialis in redlist
d.training$tip.label[d.training$tip.label =="Hylarana labialis"] <- "Chalcorana labialis"
tree$tip.label[tree$tip.label =="Hylarana labialis"] <- "Chalcorana labialis"

### Hypsiboas albomarginatus --> Boana albomarginata in redlist
d.training$tip.label[d.training$tip.label =="Hypsiboas albomarginatus"] <- "Boana albomarginata"
tree$tip.label[tree$tip.label =="Hypsiboas albomarginatus"] <- "Boana albomarginata"

### Hypsiboas albopunctatus --> Boana albopunctata in redlist
d.training$tip.label[d.training$tip.label =="Hypsiboas albopunctatus"] <- "Boana albopunctata"
tree$tip.label[tree$tip.label =="Hypsiboas albopunctatus"] <- "Boana albopunctata"

### Hypsiboas boans --> Boana boans in redlist
d.training$tip.label[d.training$tip.label =="Hypsiboas boans"] <- "Boana boans"
tree$tip.label[tree$tip.label =="Hypsiboas boans"] <- "Boana boans"

### Hypsiboas crepitans --> Boana crepitans
d.training$tip.label[d.training$tip.label =="Hypsiboas crepitans"] <- "Boana crepitans"
tree$tip.label[tree$tip.label =="Hypsiboas crepitans"] <- "Boana crepitans"

### Hypsiboas curupi --> Boana curupi
d.training$tip.label[d.training$tip.label =="Hypsiboas curupi"] <- "Boana curupi"
tree$tip.label[tree$tip.label =="Hypsiboas curupi"] <- "Boana curupi"

### Hypsiboas fasciatus --> Boana fasciata
d.training$tip.label[d.training$tip.label =="Hypsiboas fasciatus"] <- "Boana fasciata"
tree$tip.label[tree$tip.label =="Hypsiboas fasciatus"] <- "Boana fasciata"

### Hypsiboas pardalis --> Boana pardalis 
d.training$tip.label[d.training$tip.label =="Hypsiboas pardalis"] <- "Boana pardalis"
tree$tip.label[tree$tip.label =="Hypsiboas pardalis"] <- "Boana pardalis"

### Hypsiboas pellucens --> Boana pellucens
d.training$tip.label[d.training$tip.label =="Hypsiboas pellucens"] <- "Boana pellucens"
tree$tip.label[tree$tip.label =="Hypsiboas pellucens"] <- "Boana pellucens"

### Hypsiboas pulchellus --> Boana pulchella
d.training$tip.label[d.training$tip.label =="Hypsiboas pulchellus"] <- "Boana pulchella"
tree$tip.label[tree$tip.label =="Hypsiboas pulchellus"] <- "Boana pulchella"

### Hypsiboas raniceps --> Boana raniceps
d.training$tip.label[d.training$tip.label =="Hypsiboas raniceps"] <- "Boana raniceps"

### Hypsiboas rosenbergi --> Boana raniceps
d.training$tip.label[d.training$tip.label =="Hypsiboas rosenbergi"] <- "Boana raniceps"
tree$tip.label[tree$tip.label =="Hypsiboas rosenbergi"] <- "Boana raniceps"

### Hypsiboas semilineatus --> Boana semilineata
d.training$tip.label[d.training$tip.label =="Hypsiboas semilineatus"] <- "Boana semilineata"
tree$tip.label[tree$tip.label =="Hypsiboas semilineatus"] <- "Boana semilineata"

### Phyllomedusa nordestina --> Pithecopus nordestinus
d.training$tip.label[d.training$tip.label =="Phyllomedusa nordestina"] <- "Pithecopus nordestinus"
tree$tip.label[tree$tip.label =="Phyllomedusa nordestina"] <- "Pithecopus nordestinus"

### Phyllomedusa rohdei --> Pithecopus rohdei
d.training$tip.label[d.training$tip.label =="Phyllomedusa rohdei"] <- "Pithecopus rohdei"
tree$tip.label[tree$tip.label =="Phyllomedusa rohdei"] <- "Pithecopus rohdei"

### Rana bwana--> Lithobates bwana
d.training$tip.label[d.training$tip.label =="Rana bwana"] <- "Lithobates bwana"
tree$tip.label[tree$tip.label =="Rana bwana"] <- "Lithobates bwana"

### Rana vaillanti --> Lithobates vaillanti
d.training$tip.label[d.training$tip.label =="Rana vaillanti"] <- "Lithobates vaillanti"
tree$tip.label[tree$tip.label =="Rana vaillanti"] <- "Lithobates vaillanti"

### Rhinella humboldti --> Rhinella granulosa
d.training$tip.label[d.training$tip.label =="Rhinella humboldti"] <- "Rhinella granulosa"

### Scinax agilis --> Ololygon agilis
d.training$tip.label[d.training$tip.label =="Scinax agilis"] <- "Ololygon agilis"
tree$tip.label[tree$tip.label =="Scinax agilis"] <- "Ololygon agilis"

### Scinax aromothyella --> Ololygon aromothyella
d.training$tip.label[d.training$tip.label =="Scinax aromothyella"] <- "Ololygon aromothyella"
tree$tip.label[tree$tip.label =="Scinax aromothyella"] <- "Ololygon aromothyella"

### Scinax strigilatus --> Ololygon strigilata
d.training$tip.label[d.training$tip.label =="Scinax strigilatus"] <- "Ololygon strigilata"
tree$tip.label[tree$tip.label =="Scinax strigilatus"] <- "Ololygon strigilata"

### Sphaenorhynchus pauloalvini --> Gabohyla pauloalvini
d.training$tip.label[d.training$tip.label =="Sphaenorhynchus pauloalvini"] <- "Gabohyla pauloalvini"
tree$tip.label[tree$tip.label =="Sphaenorhynchus pauloalvini"] <- "Gabohyla pauloalvini"

####### Species not matching IUCN or not having distribution ranges ##########

# Hypsiboas almendarizae --> not in IUCN
# Elachistocleis muiraquitan --> not in IUCN
# Epipedobates darwinwallacei --> not in IUCN
# Hyloxalus yasuni --> not in IUCN
# Pristimantis reichlei --> not in IUCN
# Pristimantis bicantus --> not in IUCN
# Plethodon chlorobryonis --> not in IUCN
# Plethodon grobmani --> not in IUCN
# Plethodon ocmulgee --> not in IUCN
# Plethodon variolatus --> not in IUCN
# Rhinella azarai --> not in IUCN
# Trachycephalus cunauaru --> not in IUCN
# Scinax strigilatus --> in the IUCN, but no geographical distribution
# Uperoleia marmorata --> in the IUCN, but no geographical distribution

saveRDS(tree, "Rdata/General_data/tree_for_imputation.rds")  # Save the modified phylogenetic tree

d.not_IUCN<-d.training[d.training$tip.label %!in% IUCN_data$tip.label, ] # Check if all replacements were done correctly
unique(d.not_IUCN$species) # All good, 14 species not captured

d.training<-d.training[d.training$tip.label %in% IUCN_data$tip.label, ] # Only get species for which we have IUCN ranges
d.training<-unique(d.training)

species<-distinct(data.frame(tip.label=d.training$tip.label)) # List of unique species names (524 species with phylogeny and distribution range)

d.training %>% 
  group_by(tip.label) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  summarise(mean = mean(n), min = min(n), max = max(n)) # 5.08 estimates per species on average

d.training %>%
  group_by(tip.label) %>%
  summarise(n = n()) %>%
  filter(n > 1) %>%
  ungroup() # 287 species with more than one estimate.
```

##

### **Merge ecotype data with the training data and do additional processing**

```{r, eval=F}
# Select relevant variables
d.training <- dplyr::select(d.training,
                            tip.label, 
                            order,
                            family,
                            acclimated, 
                            acclimation_temp,
                            acclimation_time,  
                            life_stage_tested,
                            SVL,
                            body_mass,
                            endpoint, 
                            medium_test_temp, 
                            ramping, 
                            mean_UTL, 
                            error_UTL,
                            n_UTL,
                            error_type)

d.training <- left_join(d.training, dplyr::select(unique(IUCN_data), tip.label, IUCN_status)) # Update IUCN status

# Process ecotype data 
ecotype$tip.label <- ecotype$binomial # Rename species name
ecotype$order_name <- str_to_title(ecotype$order_name)
ecotype$family_name <- str_to_title(ecotype$family_name)
ecotype$binomial_tree_phylo <- gsub("_", " ", ecotype$binomial_tree_phylo)

ecotype_sp<-ecotype

# Match the different variables in the ecotype data to the training data
ecotype_IUCN_match <- ecotype_sp[ecotype_sp$binomial_IUCN %in% d.training$tip.label, ] %>% mutate(matched_var="binomial_IUCN")
ecotype_binomial_match <- ecotype_sp[ecotype_sp$binomial %in% d.training$tip.label, ] %>%   mutate(matched_var = "binomial")
ecotype_phylo_match <- ecotype_sp[ecotype_sp$binomial_tree_phylo %in% d.training$tip.label, ] %>%  mutate(matched_var = "binomial_tree_phylo")


# Combine the datasets and create the 'tip.label' column based on the 'matched_var' colum
combined_data <- bind_rows(ecotype_IUCN_match, ecotype_binomial_match, ecotype_phylo_match) %>%
  mutate(tip.label = case_when(
    matched_var == "binomial_IUCN" ~ binomial_IUCN,
    matched_var == "binomial" ~ binomial,
    matched_var == "binomial_tree_phylo" ~ binomial_tree_phylo
  ))

ecotype_sp <- combined_data %>%
  distinct(tip.label, .keep_all = TRUE) 

# Merge ecotype information in the training data
d.training <- left_join(d.training, dplyr::select(ecotype_sp, tip.label, ecotype, second_ecotype, strategy, Notes)) 


d.training <- d.training %>% mutate(sd_UTL= ifelse(error_type=="se" & is.na(n_UTL)=="TRUE", 
                                                   NA, 
                                                   ifelse(error_type=="sd", 
                                                          error_UTL, 
                                                          error_UTL*sqrt(n_UTL)))) # Convert SE to SD
```

## **Process list of species to impute** {.tabset .tabset_fade .tabset_pills}

### **Select species to be imputed** 

Here, we focus on species for which we have ecotype data, geographical distribution range, and matching the phylogenetic tree from Jetz and Pyron (2018)

```{r, eval=F}

# Filter species for which we have IUCN distribution range and phylogenetic position

tree_sp<-data.frame(tip.label = tree$tip.label) # Data frame with all species in the phylogenetic tree

tree_sp<-data.frame(tip.label = tree_sp[tree_sp$tip.label %in% IUCN_data$tip.label, ] )# Only get species for which we have IUCN ranges (5792)

ecotype_sp<-dplyr::select(ecotype, order_name, family_name, ecotype, second_ecotype, strategy, Notes, SVL_cm, mass_g, binomial, binomial_IUCN, binomial_tree_phylo)

# Match the different variables in the ecotype data to the phylogenetic tree
ecotype_IUCN_match <- ecotype_sp[ecotype_sp$binomial_IUCN %in% tree_sp$tip.label, ] %>% mutate(matched_var="binomial_IUCN")
ecotype_binomial_match <- ecotype_sp[ecotype_sp$binomial %in% tree_sp$tip.label, ] %>%   mutate(matched_var = "binomial")
ecotype_phylo_match <- ecotype_sp[ecotype_sp$binomial_tree_phylo %in% tree_sp$tip.label, ] %>%  mutate(matched_var = "binomial_tree_phylo")

# Combine the datasets and create the 'tip.label' column based on the 'matched_var' colum
combined_data <- bind_rows(ecotype_IUCN_match, ecotype_binomial_match, ecotype_phylo_match) %>%
  mutate(tip.label = case_when(
    matched_var == "binomial_IUCN" ~ binomial_IUCN,
    matched_var == "binomial" ~ binomial,
    matched_var == "binomial_tree_phylo" ~ binomial_tree_phylo
  ))

ecotype_sp <- combined_data %>%
  distinct(tip.label, .keep_all = TRUE) 


# Remove obligate cave-dwellers
ecotype_sp <- ecotype_sp %>% 
   filter(strategy != "Obligate cave-dweller" | is.na(strategy)==TRUE)

# Add a mention for paedomorphic species 
ecotype_sp <- ecotype_sp %>% 
  mutate(strategy = ifelse(strategy == "Paedomorphic"| Notes == "Paedomorphic", "Paedomorphic", NA)) %>% 
  dplyr::select(-Notes)

## Now we create a list of data-deficient species that match the phylogeny and for which we know the ecotype

data_deficient_sp<-data.frame(tip.label = tree_sp[tree_sp$tip.label %!in% d.training$tip.label, ]) # Data frame with all species we do not have data for (5268)

data_deficient_sp <- data.frame(tip.label = data_deficient_sp[data_deficient_sp$tip.label %in% ecotype_sp$tip.label, ]) # Focus on species we have ecotype data (4822)


data_deficient_sp<-left_join(data_deficient_sp, ecotype_sp, by="tip.label") # Assign ecotype data to each species. 
data_deficient_sp<-left_join(data_deficient_sp, dplyr::select(unique(IUCN_data), tip.label, IUCN_status))

data_deficient_sp<-dplyr::select(data_deficient_sp, tip.label, order=order_name, family=family_name, IUCN_status, ecotype, second_ecotype, strategy, SVL=SVL_cm, mass_g) # 4822 species

# Add body mass data from Johnson et al. 2023 

Johnson$tip.label <- Johnson$Species
Johnson$tip.label <- gsub("_", " ", Johnson$tip.label)
Johnson$mass_Johnson <- Johnson$Body_mass

data_deficient_sp <- left_join(data_deficient_sp, dplyr::select(Johnson, tip.label, mass_Johnson),
                               by = "tip.label")

# Choose the body mass from Niky and Wu (2023) when available, otherwise take it from Johnson et al. 2023 
data_deficient_sp <- data_deficient_sp %>%  mutate(body_mass = ifelse(is.na(mass_g)==FALSE,
                                                                mass_g, 
                                                                mass_Johnson))


# Remove Caecilians because we did not have data for this Order. 
data_deficient_sp<-filter(data_deficient_sp, order!="Gymnophiona")


# All species that will be imputed (4679 species)
all_species <- dplyr::select(data_deficient_sp, -mass_g, -mass_Johnson)
```


### **Process species in the training data that will be imputed**

We will also generate 3 new estimates per species, for the species we already have in the training dataset. This will allow us to standardise CTmax estimates using the same parameters. 

```{r, eval=F}
species_training <- dplyr::select(d.training, 
                                  tip.label,
                                  order,
                                  family,
                                  IUCN_status)
# Match with the ecotype dataset
species_training <- left_join(species_training, dplyr::select(ecotype_sp, 
                                                              tip.label,
                                                              ecotype, 
                                                              second_ecotype,
                                                              SVL=SVL_cm,
                                                              mass_g))
# Match with Johnson et al. body mass data
species_training <- left_join(species_training, dplyr::select(Johnson, 
                                                              tip.label, 
                                                              mass_Johnson))
# Take the data from Johnson et al. when available
species_training <- species_training %>%  mutate(body_mass = ifelse(is.na(mass_g)==FALSE,
                                                             mass_g, 
                                                             mass_Johnson)) %>% 
                                          dplyr::select(-mass_g, -mass_Johnson)
```



### **Merge datasets of species we need to impute and assign predictors**

```{r, eval=F}
data_to_imp <- full_join(species_training, all_species) 
data_to_imp <- distinct(data_to_imp)

data_to_imp  <- data_to_imp %>% mutate(ramping=1, # most common ramping
                                       acclimated="acclimated", # acclimated animals
                                       acclimation_temp = NA, #  will be determined from biophysical models
                                       acclimation_time=10, # most common acclimation time
                                       endpoint="OS", # Most common endpoint; most precise one too
                                       medium_test_temp="body_water", # Body or water temperature recorded during assay
                                       life_stage_tested="adults",
                                       imputed="yes")  
```

##

## **Combine training data and list of species to impute**

```{r, eval=F}

d.training<-mutate(d.training, imputed="no") # add a column "imputed"

d.training <- mutate(d.training, medium_test_temp = ifelse(medium_test_temp=="body"|medium_test_temp=="water", "body_water", "ambient")) 

data_for_imp<- full_join(d.training, data_to_imp) # Join the train data to the data to impute 

data_for_imp<-mutate(data_for_imp, species=tip.label) # Add another column for species so we can use this as a random effect as well.

data_for_imp<-mutate(data_for_imp, row_n = as.character(row_number()))


# Manually add missing ecotypes

# Subset the data_for_imp dataframe to remove the rows with missing ecotype values
data_with_ecotypes <- data_for_imp[!is.na(data_for_imp$ecotype),]

# Identify missing species
missing_ecotypes <- data_for_imp[is.na(data_for_imp$ecotype),]

# Manually add missing ecotypes
missing_ecotypes[missing_ecotypes$tip.label == "Cophixalus australis", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Oreobates gemcare", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Oreobates granulosus", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Dryophytes walkeri", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Hynobius fucus", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Kalophrynus limbooliati", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Pristimantis festae", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Pristimantis matidiktyo", "ecotype"] <- "Ground-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Pristimantis pharangobates", "ecotype"] <- "Ground-dwelling"

missing_ecotypes[missing_ecotypes$tip.label == "Chalcorana labialis", "ecotype"] <- "Stream-dwelling"
missing_ecotypes[missing_ecotypes$tip.label == "Hyloxalus italoi", "ecotype"] <- "Stream-dwelling"

missing_ecotypes[missing_ecotypes$tip.label == "Cynops orientalis", "ecotype"] <- "Aquatic"
missing_ecotypes[missing_ecotypes$tip.label == "Paramesotriton labiatus", "ecotype"] <- "Aquatic"

missing_ecotypes[missing_ecotypes$tip.label == "Dendropsophus molitor", "ecotype"] <- "Arboreal"
missing_ecotypes[missing_ecotypes$tip.label == "Polypedates braueri", "ecotype"] <- "Arboreal"

# Merge the two data frames based on matching tip.label values
data_for_imp <- rbind(data_with_ecotypes, missing_ecotypes)

# Save the preliminary data for the imputation (we still need to add the temperature)
saveRDS(data_for_imp, "RData/General_data/pre_data_for_imputation.rds")
```

## **Match species to their geographical distribution** 

```{r, eval=F}
IUCN_polygons <- readRDS(file="RData/General_data/raster_IUCN_polygons.rds") # Save processed IUCN polygons

polygon<-subset(IUCN_polygons, IUCN_polygons@data$binomial %in% data_for_imp$tip.label)

# Rasterize at a 1-degree resolution
raster_polygon<-lets.presab(polygon, resol=1) 
presence_absence<-data.frame(raster_polygon$Presence_and_Absence_Matrix)

# Pivot longer
presence_absence<-pivot_longer(presence_absence, cols=Acanthixalus.sonjae:Zachaenus.parvulus, names_to = "tip.label", values_to = "Presence") 
presence<-filter(presence_absence, Presence=="1") # Only keep rows where species are present

saveRDS(presence, file="RData/General_data/species_coordinates.rds")

distinct_coord<- distinct(dplyr::select(presence, -Presence, - tip.label)) # Coordinates where species are present (14119 grid cells)
distinct_coord<-distinct_coord %>% rename(x=Longitude.x., y=Latitude.y.)

saveRDS(distinct_coord, file="RData/General_data/distinct_coordinates.rds")
```


## **Adjust coordinates to land masses**  {.tabset .tabset_fade .tabset_pills}

Rasterizing at a 1-degree resolution produces data points that do not necessarily match land masses. Therefore, these coordinates must be adjusted

### **Loop over coordinates and find matching land** 

This code ran on an HPC environment, where the original code can be found in **R/Data_wrangling/Adjusting_coordinates.R** and the resources used in **pbs/Data_wrangling/Adjusting_coordinates.pbs** 

```{r, eval=F}
# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)

# Function to check if coordinate is on land
check_if_point_on_land <- function(lon, lat) {
  point <- st_point(c(lon, lat))
  point_sf <- st_sf(geometry = st_sfc(point), crs = 4326)  # specify the CRS when you create the st_point
  st_transform(point_sf, st_crs(land_polygon))  # transform the point to match the CRS of the land_polygon
  st_intersects(land_polygon, point_sf, sparse = FALSE)[1, 1]
}


adjust_coordinates_to_land <- function(lon, lat) {
  if(check_if_point_on_land(lon, lat)) {
    return(c(lon, lat))
  }
  
  steps <- seq(-0.45, 0.45, by = 0.05)
  
  # Iterate over both longitude and latitude in the full range of steps
  for(dx in steps) {
    for(dy in steps) {
      if(check_if_point_on_land(lon + dx, lat + dy)) {
        return(c(lon + dx, lat + dy))
      }
    }
  }
  
  return(NULL)  # return NULL if no land found
}

distinct_coord <- readRDS(file="RData/General_data/distinct_coordinates.rds")

distinct_coord_adj <- as.data.frame(distinct_coord %>% rename(lon=x, lat=y))

# Iterate through each row in the dataframe
for(i in 1:nrow(distinct_coord_adj)) {
  print(paste("Processing lon: ", distinct_coord_adj$lon[i], ", lat: ", distinct_coord_adj$lat[i]))
  adjusted_coords <- adjust_coordinates_to_land(distinct_coord_adj$lon[i], distinct_coord_adj$lat[i])
  if (!is.null(adjusted_coords)) {
    print(paste("Adjusted lon: ", adjusted_coords[1], ", lat: ", adjusted_coords[2]))
    distinct_coord_adj$lon[i] <- adjusted_coords[1]
    distinct_coord_adj$lat[i] <- adjusted_coords[2]
  } else {
    print(paste("No suitable land coordinates found for lon: ", distinct_coord_adj$lon[i], ", lat: ", distinct_coord_adj$lat[i]))
  }
}

saveRDS(distinct_coord_adj, file="RData/General_data/distinct_coordinates_adj.rds")
```

### **Adjust coordinates not matching land masses** 

Some coordinates were not adjusted properly, and had to undergo further processing.

```{r, eval=F}

species_occurrence<- readRDS("RData/General_data/species_coordinates.rds")
species_occurrence<- rename(species_occurrence,lon=Longitude.x., lat=Latitude.y.)

n_species<- unique(species_occurrence$tip.label) # 5213 

distinct_coord_adj <- readRDS("RData/General_data/distinct_coordinates_adj.rds")

# Identify coordinates that did not intersect with land masses
failed_coords <- data.frame(
  lon = c(-124.5, 38.5, -123.5, 129.5, -107.5, -74.5, -68.5, -65.5, 122.5, 97.5, 
          120.5, 126.5, -14.5, -9.5, 107.5, -0.5, 0.5, -0.5, 0.5, 6.5, 150.5, -5.5, 
          50.5, 17.5, 25.5, 122.5, -64.5),
  lat = c(45.5, 41.5, 37.5, 27.5, 23.5, 19.5, 19.5, 17.5, 15.5, 13.5, 10.5, 10.5, 
          9.5, 4.5, 3.5, 0.5, 0.5, -0.5, -0.5, -0.5, -8.5, -16.5, -16.5, -33.5, -34.5, 
          -34.5, -41.5)
)


distinct_coord_adj <- distinct_coord_adj %>%
  mutate(id = paste(lon, lat))

failed_coords <- failed_coords %>%
  mutate(id = paste(lon, lat))

# Replace the coordinates 
distinct_coord_adj <- distinct_coord_adj %>%
  rowwise() %>%
  mutate(
    across(c(lon, lat), ~ if_else(id %in% failed_coords$id, NA_real_, .))
  ) %>%
  dplyr::select(-id)

# Get original distinct coordinates
distinct_coord <- readRDS("RData/General_data/distinct_coordinates.rds")

distinct_coord_adj<- cbind(distinct_coord, distinct_coord_adj)


distinct_coord_adj<- filter(distinct_coord_adj, is.na(lat)==FALSE)

saveRDS(distinct_coord_adj, file="RData/General_data/distinct_coordinates_adjusted.rds")

##
species_occurrence <- species_occurrence %>%
  mutate(id = paste(lon, lat))

species_occurrence  <- species_occurrence %>%
  rowwise() %>%
  mutate(
    across(c(lon, lat), ~ if_else(id %in% failed_coords$id, NA_real_, .))
  ) %>%
  dplyr::select(-id)

species_occurrence <- filter(species_occurrence, is.na(lat)==FALSE)

n_species<- unique(species_occurrence$tip.label) # 5203. All good.


### Updating species occurrence dataset

distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")

# Match body mass data to coordinates
presence <- readRDS(file="RData/General_data/species_coordinates.rds")
presence <- dplyr::rename(presence,lon=Longitude.x., lat=Latitude.y.)
presence$tip.label <- gsub("\\.", " ", presence$tip.label)

presence_adjusted <- presence %>%
  dplyr::left_join(distinct_coord, by = c("lon" = "x", "lat" = "y"))

presence <- dplyr::rename(presence_adjusted, 
                          original_lon = lon, 
                          original_lat = lat,
                          lon = lon.y,
                          lat = lat.y)

presence <- dplyr::filter(presence, is.na(lon)==FALSE)


saveRDS(presence, file="RData/General_data/species_coordinates_adjusted.rds")


##### Adjust coordinates that were not properly adjusted ############

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")

distinct_coord <- distinct_coord %>%
  mutate(
    lon = case_when(
      lon == -17.95 & lat == 27.70 ~ -17.95,
      lon == 54.05 & lat == 26.50 ~ 54.05,
      lon == 107.50 & lat == 10.50 ~ 107.5,
      lon == "0.05" & lat == 5.65 ~ 0.05,
      lon == 134.05 & lat == -0.95 ~ 134.05,
      lon == 55.25 & lat == -4.50 ~ 55.23,
      lon == 133.50 & lat == -11.50 ~ 133.45,
      lon == -38.95 & lat == -14.10 ~ -38.97,
      lon == -5.75 & lat == -15.95 ~ -5.70,
      lon == 49.05 & lat == -19.15 ~ 49.02,
      lon == 30.05 & lat == -31.25 ~ 30.05,
      lon == 147.05 & lat == -38.50 ~ 147.05,
      lon == 174.5 & lat == -35.5 ~ 174.45,
      TRUE ~ lon
    ),
    lat = case_when(
      lon == -17.95 & lat == 27.70 ~ 27.75,
      lon == 54.05 & lat == 26.50 ~ 26.8,
      lon == 107.50 & lat == 10.50 ~ 10.55,
      lon == "0.05" & lat == 5.65 ~ 5.70,
      lon == 134.05 & lat == -0.95 ~ -0.85,
      lon == 55.25 & lat == -4.50 ~ -4.5,
      lon == 133.50 & lat == -11.50 ~ -11.5,
      lon == -38.95 & lat == -14.10 ~ -14.1,
      lon == -5.75 & lat == -15.95 ~ -15.95,
      lon == 49.05 & lat == -19.15 ~ -19.15,
      lon == 30.05 & lat == -31.25 ~ -31.20,
      lon == 147.05 & lat == -38.50 ~ -38.45,
      lon == 174.5 & lat == -35.5 ~ -35.5,
      TRUE ~ lat
    )
  )
saveRDS(distinct_coord, file="RData/General_data/distinct_coordinates_adjusted.rds")

### Same for species coordinates

species_coordinates <- readRDS("RData/General_data/species_coordinates_adjusted.rds")

species_coordinates <- species_coordinates %>% 
  mutate(
    lon = case_when(
      lon == -17.95 & lat == 27.70 ~ -17.95,
      lon == 54.05 & lat == 26.50 ~ 54.05,
      lon == 107.50 & lat == 10.50 ~ 107.5,
      lon == "0.05" & lat == 5.65 ~ 0.05,
      lon == 134.05 & lat == -0.95 ~ 134.05,
      lon == 55.25 & lat == -4.50 ~ 55.23,
      lon == 133.50 & lat == -11.50 ~ 133.45,
      lon == -38.95 & lat == -14.10 ~ -38.97,
      lon == -5.75 & lat == -15.95 ~ -5.70,
      lon == 49.05 & lat == -19.15 ~ 49.02,
      lon == 30.05 & lat == -31.25 ~ 30.05,
      lon == 147.05 & lat == -38.50 ~ 147.05,
      lon == 174.5 & lat == -35.5 ~ 174.45,
      TRUE ~ lon
    ),
    lat = case_when(
      lon == -17.95 & lat == 27.70 ~ 27.75,
      lon == 54.05 & lat == 26.50 ~ 26.8,
      lon == 107.50 & lat == 10.50 ~ 10.55,
      lon == "0.05" & lat == 5.65 ~ 5.70,
      lon == 134.05 & lat == -0.95 ~ -0.85,
      lon == 55.25 & lat == -4.50 ~ -4.5,
      lon == 133.50 & lat == -11.50 ~ -11.5,
      lon == -38.95 & lat == -14.10 ~ -14.1,
      lon == -5.75 & lat == -15.95 ~ -15.95,
      lon == 49.05 & lat == -19.15 ~ -19.15,
      lon == 30.05 & lat == -31.25 ~ -31.20,
      lon == 147.05 & lat == -38.50 ~ -38.45,
      lon == 174.5 & lat == -35.5 ~ -35.5,
      TRUE ~ lat
    )
  )

saveRDS(species_coordinates, file="RData/General_data/species_coordinates_adjusted.rds")
```

#

# **Biophysical modelling** 

This code assumes that you have downloaded NCEP and TerraClimate data locally. NCEP data can be downloaded at https://psl.noaa.gov/thredds/catalog/Datasets/ncep.reanalysis2/gaussian_grid/catalog.html 
; and TerraClimate data can be downloaded at https://www.climatologylab.org/terraclimate.html 

This code ran on an HPC environment, where the original code can be found in **R/Biophysical_modelling/** and the resources used in **pbs/Biophysical_modelling/** 
These folders contain R files for each microhabitat (**Substrate/** for terrestrial conditions; **Pond/** for aquatic conditions; **Arboreal/** for arboreal conditions) and climatic scenario (**/current** for 2006-2015; **2C/** for +2 degrees of warming above pre-industrial levels; or **4C/** for +4 degrees of warming above pre-industrial levels).

For each conditions, R files are separated in batches to reduce memory and time requirements. There are also files with the suffix "**...problematic_locations** or "**...failed_locations**".
The former refer to locations that did not run properly in parallel (e.g. got stuck in endless loops) and had to run in regular for loops; while failed locations are locations that were identified as failing, post-hoc, and that needed small adjustments (i.e., increase in the error tolerance for calculating soil temperatures in NicheMapR). All geographical coordinates eventually ran without error.

Once all R scripts have finished running, you can combine the outputs from all files using the "**Combining_outputs...**" file for each microhabitat and climatic scenario. 

Models for arboreal species also require further adjustments because they ran on a subset of species. You can find the script to subset arboreal species in **R/Data_wrangling/Filtering_data_for_arboreal_species.R**, as well as some code to match the row numbers known to be "problematic locations" in this subsetted dataset in **R/Data_wrangling/Matching_row_numbers_problematic_locations_arboreal.R**

## **Vegetated substrate** 

### **Current climate** {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**
```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=0,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=0,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 200, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

Processing the coordinates in chunks is very useful for debugging. 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Substrate/current/results/1st_batch/results_biophysical_modelling_substrate_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations**

```{r, eval=F}

dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval =F}

# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Substrate/current/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Substrate/current/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Substrate/current/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]
  
  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)



#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Substrate/current/daily_temp_substrate.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Substrate/current/daily_temp_warmest_days_substrate.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Substrate/current/overall_temp_warmest_days_substrate.rds")

####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Substrate/current/missing_coordinates.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Substrate/current/missing_coordinates_row_n.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Substrate/current/row_n_duplicated_coordinates.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Substrate/current/duplicated_coordinates.rds")
```



### **Future climate (+2C)** {.tabset .tabset_fade .tabset_pills}

Here, we assume a climate projection assuming 2 degrees of warming. 

#### **Function to process coordinates**

```{r, eval=F}

# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  # Check if current index falls within any of the problematic ranges
  ERR <- 1.5
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=2,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=2,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 300, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[,3:4]
  distinct_coord <- rename(distinct_coord, 
                           x= lon,
                           y= lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 1800)  # Set a global timeout for 50 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Substrate/2C/results/1st_batch/results_biophysical_modelling_substrate_future2C_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval =F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch", 
             "6th_batch", "7th_batch", "8th_batch", "9th_batch", "10th_batch",
             "11th_batch", "12th_batch", "13th_batch", "14th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Substrate/2C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Substrate/2C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Substrate/2C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Substrate/2C/daily_temp_substrate_2C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Substrate/2C/daily_temp_warmest_days_substrate_2C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Substrate/2C/overall_temp_warmest_days_substrate_2C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Substrate/2C/missing_coordinates.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Substrate/2C/missing_coordinates_row_n.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Substrate/2C/row_n_duplicated_coordinates.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Substrate/2C/duplicated_coordinates.rds")
```


### **Future climate (+4C)**  {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**

```{r, eval=F}
# # Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 2700)  # Set a global timeout for 45 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  # Check if current index falls within any of the problematic ranges
  ERR <- 1.5
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=4,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=4,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 300, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[,3:4]
  distinct_coord <- rename(distinct_coord, 
                           x= lon,
                           y= lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 2700)  # Set a global timeout for 45 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Substrate/4C/results/1st_batch/results_biophysical_modelling_substrate_future4C_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval =F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch", 
             "6th_batch", "7th_batch", "8th_batch", "9th_batch", "10th_batch",
             "11th_batch", "12th_batch", "13th_batch", "14th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Substrate/4C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Substrate/4C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Substrate/4C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)


#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')
# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Substrate/4C/daily_temp_substrate_4C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Substrate/4C/daily_temp_warmest_days_substrate_4C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Substrate/4C/overall_temp_warmest_days_substrate_4C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Substrate/4C/missing_coordinates.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Substrate/4C/missing_coordinates_row_n.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Substrate/4C/row_n_duplicated_coordinates.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Substrate/4C/duplicated_coordinates.rds")
```

##

## **Ponds or wetlands**  

### **Current climate** {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**
```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 3600)  # Set a global timeout for 1 hour


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=0,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
    micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=0,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
        micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(
        container=1, # container model
        conth=1500, # shallow pond of 1.5m depth
        contw=12000,# pond of 12m width
        contype=1, # container sunk into the ground like a pond
        rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
        continit = 1500, # Initial container water level (1.5m)
        conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
        contwet=100, # 100% of container surface area acting as free water exchanger
        contonly=1)
      
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 2000, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}

```

#### **Function to process coordinates in chunks** 

Processing the coordinates in chunks is very useful for debugging. 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 3600)  # Set a global timeout for 60 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Pond/current/results/1st_batch/results_biophysical_modelling_pond_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations**

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()

```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval =F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", 
             "21st_batch", "22nd_batch", "23rd_batch", 
             "31st_batch", "32nd_batch", "33rd_batch")
folders2 <- paste0(4:20, "th_batch")
folders3 <- paste0(24:30, "th_batch")
folders4 <- paste0(34:36, "th_batch")

folders <- c(folders, folders2, folders3, folders4)

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Pond/current/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Pond/current/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Pond/current/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')
# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Pond/current/daily_temp_pond.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Pond/current/daily_temp_warmest_days_pond.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Pond/current/overall_temp_warmest_days_pond.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Pond/current/missing_coordinates.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Pond/current/missing_coordinates_row_n.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Pond/current/row_n_duplicated_coordinates.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Pond/current/duplicated_coordinates.rds")

```


### **Future climate (+2C)** {.tabset .tabset_fade .tabset_pills}

Here, we assume a climate projection assuming 2 degrees of warming. 

#### **Function to process coordinates**

```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 3600)  # Set a global timeout for 60 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=2,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
    micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=2,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
        micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(
        container=1, # container model
        conth=1500, # shallow pond of 1.5m depth
        contw=12000,# pond of 12m width
        contype=1, # container sunk into the ground like a pond
        rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
        continit = 1500, # Initial container water level (1.5m)
        conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
        contwet=100, # 100% of container surface area acting as free water exchanger
        contonly=1)
      
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 2000, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 3600)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Pond/2C/results/1st_batch/results_biophysical_modelling_pond_future2C_", start_index, "-", end_index, ".rds"))
  
}
```



#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval=F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", 
             "21st_batch", "22nd_batch", "23rd_batch", 
             "31st_batch", "32nd_batch", "33rd_batch")
folders2 <- paste0(4:20, "th_batch")
folders3 <- paste0(24:30, "th_batch")
folders4 <- paste0(34:36, "th_batch")

folders <- c(folders, folders2, folders3, folders4)

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Pond/2C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Pond/2C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Pond/2C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Pond/2C/daily_temp_pond_2C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Pond/2C/daily_temp_warmest_days_pond_2C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Pond/2C/overall_temp_warmest_days_pond_2C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Pond/2C/missing_coordinates_2C.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Pond/2C/missing_coordinates_row_n_2C.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Pond/2C/row_n_duplicated_coordinates_2C.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Pond/2C/duplicated_coordinates_2C.rds")
```

### **Future climate (+4C)**  {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**

```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 3600)  # Set a global timeout for 60 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=4,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 0.01,
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
    micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=4,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 0.01,
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
        micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 13] <- 0 # Make sure the pond stays in the shade
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(
        container=1, # container model
        conth=1500, # shallow pond of 1.5m depth
        contw=12000,# pond of 12m width
        contype=1, # container sunk into the ground like a pond
        rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
        continit = 1500, # Initial container water level (1.5m)
        conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
        contwet=100, # 100% of container surface area acting as free water exchanger
        contonly=1)
      
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 2000, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
  
  data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 3600)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Pond/4C/results/1st_batch/results_biophysical_modelling_pond_future4C_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 14092

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval =F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", 
             "21st_batch", "22nd_batch", "23rd_batch", 
             "31st_batch", "32nd_batch", "33rd_batch")
folders2 <- paste0(4:20, "th_batch")
folders3 <- paste0(24:30, "th_batch")
folders4 <- paste0(34:36, "th_batch")

folders <- c(folders, folders2, folders3, folders4)

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Pond/4C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Pond/4C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Pond/4C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')
# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Pond/4C/daily_temp_pond_4C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Pond/4C/daily_temp_warmest_days_pond_4C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Pond/4C/overall_temp_warmest_days_pond_4C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Pond/4C/missing_coordinates_4C.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Pond/4C/missing_coordinates_row_n_4C.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Pond/4C/row_n_duplicated_coordinates_4C.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Pond/4C/duplicated_coordinates_4C.rds")

```

##

## **Above-ground vegetation** 

### **Filter data to arboreal or semi-arboreal species** 

```{r, eval=F}
'%!in%' <- function(x,y)!('%in%'(x,y)) # Function opposite of %in%

# Generate list of coordinates for arboreal species, specifically 
data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")

data_for_imp <- data_for_imp %>%
  mutate(arboreal = ifelse(ecotype == "Arboreal" |
                             second_ecotype == "Arboreal" |
                             second_ecotype == "Semi-arboreal" |
                             second_ecotype == "Semi-Arboreal", "yes", "no")) %>% 
  mutate(arboreal = ifelse(is.na(arboreal)==TRUE, "no", arboreal))

data_arboreal <- filter(data_for_imp, arboreal =="yes")

saveRDS(data_arboreal, file="RData/General_data/data_arboreal_sp.rds")

### Adjust species coordinates 
species_coordinates_adj <- readRDS(file='RData/General_data/species_coordinates_adjusted.rds')
species_coordinates_adj_arboreal <- species_coordinates_adj[species_coordinates_adj$tip.label %in% data_arboreal$tip.label, ]

saveRDS(species_coordinates_adj_arboreal, file="RData/General_data/species_coordinates_adjusted_arboreal.rds")


# Now get list of unique coordinates
distinct_coord <- distinct(dplyr::select(species_coordinates_adj_arboreal, -Presence, -tip.label))
distinct_coord <- distinct_coord %>% rename(x = original_lon, 
                                            y = original_lat)

saveRDS(distinct_coord, file="RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
```


### **Current climate** {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**
```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=0,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 2, # 2 meters above ground
                          windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                          microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=0,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 2, # 2 meters above ground
                              windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                              microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2m)
  micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2m)
  micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2m)
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 200, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}
```

#### **Function to process coordinates in chunks** 

Processing the coordinates in chunks is very useful for debugging. 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")
  
  data <- readRDS(file="RData/General_data/data_arboreal_sp.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Arboreal/current/results/1st_batch/results_biophysical_modelling_arboreal_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations**

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 6614

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()

```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval=F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch", "6th_batch", "7th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Arboreal/current/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Arboreal/current/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Arboreal/current/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Arboreal/current/daily_temp_arboreal.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Arboreal/current/daily_temp_warmest_days_arboreal.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Arboreal/current/overall_temp_warmest_days_arboreal.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Arboreal/current/missing_coordinates.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Arboreal/current/missing_coordinates_row_n.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Arboreal/current/row_n_duplicated_coordinates.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Arboreal/current/duplicated_coordinates.rds")

```

### **Future climate (+2C)** {.tabset .tabset_fade .tabset_pills}

Here, we assume a climate projection assuming 2 degrees of warming. 

#### **Function to process coordinates**

```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=2,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 2, # 2 meters above ground
                          windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                          microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=2,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 2, # 2 meters above ground
                              windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                              microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2m)
  micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2m)
  micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2m)
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 200, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}

```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")
  
  data <- readRDS(file="RData/General_data/data_arboreal_sp.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Arboreal/2C/results/1st_batch/results_biophysical_modelling_arboreal_future2C_", start_index, "-", end_index, ".rds"))
  
}
```

#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 6614

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval=F}

# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch", "6th_batch", "7th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Arboreal/2C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Arboreal/2C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Arboreal/2C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Arboreal/2C/daily_temp_arboreal_2C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Arboreal/2C/daily_temp_warmest_days_arboreal_2C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Arboreal/2C/overall_temp_warmest_days_arboreal_2C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Arboreal/2C/missing_coordinates_2C.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Arboreal/2C/missing_coordinates_row_n_2C.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Arboreal/2C/row_n_duplicated_coordinates_2C.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Arboreal/2C/duplicated_coordinates_2C.rds")
```

### **Future climate (+4C)**  {.tabset .tabset_fade .tabset_pills}

#### **Function to process coordinates**

```{r, eval=F}
# Set up parallel processing
plan(multicore(workers=16))

# Set the global timeout
options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes


# Function to process each location
process_location <- function(loc) {
  
  print(paste("Processing location with lon =", loc$lon, "lat =", loc$lat))
  
  # Set parameters
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  coords<- c(loc$lon, loc$lat)
  
  ERR <- 1.5  # Adjusting ERR based on the locations (locations with snow sometimes need a higher value)
  
  micro_result <- withTimeout({
    NicheMapR::micro_ncep(loc = coords, 
                          dstart = dstart, 
                          dfinish = dfinish, 
                          scenario=4,
                          minshade=85,
                          maxshade=90,
                          Usrhyt = 2, # 2 meters above ground
                          windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                          microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                          cap = 1,
                          ERR = ERR, 
                          spatial = 'data/NCEP',
                          terra_source = 'data/TerraClimate/data')
  }, timeout = 600, onTimeout = "warning")
  
  # If the process takes longer than 10 minutes, break.
  
  if (inherits(micro_result, "try-error") || is.null(micro_result)) {
    print(paste("micro_ncep exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "micro_ncep exceeded time limit"))
  } else {
    micro <- micro_result
  }
  
  
  # When the first micro_ncep fails, try again with different ERR
  if (max(micro$metout[,1] == 0)) {
    while(max(micro$metout[,1] == 0)){
      ERR <- ERR + 0.5
      
      # Use withTimeout() for the micro_ncep() function inside the while loop as well
      micro_result <- withTimeout({
        NicheMapR::micro_ncep(loc = coords, 
                              dstart = dstart, 
                              dfinish = dfinish, 
                              scenario=4,
                              minshade=85,
                              maxshade=90,
                              Usrhyt = 2, # 2 meters above ground
                              windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                              microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                              cap = 1,
                              ERR = ERR, 
                              spatial = 'data/NCEP',
                              terra_source = 'data/TerraClimate/data')
      }, timeout = 600, onTimeout = "warning")
      
      if (inherits(micro_result, "try-error") || is.null(micro_result)) {
        print(paste("micro_ncep inside while loop exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
        return(list(success = FALSE, 
                    loc = c(lon = loc$lon, lat = loc$lat), 
                    error_message = "micro_ncep inside while loop exceeded time limit"))
      } else {
        micro <- micro_result
      }
      
      # If ERR exceeds 5, break the loop regardless of the value of micro$metout[,1]
      if(ERR >= 5){
        break
      }
    }
  }
  
  # If even after adjusting ERR micro_ncep fails, return an error message
  if (max(micro$metout[,1] == 0)) {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  # Another explicit check
  if (!max(micro$metout[,1] == 0)) {
    assign("micro", micro, envir = globalenv())
  } else {
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "Failed on micro_ncep call"))
  }
  
  success <- FALSE
  result <- NULL
  
  micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2m)
  micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2m)
  micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2m)
  
  # Use withTimeout() for the ectotherm() function as well
  ecto_result <- withTimeout({
    tryCatch({
      ecto <- NicheMapR::ectotherm(live=0, 
                                   Ww_g = loc$median_mass, 
                                   shape = 4, 
                                   pct_wet = 80)
      list(success = TRUE, ecto = ecto)
    }, error = function(e) {
      list(success = FALSE,
           loc = c(lon = loc$lon, lat = loc$lat),
           error_message = paste("Failed on ectotherm call:", as.character(conditionMessage(e))))
    })
  }, timeout = 200, onTimeout = "warning")
  
  if (inherits(ecto_result, "try-error") || is.null(ecto_result)) {
    print(paste("ectotherm() exceeded time limit for location with lon =", loc$lon, "lat =", loc$lat))
    return(list(success = FALSE, 
                loc = c(lon = loc$lon, lat = loc$lat), 
                error_message = "ectotherm() exceeded time limit"))
  }
  
  if(!ecto_result$success){
    return(ecto_result)
  }
  
  gc()
  
  # Assign the successful ecto result to the global environment
  ecto <- ecto_result$ecto
  assign("ecto", ecto, envir = globalenv())
  environ <- as.data.frame(ecto$environ)
  
  # Max and mean daily temperatures
  daily_temp <- environ %>%
    dplyr::mutate(YEAR = YEAR + 2004,
                  ERR = ERR) %>%
    dplyr::group_by(ERR, YEAR, DOY, lon = paste(loc$lon), lat=paste(loc$lat)) %>%
    dplyr::summarize(max_temp = max(TC),
                     mean_temp = mean(TC), .groups = 'drop')
  
  # Create a function to calculate the rolling weekly temperature
  calc_yearly_rolling_mean <- function(data) {
    data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean, align = "right", partial = TRUE, fill = NA)
    return(data)
  }
  
  # Calculate the rolling mean for each year and location
  daily_temp <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::group_modify(~calc_yearly_rolling_mean(.))
  
  # Identify the warmest 91 days (3 months) of each year
  daily_temp_warmest_days <- daily_temp %>%
    dplyr::group_by(YEAR, lon, lat) %>%
    dplyr::top_n(91, max_temp)
  
  # Calculate the mean overall maximum temperature for the warmest days of each year
  overall_temp_warmest_days <- daily_temp_warmest_days %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarize(mean = mean(max_temp),
                     median = median(max_temp),
                     fifth_percentile = quantile(max_temp, 0.05),
                     first_quartile = quantile(max_temp, 0.25),
                     third_quartile = quantile(max_temp, 0.75),
                     ninetyfifth_percentile = quantile(max_temp, 0.95),
                     min = min(max_temp),
                     max = max(max_temp), .groups = 'drop')
  
  result <- list(daily_temp, 
                 daily_temp_warmest_days, 
                 overall_temp_warmest_days)
  
  return(list(success = ecto_result$success, result = result)) # Return a list with a success flag and the result.
  
}

```

#### **Function to process coordinates in chunks** 

```{r, eval=F}
# Function to process a chunk of locations
process_chunk <- function(start_index, end_index) {
  # Read in distinct coordinates
  distinct_coord<- readRDS(file="RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
  
  distinct_coord <- distinct_coord[, 3:4]
  distinct_coord <- rename(distinct_coord, x = lon, y = lat)
  
  # Adjust the range of locations
  distinct_coord <- distinct_coord[start_index:end_index,]
  loc_list <- split(distinct_coord, seq(nrow(distinct_coord)))
  loc_list <- lapply(loc_list, unlist)
  
  # Match body mass data to coordinates
  presence <- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")
  
  data <- readRDS(file="RData/General_data/data_arboreal_sp.rds")
  
  presence_body_mass <- merge(presence, dplyr::select(data, tip.label, body_mass), by = "tip.label")
  median_body_mass <- presence_body_mass %>%
    dplyr::group_by(lon, lat) %>%
    dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
    dplyr::ungroup()
  
  median_body_mass <- mutate(median_body_mass,
                             median_mass = ifelse(is.na(median_mass)==TRUE,
                                                  8.4,
                                                  median_mass))
  
  # Convert loc_list back into a data frame
  loc_df <- do.call("rbind", loc_list)
  loc_df <- as.data.frame(loc_df)
  names(loc_df) <- c("lon", "lat")
  
  # Join loc_df and median_body_mass
  loc_df <- dplyr::left_join(loc_df, median_body_mass, by = c("lon", "lat"))
  
  # Convert loc_df back into a list
  loc_list <- split(loc_df, seq(nrow(loc_df)))
  
  # # Set up parallel processing
  plan(multicore(workers=16))
  
  # Set the global timeout
  options(future.globals.timeout = 1800)  # Set a global timeout for 30 minutes
  
  dstart <- "01/01/2005"
  dfinish <- "31/12/2015"
  
  
  Sys.time()
  
  results <- future.apply::future_lapply(loc_list, process_location, future.packages=c("NicheMapR", 
                                                                                       "microclima", "dplyr", "zoo", "R.utils"))
  
  Sys.time()
  
  
  saveRDS(results, file=paste0("RData/Biophysical_modelling/Arboreal/4C/results/1st_batch/results_biophysical_modelling_arboreal_future4C_", start_index, "-", end_index, ".rds"))
  
}

```

#### **Process all locations** 

```{r, eval=F}
dstart <- "01/01/2005"
dfinish <- "31/12/2015"

Sys.time()

chunk_size <- 16

# Define start and end row numbers in distinct_coord
start_row <- 1
end_row <- 6614

# Calculate total chunks for the specified range
total_chunks <- ceiling((end_row - start_row + 1) / chunk_size)

# Loop through each chunk
for(i in seq(total_chunks)) {
  # Calculate start and end indices for the current chunk
  start_index <- ((i - 1) * chunk_size) + start_row
  end_index <- min(i * chunk_size + start_row - 1, end_row)
  
  # Call the process_chunk function with a timeout of 600 seconds
  result <- process_chunk(start_index, end_index)
}

Sys.time()
```

#### **Combine outputs** 

Note that some coordinates failed to run with the code provided above, and hence ran using slightly different parameters (higher error tolerance for calculating soil temperatures; not in parallel session). See details [HERE]
Note also that the year 2005 was taken out as a burn in to allow the models to fully converge. 

```{r, eval=F}
# List of folders for each type of file
folders <- c("1st_batch", "2nd_batch", "3rd_batch", "4th_batch", "5th_batch", "6th_batch", "7th_batch")

# Initialize empty lists to store the combined dataframes
combined_daily_temp <- list()
combined_daily_temp_warmest_days <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the folder
  path_to_rds <- paste("RData/Biophysical_modelling/Arboreal/4C/results", folder, sep = "/")
  
  # Get the list of all rds files in the folder
  rds_files <- list.files(path = path_to_rds, pattern = "*.rds", full.names = TRUE)
  
  # Read all the files into a list
  nested_list_results <- lapply(rds_files, readRDS)
  
  # Extract 'result' from each sublist in nested_list_results
  nested_list_results <- lapply(nested_list_results, function(x) lapply(x, function(y) y[["result"]]))
  
  # Flatten the list
  flattened_list <- do.call("c", nested_list_results)
  
  # Combine all dataframes for each metric and store them in the respective lists
  combined_daily_temp[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[1]]))
  combined_daily_temp_warmest_days[[folder]] <- do.call("rbind", lapply(flattened_list, function(x) x[[2]]))
}

# Combine the dataframes from all folders
combined_daily_temp <- do.call("rbind", combined_daily_temp)
combined_daily_temp_warmest_days <- do.call("rbind", combined_daily_temp_warmest_days)

# Convert to numeric values
combined_daily_temp$lon <- as.numeric(combined_daily_temp$lon)
combined_daily_temp$lat <- as.numeric(combined_daily_temp$lat)

combined_daily_temp_warmest_days$lon <- as.numeric(combined_daily_temp_warmest_days$lon)
combined_daily_temp_warmest_days$lat <- as.numeric(combined_daily_temp_warmest_days$lat)

######################################################################################################

# Initialize empty lists to store the combined dataframes
combined_daily_temp_problematic <- list()
combined_daily_temp_warmest_days_problematic <- list()

# Loop over each folder
for (folder in folders) {
  # Get the path to the subfolder "problematic_locations"
  path_to_subfolder <- paste("RData/Biophysical_modelling/Arboreal/4C/results", folder, "problematic_locations", sep = "/")
  
  # Check if the subfolder exists
  if (dir.exists(path_to_subfolder)) {
    # Get the list of all rds files in the subfolder
    rds_files <- list.files(path = path_to_subfolder, pattern = "*.rds", full.names = TRUE)
    
    # Read all the files into a list
    nested_list_results <- lapply(rds_files, readRDS)
    
    # Extract the four dataframes from each list and unlist 'lat' and 'lon' columns
    combined_daily_temp_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[1]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    combined_daily_temp_warmest_days_subfolder <- do.call("rbind", lapply(nested_list_results, function(x) {
      df <- x[[2]]
      if (is.list(df$lat)) df$lat <- unlist(df$lat)
      if (is.list(df$lon)) df$lon <- unlist(df$lon)
      df
    }))
    
    # Store the combined dataframes in the respective lists
    combined_daily_temp_problematic[[folder]] <- combined_daily_temp_subfolder
    combined_daily_temp_warmest_days_problematic[[folder]] <- combined_daily_temp_warmest_days_subfolder
  }
}

# Combine the dataframes from all subfolders
combined_daily_temp_problematic <- do.call("rbind", combined_daily_temp_problematic)
combined_daily_temp_warmest_days_problematic <- do.call("rbind", combined_daily_temp_warmest_days_problematic)

#################################################################################################################

# Get the path to the "failed_locations" folder
path_to_failed_locations <- "RData/Biophysical_modelling/Arboreal/4C/results/failed_locations"

# Initialize empty lists to store the combined dataframes
combined_daily_temp_failed <- list()
combined_daily_temp_warmest_days_failed <- list()

# Get the list of .rds files in the "failed_locations" folder
rds_files_failed <- list.files(path = path_to_failed_locations, pattern = "*.rds", full.names = TRUE)

# Loop over each .rds file
for (file_failed in rds_files_failed) {
  # Read the .rds file into a list
  nested_list_results_failed <- readRDS(file_failed)
  
  # Extract the four dataframes from the list
  combined_daily_temp_failed_subfolder <- nested_list_results_failed[["result"]][[1]]
  combined_daily_temp_warmest_days_failed_subfolder <- nested_list_results_failed[["result"]][[2]]

  # Store the combined dataframes in the respective lists
  combined_daily_temp_failed[[file_failed]] <- combined_daily_temp_failed_subfolder
  combined_daily_temp_warmest_days_failed[[file_failed]] <- combined_daily_temp_warmest_days_failed_subfolder
}

# Combine the dataframes from all files in the "failed_locations" folder
combined_daily_temp_failed <- do.call("rbind", combined_daily_temp_failed)
combined_daily_temp_warmest_days_failed <- do.call("rbind", combined_daily_temp_warmest_days_failed)

#####################################################################################################

# Combine files
combined_daily_temp_all <- rbind(combined_daily_temp, combined_daily_temp_problematic, combined_daily_temp_failed)
combined_daily_temp_warmest_days_all <- rbind(combined_daily_temp_warmest_days, combined_daily_temp_warmest_days_problematic, combined_daily_temp_warmest_days_failed)

# Remove the first year (burn-in)
combined_daily_temp_all <- filter(combined_daily_temp_all, YEAR!="2005")
combined_daily_temp_warmest_days_all <- filter(combined_daily_temp_warmest_days_all, YEAR!="2005")

# Calculate the overall temperature across coordinates
combined_overall_temp_all <- combined_daily_temp_warmest_days_all %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarize(mean = mean(max_temp),
                   median = median(max_temp),
                   fifth_percentile = quantile(max_temp, 0.05),
                   first_quartile = quantile(max_temp, 0.25),
                   third_quartile = quantile(max_temp, 0.75),
                   ninetyfifth_percentile = quantile(max_temp, 0.95),
                   min = min(max_temp),
                   max = max(max_temp), .groups = 'drop')

# Save files
saveRDS(combined_daily_temp_all, file= "RData/Biophysical_modelling/Arboreal/4C/daily_temp_arboreal_4C.rds")
saveRDS(combined_daily_temp_warmest_days_all, file="RData/Biophysical_modelling/Arboreal/4C/daily_temp_warmest_days_arboreal_4C.rds")
saveRDS(combined_overall_temp_all, file="RData/Biophysical_modelling/Arboreal/4C/overall_temp_warmest_days_arboreal_4C.rds")


####################################################################################################

## Check for missing coordinates again

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- mutate(distinct_coord, lon_lat = paste(lon, lat))

combined_daily_temp_warmest_days_all <- mutate(combined_daily_temp_warmest_days_all, lon_lat = paste(lon, lat))

# Function opposite of %in%
'%!in%' <- function(x,y)!('%in%'(x,y)) 

missing_coord <- distinct_coord[distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat,]
missing_coord
missing_coord_row_numbers <- data.frame(row_n = which(distinct_coord$lon_lat %!in% combined_daily_temp_warmest_days_all$lon_lat))
missing_coord_row_numbers

### 
check_dup<- group_by(combined_daily_temp_all, lon, lat, YEAR, DOY) %>% summarise(n=n())
loc_with_more_than_one<- filter(check_dup, n>1)
loc_with_more_than_one<- mutate(loc_with_more_than_one, lon_lat = paste(lon, lat))
row_n_dup<- data.frame(row_n = which(distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat))
row_n_dup
dup_coord <- distinct_coord[distinct_coord$lon_lat %in% loc_with_more_than_one$lon_lat,]
dup_coord

# Save the combined data
saveRDS(missing_coord, file= "RData/Biophysical_modelling/Arboreal/4C/missing_coordinates_4C.rds")
saveRDS(missing_coord_row_numbers, file="RData/Biophysical_modelling/Arboreal/4C/missing_coordinates_row_n_4C.rds")
saveRDS(row_n_dup, file="RData/Biophysical_modelling/Arboreal/4C/row_n_duplicated_coordinates_4C.rds")
saveRDS(dup_coord, file="RData/Biophysical_modelling/Arboreal/4C/duplicated_coordinates_4C.rds")
```

##


# **Data imputation** {.tabset .tabset_fade .tabset_pills}

Here, the data was imputed assuming that animals were acclimated to either the median, 5% or 95% percentile mean maximum temperature experienced across their range of distribution in the warmest three-months of each year. 

## **Add ecologicall-relevant temperatures to the training data** 

This code ran on an HPC environment, where the original code can be found in **R/Data_wrangling/Adding_temperatures_to_data_for_imputation.R** and the resources used in **pbs/Data_wrangling/Adding_temperatures_to_data_for_imputation.pbs** 


```{r, eval=F}
## Load preliminary data for imputation
data_for_imp <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")

## Load occurence data
species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")
# Combine temperature data 

### Maximum temperature

overall_temp<-readRDS("Rdata/Biophysical_modelling/Substrate/current/overall_temp_warmest_days_substrate.rds")

overall_temp$lon <- as.numeric(overall_temp$lon)
overall_temp$lat <- as.numeric(overall_temp$lat)

# Merge coordinates with the mean maximum temperature of the warmest days across the species distribution
species_occurrence_temp <- merge(species_occurrence, overall_temp, by.x = c("lat", "lon"), by.y = c("lat", "lon"))

# Group by species and calculate mean for each variable
species_temp_values <- species_occurrence_temp %>%
  group_by(tip.label) %>%
  summarize(
    mean_mean = mean(mean),
    mean_median = mean(median),
    mean_fifth_percentile = mean(fifth_percentile),
    mean_first_quartile = mean(first_quartile),
    mean_third_quartile = mean(third_quartile),
    mean_ninetyfifth_percentile = mean(ninetyfifth_percentile),
    mean_min = mean(min),
    mean_max = mean(max),
    .groups = 'drop'
  )


# Filter the relevant columns (here adding data from the 5th and 95th percentiles)
species_temp_values_filtered <- species_temp_values %>% 
  dplyr::select(tip.label, mean_median, mean_fifth_percentile, mean_ninetyfifth_percentile)

# Pivot the data frame into long format
species_temp_values_long <- species_temp_values_filtered %>% 
  pivot_longer(cols = c(mean_median, mean_fifth_percentile, mean_ninetyfifth_percentile),
               names_to = "temp_range",
               values_to = "acclimation_temp") %>% 
  mutate(tip.label = gsub("\\.", "_", tip.label), # replace dots with underscores
         temp_range = gsub("^mean_", "", temp_range)) # remove "mean_" from temp_range

# Reorder the columns
species_temp_values_long <- species_temp_values_long %>% 
  dplyr::select(tip.label, temp_range, acclimation_temp)

# Rename the "mean_median" column to "median", etc.
names(species_temp_values_long)[2:3] <- c("temp_range", "acclimation_temp")
species_temp_values_long$tip.label <-  gsub("_", " ", species_temp_values_long$tip.label)

# Join with data for imputation

species_temp_values_long$tip.label[species_temp_values_long$tip.label=="Scinax x signatus"] <- "Scinax x-signatus" # Rename
species_temp_values_long$tip.label[species_temp_values_long$tip.label=="Pristimantis w nigrum"] <- "Pristimantis w-nigrum" # Rename

# Split data_for_imp into two data frames
data_for_imp_nonNA <- data_for_imp %>% 
  filter(!is.na(acclimation_temp))

data_for_imp_NA <- data_for_imp %>% 
  filter(is.na(acclimation_temp)) %>% 
  dplyr::select(-acclimation_temp)  # Remove the NA acclimation_temp column


# Perform a full join on data_for_imp_NA and species_temp_values_long
data_for_imp_NA <- full_join(data_for_imp_NA, species_temp_values_long, by = "tip.label")

# Combine the two data frames
data_for_imp_with_temp <- bind_rows(data_for_imp_nonNA, data_for_imp_NA)


saveRDS(data_for_imp_with_temp, file="RData/General_data/data_for_imputation_with_temp.rds")

```


## **Function to perfom the imputation** 

The .R file for this code can be found in **R/Imputation/Functions_BACE.R** 

```{r, eval=F}
#######################
#  supporting functions
######################

# these functions below are from: https://github.com/matthiasspeidel/hmi

#' Standardizing function
#'
#' Function to standardize variables that are numeric (continuous and count variables) but no rounded continuous, semicontinuous, intercepts or categorical variables.
#' @param X A n times p data.frame with p fixed (or random) effects variables.
#' @return A n times p data.frame with the standardized versions of the numeric variables.
#' @export
stand <- function(X){
  # if(!is.data.frame(X)) stop("X has to be a data.frame.")
  # if(ncol(X) == 0) return(X)
  # types <- array(NA, dim = ncol(X))
  # for(i in 1:length(types)){
  #   types[i] <- get_type(X[, i])
  # }
  # need_stand_X <- types %in% c("cont", "count", "roundedcont", "semicont")
  X_stand <- X
  tmp <- scale(X)
  X_stand <- matrix(tmp, ncol = ncol(tmp)) # this avoids having attributes delivered by scale().
  return(X_stand)
}

#' Sample imputation.
#'
#' Function to sample values in a variable from other (observed) values in this variable.
#' So this imputation does not use further covariates.
#' @param variable A vector of size \code{n} with missing values.
#' @return A list with a n times 1 data.frame without missing values and
#'  a list with the chains of the Gibbs-samples for the fixed effects and variance parameters.
#' @examples
#' set.seed(123)
#' sample_imp(c(1, NA, 3, NA, 5))
#' @export
sample_imp <- function(variable){
  
  if(is.data.frame(variable)){
    stop("You passed a data.frame instead of a vector to sample_imp.")
  }
  if(all(is.na(variable))) stop("Variable consists only of NAs.")
  
  ret <- data.frame(target = variable)
  
  
  
  need_replacement <- is.na(variable) | is.infinite(variable)
  ret[need_replacement, 1] <- sample(size = sum(need_replacement),
                                     variable[!need_replacement], replace = TRUE)
  return(ret)
}





#####################
# imputation function
#####################

# inter = muitplier for iteration 
b_mice <- function(cycle = 1, 
                   data = dat, 
                   Ainv = Ainv,
                   iter1 = 10, 
                   iter2 = 20, 
                   iter3 = 60){
  
  


  
  # Standard deviation of thermal tolerance estimates (sd_UTL)
  #######################
  
  # formula
  forms_sd_UTL <- as.formula(paste("ln_sd_UTL ~ 
                                    life_stage_tested +", 
                                   "acclimation_temp", "+",
                                   "endpoint2", "+",
                                   "acclimated", "+",
                                   paste0("ln_acclimation_time_stand",  cycle), "+",
                                   paste0("medium_test_temp2_fill", cycle), "+",
                                   paste0("ramping_stand", cycle), "+",
                                   paste0("mean_UTL_stand", cycle)))
  
  prior_sd_UTL<- list(R = list(V = 1, nu = 0.002), 
                      G = list( G1 = list(V = 1, nu = 0.002, 
                                          alpha.mu = 0, 
                                          alpha.V = 1000)))
  # model
  mod_sd_UTL <- MCMCglmm(forms_sd_UTL,
                         random = ~ species,
                         pl = TRUE,
                         pr = TRUE,
                         nitt=13000*iter1, 
                         thin=10*iter1, 
                         burnin=3000*iter1,
                         singular.ok=TRUE,
                         verbose=FALSE,
                         prior = prior_sd_UTL,
                         data = data)
  # processing
  pre_sd_UTL <- as.vector(predict(mod_sd_UTL, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]] <- 
    data$ln_sd_UTL
  # filling in with predicted values
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]][sd_UTL_mpos] <- 
    pre_sd_UTL[sd_UTL_mpos]
  data[[paste0("ln_sd_UTL_stand", cycle + 1)]] <-
    stand(data[[paste0("ln_sd_UTL_stand", cycle + 1)]])[,1]
  
  # Adding variance column 
  data[[paste0("var_UTL_stand", cycle + 1)]] <- 
    (data[[paste0("ln_sd_UTL_stand", cycle + 1)]])^2
  
  
  
  #data
  print("1 out of 5 models done")
  
  
  
  
  # Acclimation time
  #######################
  
  # formula
  forms_acclimation_time <- as.formula(paste("ln_acclimation_time ~ 
                                              life_stage_tested +", 
                                             paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                             paste0("mean_UTL_stand", cycle)))
  
  prior_acclimation_time<- list(R = list(V = 1, nu = 0.002), 
                                G = list( G1 = list(V = 1, nu = 0.002, 
                                                    alpha.mu = 0, 
                                                    alpha.V = 1000)))
  # model
  mod_acclimation_time <- MCMCglmm(forms_acclimation_time,
                                   random = ~ species,
                                   pl = TRUE,
                                   pr = TRUE,
                                   nitt=13000*iter1, 
                                   thin=10*iter1, 
                                   burnin=3000*iter1,
                                   singular.ok=TRUE,
                                   verbose=FALSE,
                                   prior = prior_acclimation_time,
                                   data = data)
  # processing
  pre_acclimation_time <- as.vector(predict(mod_acclimation_time, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]] <- 
    data$ln_acclimation_time
  # filling in with predicted values
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]][acclimation_time_mpos] <- 
    pre_acclimation_time[acclimation_time_mpos]
  data[[paste0("ln_acclimation_time_stand", cycle + 1)]] <-
    stand(data[[paste0("ln_acclimation_time_stand", cycle + 1)]])[,1]
  
  #data
  print("2 out of 5 models done")
  
  
  # Ramping rate
  ################
  
  # formula
  forms_ramping <- as.formula(paste("ramping ~ 
                                    life_stage_tested +",
                                    paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                    paste0("mean_UTL_stand", cycle)))
  
  # prior
  prior_ramping <- list(R = list(V = 1, nu = 0.002), 
                        G = list( G1 = list(V = 1, nu = 0.002, 
                                            alpha.mu = 0, 
                                            alpha.V = 1000)))
  # model
  mod_ramping <- MCMCglmm(forms_ramping,
                          random = ~ species,
                          pl = TRUE,
                          pr = TRUE,
                          nitt=13000*iter1, 
                          thin=10*iter1, 
                          burnin=3000*iter1,
                          singular.ok=TRUE,
                          prior = prior_ramping,
                          verbose=FALSE,
                          data = data)
  # processing
  pre_ramping <- as.vector(predict(mod_ramping, marginal = NULL)) # prediction
  # creating a new variable
  data[[paste0("ramping_stand", cycle + 1)]] <- 
    data$ramping
  # filling in with predicted values
  data[[paste0("ramping_stand", cycle + 1)]][ramping_mpos] <- 
    pre_ramping[ramping_mpos]
  data[[paste0("ramping_stand", cycle + 1)]] <-
    stand(data[[paste0("ramping_stand", cycle + 1)]])[,1]
  
  #data
  print("3 out of 5 models done")
  
  # Medium for measuring CTmax (ambient, water/body)
  ################
  
  # formula
  forms_medium <- as.formula(paste("medium_test_temp2 ~ 
                                   life_stage_tested +", 
                                   paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                   paste0("mean_UTL_stand", cycle)))
  
  forms_medium_prior  <- as.formula(paste(" ~ life_stage_tested +",
                                          paste0("ln_sd_UTL_stand", cycle + 1), "+",
                                          paste0("mean_UTL_stand", cycle)))
  
  
  # prior
  prior_medium <-list(B = list(mu = rep(0,4), 
                               V=gelman.prior(forms_medium_prior,
                                              data = data, 
                                              scale=sqrt(1+1))),
                      R = list(V=1, fix =1), 
                      G = list(G1 = list(V = 1, nu = 0.002, 
                                         alpha.mu = 0, 
                                         alpha.V = 1000)))
  # model
  mod_medium <- MCMCglmm(forms_medium,
                         random = ~ species,
                         ginverse=list(tip.label = Ainv),
                         pl = TRUE,
                         pr = TRUE,
                         family = "threshold", 
                         nitt=13000*iter3, 
                         thin=10*iter3, 
                         burnin=3000*iter3,
                         singular.ok=TRUE,
                         prior = prior_medium,
                         verbose=FALSE,
                         data = data)
  # processing
  pre_medium <- as.vector(predict(mod_medium, marginal = NULL)) # prediction
  pre_medium_b<- levels(data$medium_test_temp2)[round(pre_medium,0)+1]
  # creating a new variable
  data[[paste0("medium_test_temp2_fill", cycle + 1)]] <- 
    data$medium_test_temp2
  # filling in with predicted values
  data[[paste0("medium_test_temp2_fill", cycle + 1)]][medium_test_temp2_mpos] <- 
    pre_medium_b[medium_test_temp2_mpos]
  
  #data 
  print("4 out of 5 models done")
  
  # Thermal tolerance (mean_UTL)
  ################
  
  # formula
  forms_mean_UTL <- as.formula(paste("mean_UTL ~ 
                                   acclimation_temp_stand +", 
                                   paste0("ln_acclimation_time_stand",  cycle + 1), "+",
                                   paste0("ramping_stand",  cycle + 1), "+",
                                   paste0("medium_test_temp2_fill", cycle + 1), "+",
                                   "endpoint2", "+",
                                   "acclimated" , "+",
                                   "life_stage_tested", "+",
                                   "ecotype"))
  
  # prior
  prior_mean_UTL <- list(R = list(V = 1, nu = 0.002), 
                         G = list( G1 = list(V = diag(2)/2, nu = 2, 
                                             alpha.mu = rep(0,2), 
                                             alpha.V = diag(2)*1000),
                                   G2 = list(V = diag(2)/2, nu = 2, 
                                             alpha.mu = rep(0,2), 
                                             alpha.V = diag(2)*1000))
  )
  
  
  mev <- noquote(paste0("var_UTL_stand", cycle + 1)) # Variance for mev argument
  
  
  # model
  mod_mean_UTL <- MCMCglmm(forms_mean_UTL,
                           random = ~
                             us(1+acclimation_temp_stand):tip.label + 
                             us(1+acclimation_temp_stand):species,
                           ginverse=list(tip.label = Ainv),
                           pl = TRUE,
                           pr = TRUE,
                           nitt=13000*iter3, 
                           thin=10*iter3, 
                           burnin=3000*iter3,
                           singular.ok=TRUE,
                           prior = prior_mean_UTL,
                           verbose=FALSE,
                           mev=data$mev,
                           data = data)
  
  print("5 out of 5 models done")
  
  # processing
  predictions <- predict(mod_mean_UTL, marginal = NULL, interval = "confidence") # prediction
  pre_mean_UTL <- predictions[ , 1]
  data[["lower_mean_UTL"]] <- predictions[ , 2]
  data[["upper_mean_UTL"]] <- predictions[ , 3]
  # creating a new variable
  data[[paste0("mean_UTL_stand", cycle + 1)]] <- 
    data$mean_UTL
  # filling in with predicted values
  data[[paste0("mean_UTL_stand", cycle + 1)]][mean_UTL_mpos] <- 
    pre_mean_UTL[mean_UTL_mpos]
  data[[paste0("mean_UTL_stand", cycle + 1)]] <-
    data[[paste0("mean_UTL_stand", cycle + 1)]]
  data[[paste0("filled_mean_UTL", cycle)]] <- 
    data[[paste0("mean_UTL_stand", cycle + 1)]] # row estimation
  data[[paste0("mean_UTL_stand", cycle + 1)]] <- 
    stand(data[[paste0("mean_UTL_stand", cycle + 1)]])[,1]
  
  data
}  

```


## **Data processing** 

This code can be found in **R/Imputation/Running_imputation.R** 

```{r, eval=F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/General_data/data_for_imputation_with_temp.rds")


# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0
```

## **Run imputation**

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_imputation.R** and the resources used in **pbs/Imputation/Running_imputation.pbs** 


```{r, eval=F}
# Cycle 1
system.time(dat1 <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1, file = "RData/Imputation/results/imputation_1st_cycle.Rds")

#########

# Cycle 2
system.time(dat2 <- b_mice(cycle = 2, data = dat1, Ainv = Ainv))

saveRDS(dat2, file = "RData/Imputation/results/imputation_2nd_cycle.Rds")

########

# Cycle 3
system.time(dat3 <- b_mice(cycle = 3, data = dat2, Ainv = Ainv))

saveRDS(dat3, file = "RData/Imputation/results/imputation_3rd_cycle.Rds")

#########

# Cycle 4
system.time(dat4 <- b_mice(cycle = 4, data = dat3, Ainv = Ainv))

saveRDS(dat4, file = "RData/Imputation/results/imputation_4th_cycle.Rds")

########

# Cycle 5
system.time(dat5 <- b_mice(cycle = 5, data = dat4, Ainv = Ainv))

saveRDS(dat5, file = "RData/Imputation/results/imputation_5th_cycle.Rds")
```

## **Run imputation cross-validation** 

### **Prepare datasets for the cross-validation** {.tabset .tabset_fade .tabset_pills}

Here, we created five datasets in which we removed heat tolerance estimates for 5% of the species in the experimental dataset (16 species), and 5% of the data-deficient species (234 species); maintaining the same proportion of missing data.

We specifically removed original data that fit the characteristics of the data to be imputed, i.e., ramping=1, # most common heating rate
      acclimated="acclimated", # acclimated animals
      endpoint="OS", # Most common endpoint; most precise one too
      life_stage_tested=="adults" # adult animals

This code can be found in **R/Data_wrangling/Generating_data_for_imputation.Rmd** 

```{r, eval = F}
data_for_imp<- readRDS("RData/General_data/data_for_imputation_with_temp.rds")

# Only consider observations that are comparable to the data we impute
training_data_for_crossV <- filter(data_for_imp, 
                                   imputed=="no" & 
                                   ramping=="1" &
                                   acclimated=="acclimated" &
                                   endpoint=="OS"&
                                   life_stage_tested=="adults") 

training_species_crossV<- distinct(data.frame(tip.label=training_data_for_crossV$tip.label)) # 77 species 

imp_data_for_crossV <- filter(data_for_imp, imputed=="yes")
imp_data_for_crossV <- imp_data_for_crossV[imp_data_for_crossV$tip.label %!in% training_data_for_crossV$tip.label, ] # Make sure we get species not in the original data
imp_species_crossV<- distinct(data.frame(tip.label=imp_data_for_crossV$tip.label)) 

```


#### **First set** 

```{r, eval = F}
### First set
set.seed(123)
first_training_sample_16sp_crossV<-data.frame(tip.label=sample(training_species_crossV$tip.label, 16)) # Sample of 16 species
first_imp_sample_234sp_crossV<-data.frame(tip.label=sample(imp_species_crossV$tip.label, 234)) # Sample of 234 species

first_crossV <- mutate(data_for_imp, sp_to_validate = ifelse((data_for_imp$tip.label %in% first_training_sample_16sp_crossV$tip.label) == TRUE, "yes", "no")) # Flag species to validate

first_crossV <- mutate(first_crossV, dat_to_validate = ifelse(sp_to_validate=="yes"&
                                                              ramping==1&
                                                              endpoint=="OS"&
                                                              life_stage_tested=="adults",
                                                              "yes", "no")) # Flag data to validate

first_crossV<-filter(first_crossV, !(dat_to_validate=="yes" & imputed=="yes")) # Remove the fake data for species we want to cross-validate

first_crossV <- mutate(first_crossV, mean_UTL = ifelse(dat_to_validate == "yes", NA, mean_UTL)) # Set values as NA for these 16 species

first_crossV <- first_crossV[first_crossV$tip.label %!in% first_imp_sample_234sp_crossV$tip.label, ] # Remove the data for 234 fully imputed species

saveRDS(first_crossV, "RData/Imputation/data/Data_crossV_1st_set.rds")
```

#### **Second set** 

```{r, eval = F}
### Second set 
remaining_sp<- data.frame(tip.label = training_species_crossV[training_species_crossV$tip.label %!in% first_training_sample_16sp_crossV$tip.label,])
  
set.seed(385)
second_training_sample_16sp_crossV<-data.frame(tip.label=sample(remaining_sp$tip.label, 16)) # Sample of 16 species
second_imp_sample_234sp_crossV<-data.frame(tip.label=sample(imp_species_crossV$tip.label, 234)) # Sample of 234 species

second_crossV <- mutate(data_for_imp, sp_to_validate = ifelse((data_for_imp$tip.label %in% second_training_sample_16sp_crossV$tip.label) == TRUE, "yes", "no")) # flag species to validate

second_crossV <- mutate(second_crossV, dat_to_validate = ifelse(sp_to_validate=="yes"&
                                                              ramping==1&
                                                              endpoint=="OS"&
                                                              life_stage_tested=="adults",
                                                              "yes", "no")) # flag data to validate

second_crossV<-filter(second_crossV, !(dat_to_validate=="yes"&imputed=="yes")) # Remove the fake data for species we want to cross-validate

second_crossV <- mutate(second_crossV, mean_UTL = ifelse(dat_to_validate == "yes", NA, mean_UTL)) # Set values as NA for these 16 species

second_crossV <- second_crossV[second_crossV$tip.label %!in% second_imp_sample_234sp_crossV$tip.label, ] # Remove the data for 234 fully imputed species

saveRDS(second_crossV, "RData/Imputation/data/Data_crossV_2nd_set.rds")

```

#### **Third set** 

```{r, eval = F}
### Third set
remaining_sp<- data.frame(tip.label=remaining_sp[remaining_sp$tip.label %!in% second_training_sample_16sp_crossV$tip.label,])
set.seed(390)
third_training_sample_16sp_crossV<-data.frame(tip.label=sample(remaining_sp$tip.label, 16)) # Sample of 16 species
third_imp_sample_234sp_crossV<-data.frame(tip.label=sample(imp_species_crossV$tip.label, 234)) # Sample of 234 species

third_crossV <- mutate(data_for_imp, sp_to_validate = ifelse((data_for_imp$tip.label %in% third_training_sample_16sp_crossV$tip.label) == TRUE, "yes", "no")) # flag species to validate

third_crossV <- mutate(third_crossV, dat_to_validate = ifelse(sp_to_validate=="yes"&
                                                                ramping==1&
                                                                endpoint=="OS"&
                                                                life_stage_tested=="adults",
                                                                "yes", "no")) # flag data relevant for validation for these species

third_crossV<-filter(third_crossV, !(dat_to_validate=="yes"&imputed=="yes")) # Remove the fake data for species we want to cross-validate

third_crossV <- mutate(third_crossV, mean_UTL = ifelse(dat_to_validate == "yes", NA, mean_UTL)) # Set values as NA for these 15 species 15 species

third_crossV <- third_crossV [third_crossV$tip.label %!in% third_imp_sample_234sp_crossV$tip.label, ] # Remove the data 234 fully-imputed species

saveRDS(third_crossV, "RData/Imputation/data/Data_crossV_3rd_set.rds")
```

#### **Fourth set** 

```{r, eval = F}
### Fourth set 
remaining_sp<- data.frame(tip.label=remaining_sp[remaining_sp$tip.label %!in% third_training_sample_16sp_crossV$tip.label,])
set.seed(369)
fourth_training_sample_16sp_crossV<-data.frame(tip.label=sample(remaining_sp$tip.label, 16)) # Sample of 16 species
fourth_imp_sample_234sp_crossV<-data.frame(tip.label=sample(imp_species_crossV$tip.label, 234)) # Sample of 234 species

fourth_crossV <- mutate(data_for_imp, sp_to_validate = ifelse((data_for_imp$tip.label %in% fourth_training_sample_16sp_crossV$tip.label) == TRUE, "yes", "no")) # flag species to validate

fourth_crossV <- mutate(fourth_crossV, dat_to_validate = ifelse(sp_to_validate=="yes"&
                                                                  ramping==1&
                                                                  endpoint=="OS"&
                                                                  life_stage_tested=="adults",
                                                                  "yes", "no")) # flag data relevant for validation for these species

fourth_crossV<-filter(fourth_crossV, !(dat_to_validate=="yes"&imputed=="yes")) # Remove the fake data for species we want to cross-validate

fourth_crossV <- mutate(fourth_crossV, mean_UTL = ifelse(dat_to_validate == "yes", NA, mean_UTL)) # Set values as NA for these 15 species 15 species

fourth_crossV <- fourth_crossV [fourth_crossV$tip.label %!in% fourth_imp_sample_234sp_crossV$tip.label, ] # Remove the data 234 fully-imputed species

saveRDS(fourth_crossV, "RData/Imputation/data/Data_crossV_4th_set.rds")
```

#### **Fifth set** 

```{r, eval = F}

### Fifth set 
remaining_sp<- data.frame(tip.label=remaining_sp[remaining_sp$tip.label %!in% fourth_training_sample_16sp_crossV$tip.label,]) # 13
set.seed(536)
fifth_training_sample_16sp_crossV<-rbind(data.frame(tip.label=sample(training_species_crossV$tip.label, 3)), 
                                   remaining_sp) # Sample of 3 extra species species because we have only 13 remaining

fifth_imp_sample_234sp_crossV<-data.frame(tip.label=sample(imp_species_crossV$tip.label, 234)) # Sample of 234 species

fifth_crossV <- mutate(data_for_imp, sp_to_validate = ifelse((data_for_imp$tip.label %in% fifth_training_sample_16sp_crossV$tip.label) == TRUE, "yes", "no")) # flag species to validate

fifth_crossV <- mutate(fifth_crossV, dat_to_validate = ifelse(sp_to_validate=="yes"&
                                                                ramping==1&
                                                                endpoint=="OS"&
                                                                life_stage_tested=="adults",
                                                                "yes", "no")) # flag data relevant for validation for these species

fifth_crossV<-filter(fifth_crossV, !(dat_to_validate=="yes"&imputed=="yes")) # Remove the fake data for species we want to cross-validate

fifth_crossV <- mutate(fifth_crossV, mean_UTL = ifelse(dat_to_validate == "yes", NA, mean_UTL)) # Set values as NA for these 15 species 15 species

fifth_crossV <- fifth_crossV [fifth_crossV$tip.label %!in% fifth_imp_sample_234sp_crossV$tip.label, ] # Remove the data 234 fully-imputed species

saveRDS(fifth_crossV, "RData/Imputation/data/Data_crossV_5th_set.rds")
```


### **Run the cross-validation** {.tabset .tabset_fade .tabset_pills}

#### **First set** 

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_cross_validation_1st_set.R** and the resources used in **pbs/Imputation/Running_cross_validation_1st_set.pbs** 

```{r, eval = F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Imputation/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/Imputation/data/Data_crossV_1st_set.rds")

# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm

length(unique(data_for_imp$species))

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0

## -------------------------------------------------------------------------------------------------------------------------------------------

# cycle 1
system.time(dat1_crossV <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1_crossV, file = "RData/Imputation/results/1st_cross_validation_1st_cycle.Rds")

#########

# cycle 2
system.time(dat2_crossV <- b_mice(cycle = 2, data = dat1_crossV, Ainv = Ainv))

saveRDS(dat2_crossV, file = "RData/Imputation/results/1st_cross_validation_2nd_cycle.Rds")

########

# cycle 3
system.time(dat3_crossV<- b_mice(cycle = 3, data = dat2_crossV, Ainv = Ainv))

saveRDS(dat3_crossV, file = "RData/Imputation/results/1st_cross_validation_3rd_cycle.Rds")

########

# cycle 4
system.time(dat4_crossV<- b_mice(cycle = 4, data = dat3_crossV, Ainv = Ainv))

saveRDS(dat4_crossV, file = "RData/Imputation/results/1st_cross_validation_4th_cycle.Rds")

########

# cycle 5
system.time(dat5_crossV<- b_mice(cycle = 5, data = dat4_crossV, Ainv = Ainv))

saveRDS(dat5_crossV, file = "RData/Imputation/results/1st_cross_validation_5th_cycle.Rds")

```

#### **Second set** 

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_cross_validation_2nd_set.R** and the resources used in **pbs/Imputation/Running_cross_validation_2nd_set.pbs** 

```{r, eval = F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Imputation/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/Imputation/data/Data_crossV_2nd_set.rds")



# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm


length(unique(data_for_imp$species))

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0

## -------------------------------------------------------------------------------------------------------------------------------------------

# cycle 1
system.time(dat1_crossV <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1_crossV, file = "RData/Imputation/results/2nd_cross_validation_1st_cycle.Rds")

#########

# cycle 2
system.time(dat2_crossV <- b_mice(cycle = 2, data = dat1_crossV, Ainv = Ainv))

saveRDS(dat2_crossV, file = "RData/Imputation/results/2nd_cross_validation_2nd_cycle.Rds")

########

# cycle 3
system.time(dat3_crossV<- b_mice(cycle = 3, data = dat2_crossV, Ainv = Ainv))

saveRDS(dat3_crossV, file = "RData/Imputation/results/2nd_cross_validation_3rd_cycle.Rds")

########

# cycle 4
system.time(dat4_crossV<- b_mice(cycle = 4, data = dat3_crossV, Ainv = Ainv))

saveRDS(dat4_crossV, file = "RData/Imputation/results/2nd_cross_validation_4th_cycle.Rds")

########

# cycle 5
system.time(dat5_crossV<- b_mice(cycle = 5, data = dat4_crossV, Ainv = Ainv))

saveRDS(dat5_crossV, file = "RData/Imputation/results/2nd_cross_validation_5th_cycle.Rds")

```

#### **Third set** 

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_cross_validation_3rd_set.R** and the resources used in **pbs/Imputation/Running_cross_validation_3rd_set.pbs** 

```{r, eval = F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Imputation/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/Imputation/data/Data_crossV_3rd_set.rds")



# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm


# Taking out missing species from the tree

length(unique(data_for_imp$species))

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0

## -------------------------------------------------------------------------------------------------------------------------------------------

# cycle 1
system.time(dat1_crossV <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1_crossV, file = "RData/Imputation/results/3rd_cross_validation_1st_cycle.Rds")

#########

# cycle 2
system.time(dat2_crossV <- b_mice(cycle = 2, data = dat1_crossV, Ainv = Ainv))

saveRDS(dat2_crossV, file = "RData/Imputation/results/3rd_cross_validation_2nd_cycle.Rds")

########

# cycle 3
system.time(dat3_crossV<- b_mice(cycle = 3, data = dat2_crossV, Ainv = Ainv))

saveRDS(dat3_crossV, file = "RData/Imputation/results/3rd_cross_validation_3rd_cycle.Rds")


########

# cycle 4
system.time(dat4_crossV<- b_mice(cycle = 4, data = dat3_crossV, Ainv = Ainv))

saveRDS(dat4_crossV, file = "RData/Imputation/results/3rd_cross_validation_4th_cycle.Rds")

########

# cycle 5
system.time(dat5_crossV<- b_mice(cycle = 5, data = dat4_crossV, Ainv = Ainv))

saveRDS(dat5_crossV, file = "RData/Imputation/results/3rd_cross_validation_5th_cycle.Rds")
```

#### **Fourth set** 

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_cross_validation_4th_set.R** and the resources used in **pbs/Imputation/Running_cross_validation_4th_set.pbs** 

```{r, eval = F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Imputation/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/Imputation/data/Data_crossV_4th_set.rds")



# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm

length(unique(data_for_imp$species))

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0

## -------------------------------------------------------------------------------------------------------------------------------------------

# cycle 1
system.time(dat1_crossV <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1_crossV, file = "RData/Imputation/results/4th_cross_validation_1st_cycle.Rds")

#########

# cycle 2
system.time(dat2_crossV <- b_mice(cycle = 2, data = dat1_crossV, Ainv = Ainv))

saveRDS(dat2_crossV, file = "RData/Imputation/results/4th_cross_validation_2nd_cycle.Rds")

########

# cycle 3
system.time(dat3_crossV<- b_mice(cycle = 3, data = dat2_crossV, Ainv = Ainv))

saveRDS(dat3_crossV, file = "RData/Imputation/results/4th_cross_validation_3rd_cycle.Rds")


########

# cycle 4
system.time(dat4_crossV<- b_mice(cycle = 4, data = dat3_crossV, Ainv = Ainv))

saveRDS(dat4_crossV, file = "RData/Imputation/results/4th_cross_validation_4th_cycle.Rds")

########

# cycle 5
system.time(dat5_crossV<- b_mice(cycle = 5, data = dat4_crossV, Ainv = Ainv))

saveRDS(dat5_crossV, file = "RData/Imputation/results/4th_cross_validation_5th_cycle.Rds")
```

#### **Fifth set** 

This code ran on an HPC environment, where the original code can be found in **R/Imputation/Running_cross_validation_5th_set.R** and the resources used in **pbs/Imputation/Running_cross_validation_5th_set.pbs** 

```{r, eval = F}
# Load functions for the Bayesian Augmentation with Chain Equations (BACE)
source("R/Imputation/Functions_BACE.R")

# Load data and tree
tree<- readRDS("RData/General_data/tree_for_imputation.rds")

# Load data
data_for_imp<- readRDS("RData/Imputation/data/Data_crossV_5th_set.rds")



# Transform variables

data_for_imp <- data_for_imp %>% 
  mutate(
    acclimated = factor(acclimated),
    life_stage_tested = factor(life_stage_tested),
    ln_acclimation_time = log(acclimation_time),
    ln_sd_UTL = log(sd_UTL),
    ln_body_mass = log(body_mass),
    medium_test_temp2 = factor(medium_test_temp),
    life_stage_tested=factor(life_stage_tested,
                             levels=c("adult", "adults", "larvae"),
                             labels=c("adults", "adults", "larvae")), # Correct typo
    endpoint2 = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other")) # Take LOE as LRR 
  )

data_for_imp<- dplyr::select(data_for_imp, -family) # Remove family to run MCMCglmm

length(unique(data_for_imp$species))

# Make sure everything matches

matchpos <- match(data_for_imp$tip.label, tree$tip.label)

data_for_imp$matchpos <- matchpos

dat <- data_for_imp %>% filter(is.na(matchpos) == F) 

tree_imputation <- drop.tip(tree, tree$tip.label[-match(dat$tip.label, tree$tip.label)]) # Pruned tree that only contains species in the data 

tree_imputation<-force.ultrametric(tree_imputation, method="extend") # Force the tree to be ultrametric

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree_imputation)$Ainv

# Standardize variables
#######################

# acclimation_temp
dat$acclimation_temp_stand<- stand(dat$acclimation_temp)[,1]

# mean_UTL
mean_UTL_mpos <- is.na(dat$mean_UTL) 
dat$mean_UTL_stand1 <- stand(dat$mean_UTL)[,1]
dat$mean_UTL_stand1[mean_UTL_mpos] <- 0


# acclimation_time
acclimation_time_mpos <- is.na(dat$ln_acclimation_time)
dat$ln_acclimation_time_stand1 <- stand(dat$ln_acclimation_time)[,1]
dat$ln_acclimation_time_stand1[acclimation_time_mpos] <- 0

# ramping
ramping_mpos <- is.na(dat$ramping) 
dat$ramping_stand1 <- stand(dat$ramping)[,1]
dat$ramping_stand1[ramping_mpos] <- 0

# medium_test_temp2 
medium_test_temp2_mpos <- is.na(dat$medium_test_temp2)
dat$medium_test_temp2_fill1 <- sample_imp(dat$medium_test_temp2)[[1]]

# sd_UTL 
sd_UTL_mpos <- is.na(dat$ln_sd_UTL)
dat$ln_sd_UTL_stand1 <- stand(dat$ln_sd_UTL)[,1]
dat$ln_sd_UTL_stand1[sd_UTL_mpos] <- 0

# body_mass
body_mass_mpos <- is.na(dat$ln_body_mass)
dat$ln_body_mass_stand1 <- stand(dat$ln_body_mass)[,1]
dat$ln_body_mass_stand1[body_mass_mpos] <- 0

## -------------------------------------------------------------------------------------------------------------------------------------------

# cycle 1
system.time(dat1_crossV <- b_mice(cycle = 1, data = dat, Ainv = Ainv))

saveRDS(dat1_crossV, file = "RData/Imputation/results/5th_cross_validation_1st_cycle.Rds")

#########

# cycle 2
system.time(dat2_crossV <- b_mice(cycle = 2, data = dat1_crossV, Ainv = Ainv))

saveRDS(dat2_crossV, file = "RData/Imputation/results/5th_cross_validation_2nd_cycle.Rds")

########

# cycle 3
system.time(dat3_crossV<- b_mice(cycle = 3, data = dat2_crossV, Ainv = Ainv))

saveRDS(dat3_crossV, file = "RData/Imputation/results/5th_cross_validation_3rd_cycle.Rds")

########

# cycle 4
system.time(dat4_crossV<- b_mice(cycle = 4, data = dat3_crossV, Ainv = Ainv))

saveRDS(dat4_crossV, file = "RData/Imputation/results/5th_cross_validation_4th_cycle.Rds")

########

# cycle 5
system.time(dat5_crossV<- b_mice(cycle = 5, data = dat4_crossV, Ainv = Ainv))

saveRDS(dat5_crossV, file = "RData/Imputation/results/5th_cross_validation_5th_cycle.Rds")
```

# **Predict CTmax across the distribution range of each species** 

## **Vegetated substrate** 

### **Combine species data with operative body temperatures** {.tabset .tabset_fade .tabset_pills}

Here, we merge the distribution data of each species with the daily temperatures they experience in each coordinate during the warmest 3-month period of each year

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/** and the resources used in **pbs/Climate_vulnerability/Substrate/** 

These files are named as **Combining_species_data_with_temp_data_substrate** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Current climate**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Substrate/current/daily_temp_warmest_days_substrate.rds")

species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

### Remove species that are paedomorphic as they live exclusively in water 
pre_data_for_imputation <- readRDS("RData/General_data/pre_data_for_imputation.rds")
pre_data_for_imputation <- dplyr::select(pre_data_for_imputation, tip.label, strategy)
paedomorphic_species <- filter(pre_data_for_imputation, strategy=="Paedomorphic")

species_occurrence <- anti_join(species_occurrence, paedomorphic_species, by = "tip.label")

### Combine datasets 
species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Substrate/current/species_daily_temp_warmest_days_substrate_current.rds")

```

#### **Future climate (+2C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Substrate/2C/daily_temp_warmest_days_substrate_2C.rds")

species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

### Remove species that are paedomorphic as they live exclusively in water 
pre_data_for_imputation <- readRDS("RData/General_data/pre_data_for_imputation.rds")
pre_data_for_imputation <- dplyr::select(pre_data_for_imputation, tip.label, strategy)
paedomorphic_species <- filter(pre_data_for_imputation, strategy=="Paedomorphic")

species_occurrence <- anti_join(species_occurrence, paedomorphic_species, by = "tip.label")

### Combine datasets 
species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Substrate/2C/species_daily_temp_warmest_days_substrate_future2C.rds")

```

#### **Future climate (+4C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Substrate/4C/daily_temp_warmest_days_substrate_4C.rds")

species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

### Remove species that are paedomorphic as they live exclusively in water 
pre_data_for_imputation <- readRDS("RData/General_data/pre_data_for_imputation.rds")
pre_data_for_imputation <- dplyr::select(pre_data_for_imputation, tip.label, strategy)
paedomorphic_species <- filter(pre_data_for_imputation, strategy=="Paedomorphic")

species_occurrence <- anti_join(species_occurrence, paedomorphic_species, by = "tip.label")

### Combine datasets 
species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Substrate/4C/species_daily_temp_warmest_days_substrate_future4C.rds")

```

### **Predict CTmax across the distribution range of each species** {.tabset .tabset_fade .tabset_pills}

Here, we run meta-analytic models for each species to estimate the model parameters, and use model predictions to project their CTmax across their range of distribution. These predictions are made assuming that animals are acclimated to the mean or maximum weekly temperature in each day surveyed. 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/** and the resources used in **pbs/Climate_vulnerability/Substrate/** 

These files are named as **Predicting_CTmax_across_coordinates_substrate** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Function to run meta-analytic models** 

```{r, eval=F}
# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean or maximum weekly temperature

species_meta <- function(species_name, species_data, temp_species) {
  
  cat("Processing:", species_name, "\n")
  
  dat <- dplyr::filter(species_data, tip.label == species_name)
  dat2 <- dplyr::filter(temp_species, tip.label == species_name)
  
  # Fit a meta-analytic model
  fit <- metafor::rma(yi = CTmax, 
                      sei = se, 
                      mod = ~ acclimation_temp, 
                      data = dat)
  
  int_slope <- coef(fit)
  se <- fit$se
  
  cat("Get model coefficients:\n")
  coefs <- data.frame(tip.label = dat$tip.label,
                      intercept = coef(fit)[1],
                      intercept_se = fit$se[1],
                      slope = coef(fit)[2],
                      slope_se = fit$se[2])
  print(head(coefs))
  
  
  prediction_mean <- predict(fit, newmods = dat2$mean_weekly_temp)
  prediction_max <- predict(fit, newmods = dat2$max_weekly_temp)
  
  cat("Generate predictions, mean temp:\n")
  print(head(prediction_mean))
  cat("Generate predictions, max temp:\n")
  print(head(prediction_max))
  
  daily_CTmax_substrate_mean_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_mean$pred, predicted_CTmax_se = prediction_mean$se))), -max_weekly_temp)
  daily_CTmax_substrate_max_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_max$pred, predicted_CTmax_se = prediction_max$se))), -mean_weekly_temp)
  
  return(list(coefs, daily_CTmax_substrate_mean_acc_current, daily_CTmax_substrate_max_acc_current))
  
}

```

#### **Current climate** 

##### **Load data**
```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Substrate/current/species_daily_temp_warmest_days_substrate_current.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

# Find common species between species_data and temp_species. This is needed because paedomorphic species were taken out from substrate temperature data
common_species <- intersect(unique(species_data$tip.label), unique(temp_species$tip.label))

# Filter both datasets to include only the matching species
species_data <- species_data %>% filter(tip.label %in% common_species)
temp_species <- temp_species %>% filter(tip.label %in% common_species)

saveRDS(temp_species, file="RData/Biophysical_modelling/Substrate/current/species_daily_temp_warmest_days_substrate_current_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)
```


##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_substrate_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_1, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_1, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_1, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_substrate_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_2, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_2, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_2, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_substrate_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_3, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_3, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_3, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_substrate_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_4, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_4, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_4, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_substrate_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_5, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_5, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_5, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_substrate_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_6, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_6, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_6, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_substrate_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_7, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_7, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_7, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_substrate_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_8, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_8, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_8, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_substrate_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_9, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_9, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_9, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_substrate_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_current_10, file="RData/Climate_vulnerability/Substrate/current/temp_files_ARR/species_ARR_substrate_current_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current_10, file="RData/Climate_vulnerability/Substrate/current/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_current_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_current_10, file="RData/Climate_vulnerability/Substrate/current/temp_files_max_acc/daily_CTmax_substrate_max_acc_current_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 

species_ARR_substrate_current <- distinct(rbind(species_ARR_substrate_current_1,
                              species_ARR_substrate_current_2,
                              species_ARR_substrate_current_3,
                              species_ARR_substrate_current_4,
                              species_ARR_substrate_current_5,
                              species_ARR_substrate_current_6,
                              species_ARR_substrate_current_7,
                              species_ARR_substrate_current_8,
                              species_ARR_substrate_current_9,
                              species_ARR_substrate_current_10))

daily_CTmax_substrate_mean_acc_current <- rbind(daily_CTmax_substrate_mean_acc_current_1,
                      daily_CTmax_substrate_mean_acc_current_2,
                      daily_CTmax_substrate_mean_acc_current_3,
                      daily_CTmax_substrate_mean_acc_current_4,
                      daily_CTmax_substrate_mean_acc_current_5,
                      daily_CTmax_substrate_mean_acc_current_6,
                      daily_CTmax_substrate_mean_acc_current_7,
                      daily_CTmax_substrate_mean_acc_current_8,
                      daily_CTmax_substrate_mean_acc_current_9,
                      daily_CTmax_substrate_mean_acc_current_10)

daily_CTmax_substrate_max_acc_current <- rbind(daily_CTmax_substrate_max_acc_current_1,
                       daily_CTmax_substrate_max_acc_current_2,
                       daily_CTmax_substrate_max_acc_current_3,
                       daily_CTmax_substrate_max_acc_current_4,
                       daily_CTmax_substrate_max_acc_current_5,
                       daily_CTmax_substrate_max_acc_current_6,
                       daily_CTmax_substrate_max_acc_current_7,
                       daily_CTmax_substrate_max_acc_current_8,
                       daily_CTmax_substrate_max_acc_current_9,
                       daily_CTmax_substrate_max_acc_current_10)


saveRDS(species_ARR_substrate_current, file="RData/Climate_vulnerability/Substrate/current/species_ARR_substrate_current.rds")
saveRDS(daily_CTmax_substrate_mean_acc_current, file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_mean_acc_current.rds")
saveRDS(daily_CTmax_substrate_max_acc_current, file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_max_acc_current.rds")

```


#### **Future climate (+2C)**

##### **Load data**

```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Substrate/2C/species_daily_temp_warmest_days_substrate_future2C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

# Find common species between species_data and temp_species. This is needed because paedomorphic species were taken out from substrate temperature data
common_species <- intersect(unique(species_data$tip.label), unique(temp_species$tip.label))

# Filter both datasets to include only the matching species
species_data <- species_data %>% filter(tip.label %in% common_species)
temp_species <- temp_species %>% filter(tip.label %in% common_species)

saveRDS(temp_species, file="RData/Biophysical_modelling/Substrate/2C/species_daily_temp_warmest_days_substrate_future2C_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)
```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_substrate_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_1, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_1, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_1, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_substrate_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_2, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_2, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_2, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_substrate_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_3, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_3, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_3, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_substrate_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_4, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_4, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_4, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_substrate_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_5, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_5, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_5, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_substrate_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_6, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_6, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_6, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_substrate_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_7, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_7, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_7, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_substrate_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_8, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_8, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_8, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_substrate_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_9, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_9, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_9, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_substrate_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future2C_10, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_ARR/species_ARR_substrate_future2C_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C_10, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future2C_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C_10, file="RData/Climate_vulnerability/Substrate/future2C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future2C_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()


```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 
species_ARR_substrate_future2C <- distinct(rbind(species_ARR_substrate_future2C_1,
                                                species_ARR_substrate_future2C_2,
                                                species_ARR_substrate_future2C_3,
                                                species_ARR_substrate_future2C_4,
                                                species_ARR_substrate_future2C_5,
                                                species_ARR_substrate_future2C_6,
                                                species_ARR_substrate_future2C_7,
                                                species_ARR_substrate_future2C_8,
                                                species_ARR_substrate_future2C_9,
                                                species_ARR_substrate_future2C_10))

daily_CTmax_substrate_mean_acc_future2C <- rbind(daily_CTmax_substrate_mean_acc_future2C_1,
                                                daily_CTmax_substrate_mean_acc_future2C_2,
                                                daily_CTmax_substrate_mean_acc_future2C_3,
                                                daily_CTmax_substrate_mean_acc_future2C_4,
                                                daily_CTmax_substrate_mean_acc_future2C_5,
                                                daily_CTmax_substrate_mean_acc_future2C_6,
                                                daily_CTmax_substrate_mean_acc_future2C_7,
                                                daily_CTmax_substrate_mean_acc_future2C_8,
                                                daily_CTmax_substrate_mean_acc_future2C_9,
                                                daily_CTmax_substrate_mean_acc_future2C_10)

daily_CTmax_substrate_max_acc_future2C <- rbind(daily_CTmax_substrate_max_acc_future2C_1,
                                               daily_CTmax_substrate_max_acc_future2C_2,
                                               daily_CTmax_substrate_max_acc_future2C_3,
                                               daily_CTmax_substrate_max_acc_future2C_4,
                                               daily_CTmax_substrate_max_acc_future2C_5,
                                               daily_CTmax_substrate_max_acc_future2C_6,
                                               daily_CTmax_substrate_max_acc_future2C_7,
                                               daily_CTmax_substrate_max_acc_future2C_8,
                                               daily_CTmax_substrate_max_acc_future2C_9,
                                               daily_CTmax_substrate_max_acc_future2C_10)


saveRDS(species_ARR_substrate_future2C, file="RData/Climate_vulnerability/Substrate/future2C/species_ARR_substrate_future2C.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future2C, file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_mean_acc_future2C.rds")
saveRDS(daily_CTmax_substrate_max_acc_future2C, file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_max_acc_future2C.rds")

```



#### **Future climate (+4C)**

##### **Load data**

```{r, eval=F}

results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se = (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Substrate/4C/species_daily_temp_warmest_days_substrate_future4C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

# Find common species between species_data and temp_species. This is needed because paedomorphic species were taken out from substrate temperature data
common_species <- intersect(unique(species_data$tip.label), unique(temp_species$tip.label))

# Filter both datasets to include only the matching species
species_data <- species_data %>% filter(tip.label %in% common_species)
temp_species <- temp_species %>% filter(tip.label %in% common_species)

saveRDS(temp_species, file="RData/Biophysical_modelling/Substrate/4C/species_daily_temp_warmest_days_substrate_future4C_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)

```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_substrate_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_1, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_1, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_1, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_substrate_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_2, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_2, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_2, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_substrate_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_3, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_3, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_3, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_substrate_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_4, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_4, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_4, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_substrate_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_5, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_5, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_5th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_5, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_substrate_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_6, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_6, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_6th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_6, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_substrate_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_7, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_7, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_7th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_7, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_substrate_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_8, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_8, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_8th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_8, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_substrate_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_9, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_9, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_9th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_9, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_substrate_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_substrate_mean_acc_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_substrate_max_acc_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_substrate_future4C_10, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_ARR/species_ARR_substrate_future4C_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C_10, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_mean_acc/daily_CTmax_substrate_mean_acc_future4C_10th_chunk.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C_10, file="RData/Climate_vulnerability/Substrate/future4C/temp_files_max_acc/daily_CTmax_substrate_max_acc_future4C_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 

species_ARR_substrate_future4C <- distinct(rbind(species_ARR_substrate_future4C_1,
                                                 species_ARR_substrate_future4C_2,
                                                 species_ARR_substrate_future4C_3,
                                                 species_ARR_substrate_future4C_4,
                                                 species_ARR_substrate_future4C_5,
                                                 species_ARR_substrate_future4C_6,
                                                 species_ARR_substrate_future4C_7,
                                                 species_ARR_substrate_future4C_8,
                                                 species_ARR_substrate_future4C_9,
                                                 species_ARR_substrate_future4C_10))

daily_CTmax_substrate_mean_acc_future4C <- rbind(daily_CTmax_substrate_mean_acc_future4C_1,
                                                 daily_CTmax_substrate_mean_acc_future4C_2,
                                                 daily_CTmax_substrate_mean_acc_future4C_3,
                                                 daily_CTmax_substrate_mean_acc_future4C_4,
                                                 daily_CTmax_substrate_mean_acc_future4C_5,
                                                 daily_CTmax_substrate_mean_acc_future4C_6,
                                                 daily_CTmax_substrate_mean_acc_future4C_7,
                                                 daily_CTmax_substrate_mean_acc_future4C_8,
                                                 daily_CTmax_substrate_mean_acc_future4C_9,
                                                 daily_CTmax_substrate_mean_acc_future4C_10)

daily_CTmax_substrate_max_acc_future4C <- rbind(daily_CTmax_substrate_max_acc_future4C_1,
                                                daily_CTmax_substrate_max_acc_future4C_2,
                                                daily_CTmax_substrate_max_acc_future4C_3,
                                                daily_CTmax_substrate_max_acc_future4C_4,
                                                daily_CTmax_substrate_max_acc_future4C_5,
                                                daily_CTmax_substrate_max_acc_future4C_6,
                                                daily_CTmax_substrate_max_acc_future4C_7,
                                                daily_CTmax_substrate_max_acc_future4C_8,
                                                daily_CTmax_substrate_max_acc_future4C_9,
                                                daily_CTmax_substrate_max_acc_future4C_10)


saveRDS(species_ARR_substrate_future4C, file="RData/Climate_vulnerability/Substrate/future4C/species_ARR_substrate_future4C.rds")
saveRDS(daily_CTmax_substrate_mean_acc_future4C, file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_mean_acc_future4C.rds")
saveRDS(daily_CTmax_substrate_max_acc_future4C, file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_max_acc_future4C.rds")

```

## **Pond or wetland** 

### **Combine species data with operative body temperatures** {.tabset .tabset_fade .tabset_pills}

Here, we merge the distribution data of each species with the daily temperatures they experience in each coordinate during the warmest 3-month period of each year

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/** and the resources used in **pbs/Climate_vulnerability/Pond/** 

These files are named as **Combining_species_data_with_temp_data_pond** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Current climate** 

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Pond/current/daily_temp_warmest_days_pond.rds")

species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Pond/current/species_daily_temp_warmest_days_pond_current.rds")

```

#### **Future climate (+2C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Pond/2C/daily_temp_warmest_days_pond_2C.rds")

species_occurrence<- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Pond/2C/species_daily_temp_warmest_days_pond_future2C.rds")

```

#### **Future climate (+4C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Pond/4C/daily_temp_warmest_days_pond_4C.rds")

species_occurrence<- readRDS(file="RData/General_data/species_coordinates_adjusted.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Pond/4C/species_daily_temp_warmest_days_pond_future4C.rds")
```

### **Predict CTmax across the distribution range of each species**  {.tabset .tabset_fade .tabset_pills}

Here, we run meta-analytic models for each species to estimate the model parameters, and use model predictions to project their CTmax across their range of distribution. These predictions are made assuming that animals are acclimated to the mean or maximum weekly temperature in each day surveyed. 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/** and the resources used in **pbs/Climate_vulnerability/Pond/** 

These files are named as **Predicting_CTmax_across_coordinates_pond** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Function to run meta-analytic models** 

```{r, eval=F}
# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean or maximum weekly temperature

species_meta <- function(species_name, species_data, temp_species) {
  
  cat("Processing:", species_name, "\n")
  
  dat <- dplyr::filter(species_data, tip.label == species_name)
  dat2 <- dplyr::filter(temp_species, tip.label == species_name)
  
  # Fit a meta-analytic model
  fit <- metafor::rma(yi = CTmax, 
                      sei = se, 
                      mod = ~ acclimation_temp, 
                      data = dat)
  
  int_slope <- coef(fit)
  se <- fit$se
  
  cat("Get model coefficients:\n")
  coefs <- data.frame(tip.label = dat$tip.label,
                      intercept = coef(fit)[1],
                      intercept_se = fit$se[1],
                      slope = coef(fit)[2],
                      slope_se = fit$se[2])
  print(head(coefs))
  
  
  prediction_mean <- predict(fit, newmods = dat2$mean_weekly_temp)
  prediction_max <- predict(fit, newmods = dat2$max_weekly_temp)
  
  cat("Generate predictions, mean temp:\n")
  print(head(prediction_mean))
  cat("Generate predictions, max temp:\n")
  print(head(prediction_max))
  
  daily_CTmax_pond_mean_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_mean$pred, predicted_CTmax_se = prediction_mean$se))), -max_weekly_temp)
  daily_CTmax_pond_max_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_max$pred, predicted_CTmax_se = prediction_max$se))), -mean_weekly_temp)
  
  return(list(coefs, daily_CTmax_pond_mean_acc_current, daily_CTmax_pond_max_acc_current))
  
}
```

#### **Current climate** 

##### **Load data**
```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Pond/current/species_daily_temp_warmest_days_pond_current.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Pond/current/species_daily_temp_warmest_days_pond_current_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)

```


##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_pond_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_1, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_1st_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_1, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_1st_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_1, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_pond_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_2, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_2, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_2, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_pond_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_3, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_3, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_3, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_pond_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_4, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_4th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_4, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_4th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_4, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_pond_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_5, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_5th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_5, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_5th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_5, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_pond_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_6, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_6th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_6, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_6th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_6, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_pond_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_7, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_7th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_7, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_7th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_7, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_pond_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_8, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_8th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_8, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_8th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_8, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_pond_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_9, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_9th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_9, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_9th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_9, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_pond_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_pond_max_acc_current_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_current_10, file="RData/Climate_vulnerability/Pond/current/temp_files_ARR/species_ARR_pond_current_10th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_current_10, file="RData/Climate_vulnerability/Pond/current/temp_files_mean_acc/daily_CTmax_pond_mean_acc_current_10th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_current_10, file="RData/Climate_vulnerability/Pond/current/temp_files_max_acc/daily_CTmax_pond_max_acc_current_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()


```

##### **Combine chunks** 

```{r, eval=F}

# Combine results from all chunks and save 
species_ARR_pond_current <- distinct(rbind(species_ARR_pond_current_1,
                                                species_ARR_pond_current_2,
                                                species_ARR_pond_current_3,
                                                species_ARR_pond_current_4,
                                                species_ARR_pond_current_5,
                                                species_ARR_pond_current_6,
                                                species_ARR_pond_current_7,
                                                species_ARR_pond_current_8,
                                                species_ARR_pond_current_9,
                                                species_ARR_pond_current_10))

daily_CTmax_pond_mean_acc_current <- rbind(daily_CTmax_pond_mean_acc_current_1,
                                                daily_CTmax_pond_mean_acc_current_2,
                                                daily_CTmax_pond_mean_acc_current_3,
                                                daily_CTmax_pond_mean_acc_current_4,
                                                daily_CTmax_pond_mean_acc_current_5,
                                                daily_CTmax_pond_mean_acc_current_6,
                                                daily_CTmax_pond_mean_acc_current_7,
                                                daily_CTmax_pond_mean_acc_current_8,
                                                daily_CTmax_pond_mean_acc_current_9,
                                                daily_CTmax_pond_mean_acc_current_10)

daily_CTmax_pond_max_acc_current <- rbind(daily_CTmax_pond_max_acc_current_1,
                                               daily_CTmax_pond_max_acc_current_2,
                                               daily_CTmax_pond_max_acc_current_3,
                                               daily_CTmax_pond_max_acc_current_4,
                                               daily_CTmax_pond_max_acc_current_5,
                                               daily_CTmax_pond_max_acc_current_6,
                                               daily_CTmax_pond_max_acc_current_7,
                                               daily_CTmax_pond_max_acc_current_8,
                                               daily_CTmax_pond_max_acc_current_9,
                                               daily_CTmax_pond_max_acc_current_10)


saveRDS(species_ARR_pond_current, file="RData/Climate_vulnerability/Pond/current/species_ARR_pond_current.rds")
saveRDS(daily_CTmax_pond_mean_acc_current, file="RData/Climate_vulnerability/Pond/current/daily_CTmax_pond_mean_acc_current.rds")
saveRDS(daily_CTmax_pond_max_acc_current, file="RData/Climate_vulnerability/Pond/current/daily_CTmax_pond_max_acc_current.rds")

```


#### **Future climate (+2C)**

##### **Load data**

```{r, eval=F}

results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Pond/2C/species_daily_temp_warmest_days_pond_future2C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Pond/2C/species_daily_temp_warmest_days_pond_future2C_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)

```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_pond_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_1, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_1, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_1, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_pond_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_2, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_2, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_2, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_pond_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_3, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_3, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_3, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_pond_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_4, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_4, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_4, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_pond_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_5, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_5th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_5, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_5th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_5, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_pond_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_6, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_6th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_6, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_6th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_6, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_pond_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_7, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_7th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_7, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_7th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_7, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_pond_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_8, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_8th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_8, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_8th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_8, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_pond_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_9, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_9th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_9, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_9th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_9, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_pond_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future2C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future2C_10, file="RData/Climate_vulnerability/Pond/future2C/temp_files_ARR/species_ARR_pond_future2C_10th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C_10, file="RData/Climate_vulnerability/Pond/future2C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future2C_10th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C_10, file="RData/Climate_vulnerability/Pond/future2C/temp_files_max_acc/daily_CTmax_pond_max_acc_future2C_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 

species_ARR_pond_future2C <- distinct(rbind(species_ARR_pond_future2C_1,
                                                 species_ARR_pond_future2C_2,
                                                 species_ARR_pond_future2C_3,
                                                 species_ARR_pond_future2C_4,
                                                 species_ARR_pond_future2C_5,
                                                 species_ARR_pond_future2C_6,
                                                 species_ARR_pond_future2C_7,
                                                 species_ARR_pond_future2C_8,
                                                 species_ARR_pond_future2C_9,
                                                 species_ARR_pond_future2C_10))

daily_CTmax_pond_mean_acc_future2C <- rbind(daily_CTmax_pond_mean_acc_future2C_1,
                                                 daily_CTmax_pond_mean_acc_future2C_2,
                                                 daily_CTmax_pond_mean_acc_future2C_3,
                                                 daily_CTmax_pond_mean_acc_future2C_4,
                                                 daily_CTmax_pond_mean_acc_future2C_5,
                                                 daily_CTmax_pond_mean_acc_future2C_6,
                                                 daily_CTmax_pond_mean_acc_future2C_7,
                                                 daily_CTmax_pond_mean_acc_future2C_8,
                                                 daily_CTmax_pond_mean_acc_future2C_9,
                                                 daily_CTmax_pond_mean_acc_future2C_10)

daily_CTmax_pond_max_acc_future2C <- rbind(daily_CTmax_pond_max_acc_future2C_1,
                                                daily_CTmax_pond_max_acc_future2C_2,
                                                daily_CTmax_pond_max_acc_future2C_3,
                                                daily_CTmax_pond_max_acc_future2C_4,
                                                daily_CTmax_pond_max_acc_future2C_5,
                                                daily_CTmax_pond_max_acc_future2C_6,
                                                daily_CTmax_pond_max_acc_future2C_7,
                                                daily_CTmax_pond_max_acc_future2C_8,
                                                daily_CTmax_pond_max_acc_future2C_9,
                                                daily_CTmax_pond_max_acc_future2C_10)


saveRDS(species_ARR_pond_future2C, file="RData/Climate_vulnerability/Pond/future2C/species_ARR_pond_future2C.rds")
saveRDS(daily_CTmax_pond_mean_acc_future2C, file="RData/Climate_vulnerability/Pond/future2C/daily_CTmax_pond_mean_acc_future2C.rds")
saveRDS(daily_CTmax_pond_max_acc_future2C, file="RData/Climate_vulnerability/Pond/future2C/daily_CTmax_pond_max_acc_future2C.rds")


```



#### **Future climate (+4C)**

##### **Load data**

```{r, eval=F}

results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Pond/4C/species_daily_temp_warmest_days_pond_future4C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Pond/4C/species_daily_temp_warmest_days_pond_future4C_adj.rds")

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)
```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_pond_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_1, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_1, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_1, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_pond_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_2, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_2, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_2, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_pond_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_3, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_3, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_3, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_pond_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_4, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_4, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_4, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_4th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[5]]
result_list_5 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_5 <- c(result_list_5, result_chunk)
}

species_ARR_pond_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_5 <- do.call(rbind, lapply(result_list_5, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_5)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_5, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_5th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_5, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_5th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_5, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_5th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[6]]
result_list_6 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_6 <- c(result_list_6, result_chunk)
}

species_ARR_pond_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_6 <- do.call(rbind, lapply(result_list_6, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_6)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_6, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_6th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_6, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_6th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_6, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_6th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[7]]
result_list_7 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_7 <- c(result_list_7, result_chunk)
}

species_ARR_pond_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_7 <- do.call(rbind, lapply(result_list_7, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_7)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_7, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_7th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_7, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_7th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_7, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_7th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[8]]
result_list_8 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_8 <- c(result_list_8, result_chunk)
}

species_ARR_pond_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_8 <- do.call(rbind, lapply(result_list_8, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_8)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_8, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_8th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_8, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_8th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_8, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_8th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[9]]
result_list_9 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_9 <- c(result_list_9, result_chunk)
}

species_ARR_pond_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_9 <- do.call(rbind, lapply(result_list_9, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_9)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_9, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_9th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_9, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_9th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_9, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_9th_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[10]]
result_list_10 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_10 <- c(result_list_10, result_chunk)
}

species_ARR_pond_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[1]]))
daily_CTmax_pond_mean_acc_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[2]]))
daily_CTmax_pond_max_acc_future4C_10 <- do.call(rbind, lapply(result_list_10, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_10)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_pond_future4C_10, file="RData/Climate_vulnerability/Pond/future4C/temp_files_ARR/species_ARR_pond_future4C_10th_chunk.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C_10, file="RData/Climate_vulnerability/Pond/future4C/temp_files_mean_acc/daily_CTmax_pond_mean_acc_future4C_10th_chunk.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C_10, file="RData/Climate_vulnerability/Pond/future4C/temp_files_max_acc/daily_CTmax_pond_max_acc_future4C_10th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 
species_ARR_pond_future4C <- distinct(rbind(species_ARR_pond_future4C_1,
                                                 species_ARR_pond_future4C_2,
                                                 species_ARR_pond_future4C_3,
                                                 species_ARR_pond_future4C_4,
                                                 species_ARR_pond_future4C_5,
                                                 species_ARR_pond_future4C_6,
                                                 species_ARR_pond_future4C_7,
                                                 species_ARR_pond_future4C_8,
                                                 species_ARR_pond_future4C_9,
                                                 species_ARR_pond_future4C_10))

daily_CTmax_pond_mean_acc_future4C <- rbind(daily_CTmax_pond_mean_acc_future4C_1,
                                                 daily_CTmax_pond_mean_acc_future4C_2,
                                                 daily_CTmax_pond_mean_acc_future4C_3,
                                                 daily_CTmax_pond_mean_acc_future4C_4,
                                                 daily_CTmax_pond_mean_acc_future4C_5,
                                                 daily_CTmax_pond_mean_acc_future4C_6,
                                                 daily_CTmax_pond_mean_acc_future4C_7,
                                                 daily_CTmax_pond_mean_acc_future4C_8,
                                                 daily_CTmax_pond_mean_acc_future4C_9,
                                                 daily_CTmax_pond_mean_acc_future4C_10)

daily_CTmax_pond_max_acc_future4C <- rbind(daily_CTmax_pond_max_acc_future4C_1,
                                                daily_CTmax_pond_max_acc_future4C_2,
                                                daily_CTmax_pond_max_acc_future4C_3,
                                                daily_CTmax_pond_max_acc_future4C_4,
                                                daily_CTmax_pond_max_acc_future4C_5,
                                                daily_CTmax_pond_max_acc_future4C_6,
                                                daily_CTmax_pond_max_acc_future4C_7,
                                                daily_CTmax_pond_max_acc_future4C_8,
                                                daily_CTmax_pond_max_acc_future4C_9,
                                                daily_CTmax_pond_max_acc_future4C_10)


saveRDS(species_ARR_pond_future4C, file="RData/Climate_vulnerability/Pond/future4C/species_ARR_pond_future4C.rds")
saveRDS(daily_CTmax_pond_mean_acc_future4C, file="RData/Climate_vulnerability/Pond/future4C/daily_CTmax_pond_mean_acc_future4C.rds")
saveRDS(daily_CTmax_pond_max_acc_future4C, file="RData/Climate_vulnerability/Pond/future4C/daily_CTmax_pond_max_acc_future4C.rds")

```

## **Above-ground vegetation** 

### **Combine species data with operative body temperatures** {.tabset .tabset_fade .tabset_pills}

Here, we merge the distribution data of each species with the daily temperatures they experience in each coordinate during the warmest 3-month period of each year

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/** and the resources used in **pbs/Climate_vulnerability/Arboreal/** 

These files are named as **Combining_species_data_with_temp_data_arboreal** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Current climate**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Arboreal/current/daily_temp_warmest_days_arboreal.rds")

species_occurrence <- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Arboreal/current/species_daily_temp_warmest_days_arboreal_current.rds")

```

#### **Future climate (+2C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Arboreal/2C/daily_temp_warmest_days_arboreal_2C.rds")

species_occurrence<- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Arboreal/2C/species_daily_temp_warmest_days_arboreal_future2C.rds")

```

#### **Future climate (+4C)**

```{r, eval=F}
### Daily temperature of the warmest days
daily_temp_warmest_days<- readRDS("RData/Biophysical_modelling/Arboreal/4C/daily_temp_warmest_days_arboreal_4C.rds")

species_occurrence<- readRDS(file="RData/General_data/species_coordinates_adjusted_arboreal.rds")

species_temp_warmest_days <- merge(daily_temp_warmest_days, species_occurrence, by = c("lon", "lat"))

saveRDS(species_temp_warmest_days, file="RData/Biophysical_modelling/Arboreal/4C/species_daily_temp_warmest_days_arboreal_future4C.rds")

```

### **Predict CTmax across the distribution range of each species** {.tabset .tabset_fade .tabset_pills}

Here, we run meta-analytic models for each species to estimate the model parameters, and use model predictions to project their CTmax across their range of distribution. These predictions are made assuming that animals are acclimated to the mean or maximum weekly temperature in each day surveyed. 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/** and the resources used in **pbs/Climate_vulnerability/Arboreal/** 

These files are named as **Predicting_CTmax_across_coordinates_arboreal** and the file suffix denotes the climatic scenario (**_current** for 2006-2015; **_future2C** for +2 degrees of warming above pre-industrial levels; or **_future_4C** for +4 degrees of warming above pre-industrial levels).

#### **Function to run meta-analytic models** 

```{r, eval=F}
# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean or maximum weekly temperature

## Create function
species_meta <- function(species_name, species_data, temp_species) {
  
  cat("Processing:", species_name, "\n")
  
  dat <- dplyr::filter(species_data, tip.label == species_name)
  dat2 <- dplyr::filter(temp_species, tip.label == species_name)
  
  # Fit a meta-analytic model
  fit <- metafor::rma(yi = CTmax, 
                      sei = se, 
                      mod = ~ acclimation_temp, 
                      data = dat)
  
  int_slope <- coef(fit)
  se <- fit$se
  
  cat("Get model coefficients:\n")
  coefs <- data.frame(tip.label = dat$tip.label,
                      intercept = coef(fit)[1],
                      intercept_se = fit$se[1],
                      slope = coef(fit)[2],
                      slope_se = fit$se[2])
  print(head(coefs))
  
  
  prediction_mean <- predict(fit, newmods = dat2$mean_weekly_temp)
  prediction_max <- predict(fit, newmods = dat2$max_weekly_temp)
  
  cat("Generate predictions, mean temp:\n")
  print(head(prediction_mean))
  cat("Generate predictions, max temp:\n")
  print(head(prediction_max))
  
  daily_CTmax_arboreal_mean_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_mean$pred, predicted_CTmax_se = prediction_mean$se))), -max_weekly_temp)
  daily_CTmax_arboreal_max_acc_current <- dplyr::select((cbind(dat2, cbind(predicted_CTmax = prediction_max$pred, predicted_CTmax_se = prediction_max$se))), -mean_weekly_temp)
  
  return(list(coefs, daily_CTmax_arboreal_mean_acc_current, daily_CTmax_arboreal_max_acc_current))
  
}
```

#### **Current climate** 

##### **Load data**
```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Arboreal/current/species_daily_temp_warmest_days_arboreal_current.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Arboreal/current/species_daily_temp_warmest_days_arboreal_current_adj.rds")

species_data <- filter(species_data, tip.label %in% temp_species$tip.label)

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)

```


##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_arboreal_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_current_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_current_1, file="RData/Climate_vulnerability/Arboreal/current/temp_files_ARR/species_ARR_arboreal_current_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_current_1, file="RData/Climate_vulnerability/Arboreal/current/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_current_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_current_1, file="RData/Climate_vulnerability/Arboreal/current/temp_files_max_acc/daily_CTmax_arboreal_max_acc_current_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_arboreal_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_current_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_current_2, file="RData/Climate_vulnerability/Arboreal/current/temp_files_ARR/species_ARR_arboreal_current_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_current_2, file="RData/Climate_vulnerability/Arboreal/current/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_current_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_current_2, file="RData/Climate_vulnerability/Arboreal/current/temp_files_max_acc/daily_CTmax_arboreal_max_acc_current_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_arboreal_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_current_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_current_3, file="RData/Climate_vulnerability/Arboreal/current/temp_files_ARR/species_ARR_arboreal_current_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_current_3, file="RData/Climate_vulnerability/Arboreal/current/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_current_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_current_3, file="RData/Climate_vulnerability/Arboreal/current/temp_files_max_acc/daily_CTmax_arboreal_max_acc_current_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_arboreal_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_current_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_current_4, file="RData/Climate_vulnerability/Arboreal/current/temp_files_ARR/species_ARR_arboreal_current_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_current_4, file="RData/Climate_vulnerability/Arboreal/current/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_current_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_current_4, file="RData/Climate_vulnerability/Arboreal/current/temp_files_max_acc/daily_CTmax_arboreal_max_acc_current_4th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 
species_ARR_arboreal_current <- distinct(rbind(species_ARR_arboreal_current_1,
                                                species_ARR_arboreal_current_2,
                                                species_ARR_arboreal_current_3,
                                                species_ARR_arboreal_current_4))

daily_CTmax_arboreal_mean_acc_current <- rbind(daily_CTmax_arboreal_mean_acc_current_1,
                                                daily_CTmax_arboreal_mean_acc_current_2,
                                                daily_CTmax_arboreal_mean_acc_current_3,
                                                daily_CTmax_arboreal_mean_acc_current_4)

daily_CTmax_arboreal_max_acc_current <- rbind(daily_CTmax_arboreal_max_acc_current_1,
                                               daily_CTmax_arboreal_max_acc_current_2,
                                               daily_CTmax_arboreal_max_acc_current_3,
                                               daily_CTmax_arboreal_max_acc_current_4)


saveRDS(species_ARR_arboreal_current, file="RData/Climate_vulnerability/Arboreal/current/species_ARR_arboreal_current.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_current, file="RData/Climate_vulnerability/Arboreal/current/daily_CTmax_arboreal_mean_acc_current.rds")
saveRDS(daily_CTmax_arboreal_max_acc_current, file="RData/Climate_vulnerability/Arboreal/current/daily_CTmax_arboreal_max_acc_current.rds")
```


#### **Future climate (+2C)**

##### **Load data**

```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Arboreal/2C/species_daily_temp_warmest_days_arboreal_future2C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Arboreal/2C/species_daily_temp_warmest_days_arboreal_future2C_adj.rds")

species_data <- filter(species_data, tip.label %in% temp_species$tip.label)

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)
```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_arboreal_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future2C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future2C_1, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_ARR/species_ARR_arboreal_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future2C_1, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future2C_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future2C_1, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future2C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_arboreal_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future2C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future2C_2, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_ARR/species_ARR_arboreal_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future2C_2, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future2C_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future2C_2, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future2C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_arboreal_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future2C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future2C_3, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_ARR/species_ARR_arboreal_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future2C_3, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future2C_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future2C_3, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future2C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_arboreal_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future2C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future2C_4, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_ARR/species_ARR_arboreal_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future2C_4, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future2C_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future2C_4, file="RData/Climate_vulnerability/Arboreal/future2C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future2C_4th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()

```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 
species_ARR_arboreal_future2C <- distinct(rbind(species_ARR_arboreal_future2C_1,
                                                 species_ARR_arboreal_future2C_2,
                                                 species_ARR_arboreal_future2C_3,
                                                 species_ARR_arboreal_future2C_4))

daily_CTmax_arboreal_mean_acc_future2C <- rbind(daily_CTmax_arboreal_mean_acc_future2C_1,
                                                 daily_CTmax_arboreal_mean_acc_future2C_2,
                                                 daily_CTmax_arboreal_mean_acc_future2C_3,
                                                 daily_CTmax_arboreal_mean_acc_future2C_4)

daily_CTmax_arboreal_max_acc_future2C <- rbind(daily_CTmax_arboreal_max_acc_future2C_1,
                                                daily_CTmax_arboreal_max_acc_future2C_2,
                                                daily_CTmax_arboreal_max_acc_future2C_3,
                                                daily_CTmax_arboreal_max_acc_future2C_4)


saveRDS(species_ARR_arboreal_future2C, file="RData/Climate_vulnerability/Arboreal/future2C/species_ARR_arboreal_future2C.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future2C, file="RData/Climate_vulnerability/Arboreal/future2C/daily_CTmax_arboreal_mean_acc_future2C.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future2C, file="RData/Climate_vulnerability/Arboreal/future2C/daily_CTmax_arboreal_max_acc_future2C.rds")

```



#### **Future climate (+4C)**

##### **Load data**

```{r, eval=F}
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")  

CTmax_data<- dplyr::select(results_imputation, CTmax=filled_mean_UTL5, lowerCI = lower_mean_UTL, upperCI=upper_mean_UTL, acclimation_temp, tip.label, imputed) # Select relevant columns

original_data<-dplyr::filter(CTmax_data, imputed=="no") # Original experimental data
imputed_data<-dplyr::filter(CTmax_data, imputed=="yes") # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>% 
  mutate(se= (upperCI-CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

temp_species<- readRDS("RData/Biophysical_modelling/Arboreal/4C/species_daily_temp_warmest_days_arboreal_future4C.rds")
temp_species$tip.label <- gsub("_", " ", temp_species$tip.label)

temp_species$tip.label[temp_species$tip.label =="Scinax x signatus"] <- "Scinax x-signatus"
temp_species$tip.label[temp_species$tip.label =="Pristimantis w nigrum"] <- "Pristimantis w-nigrum"

saveRDS(temp_species, file="RData/Biophysical_modelling/Arboreal/4C/species_daily_temp_warmest_days_arboreal_future4C_adj.rds")

species_data <- filter(species_data, tip.label %in% temp_species$tip.label)

# Run meta-analytic models to calculate species-level ARR and intercept; and predict the CTmax of each day once acclimated to the mean weekly temperature

temp_species <- temp_species %>% dplyr::select(tip.label, lon, lat, YEAR, DOY, max_temp, mean_weekly_temp, max_weekly_temp)

```

##### **Run the models in chunks** 

```{r, eval=F}
# Create chunks of 3 species at a time
species_list <- unique(species_data$tip.label)
chunk_size <- 3 
num_chunks <- ceiling(length(species_list) / chunk_size)

# Split the species list into chunks
chunk_species_list <- split(species_list, 
                            cut(1:length(species_list), 
                                breaks = num_chunks,
                                labels = FALSE))

# Now, create larger chunks of small chunks
# Running all chunks at once will require an enormous amount of RAM, so we proceed with 175 chunks at a time in 10 batches.
larger_chunk_size <- 175
num_larger_chunks <- ceiling(num_chunks / larger_chunk_size)

# Split the chunk list into larger chunks
larger_chunk_list <- split(chunk_species_list, cut(1:length(chunk_species_list), breaks = num_larger_chunks, labels = FALSE))


# Set up parallel processing 
cl <- makeCluster(16)

# Load packages on nodes
clusterEvalQ(cl, {
  library(dplyr)
  library(metafor)
})

# Check processing time
Sys.time()

# Processing for first larger chunk
current_larger_chunk <- larger_chunk_list[[1]]
result_list_1 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_1 <- c(result_list_1, result_chunk)
}

species_ARR_arboreal_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future4C_1 <- do.call(rbind, lapply(result_list_1, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_1)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future4C_1, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_ARR/species_ARR_arboreal_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future4C_1, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future4C_1st_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future4C_1, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future4C_1st_chunk.rds")

################################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[2]]
result_list_2 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_2 <- c(result_list_2, result_chunk)
}

species_ARR_arboreal_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future4C_2 <- do.call(rbind, lapply(result_list_2, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_2)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future4C_2, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_ARR/species_ARR_arboreal_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future4C_2, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future4C_2nd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future4C_2, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future4C_2nd_chunk.rds")

###################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[3]]
result_list_3 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_3 <- c(result_list_3, result_chunk)
}

species_ARR_arboreal_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future4C_3 <- do.call(rbind, lapply(result_list_3, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_3)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future4C_3, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_ARR/species_ARR_arboreal_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future4C_3, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future4C_3rd_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future4C_3, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future4C_3rd_chunk.rds")

######################

Sys.time()

# Processing for second larger chunk
current_larger_chunk <- larger_chunk_list[[4]]
result_list_4 <- list()

# Loop over the small chunks within the current larger chunk
for (i in seq_along(current_larger_chunk)) {
  current_species <- current_larger_chunk[[i]]
  
  # Filter data for only the species in the current chunk
  chunk_species_data <- dplyr::filter(species_data, tip.label %in% current_species)
  chunk_temp_species <- dplyr::filter(temp_species, tip.label %in% current_species)
  
  # Export only the filtered data and the current species list to the cluster
  clusterExport(cl, c("chunk_species_data", "chunk_temp_species", "current_species", "species_meta"))
  
  # Call species_meta for each species in the chunk
  result_chunk <- parallel::parLapply(cl, current_species, function(x) species_meta(x, chunk_species_data, chunk_temp_species))
  
  result_list_4 <- c(result_list_4, result_chunk)
}

species_ARR_arboreal_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[1]]))
daily_CTmax_arboreal_mean_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[2]]))
daily_CTmax_arboreal_max_acc_future4C_4 <- do.call(rbind, lapply(result_list_4, function(x) x[[3]]))

rm(chunk_species_data)
rm(chunk_temp_species)
rm(result_chunk)
rm(result_list_4)

Sys.time()

# Save the results for first chunk
saveRDS(species_ARR_arboreal_future4C_4, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_ARR/species_ARR_arboreal_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future4C_4, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_mean_acc/daily_CTmax_arboreal_mean_acc_future4C_4th_chunk.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future4C_4, file="RData/Climate_vulnerability/Arboreal/future4C/temp_files_max_acc/daily_CTmax_arboreal_max_acc_future4C_4th_chunk.rds")

######################

# Stop the cluster
stopCluster(cl)
gc()
```

##### **Combine chunks** 

```{r, eval=F}
# Combine results from all chunks and save 
species_ARR_arboreal_future4C <- distinct(rbind(species_ARR_arboreal_future4C_1,
                                                 species_ARR_arboreal_future4C_2,
                                                 species_ARR_arboreal_future4C_3,
                                                 species_ARR_arboreal_future4C_4))

daily_CTmax_arboreal_mean_acc_future4C <- rbind(daily_CTmax_arboreal_mean_acc_future4C_1,
                                                 daily_CTmax_arboreal_mean_acc_future4C_2,
                                                 daily_CTmax_arboreal_mean_acc_future4C_3,
                                                 daily_CTmax_arboreal_mean_acc_future4C_4)

daily_CTmax_arboreal_max_acc_future4C <- rbind(daily_CTmax_arboreal_max_acc_future4C_1,
                                                daily_CTmax_arboreal_max_acc_future4C_2,
                                                daily_CTmax_arboreal_max_acc_future4C_3,
                                                daily_CTmax_arboreal_max_acc_future4C_4)


saveRDS(species_ARR_arboreal_future4C, file="RData/Climate_vulnerability/Arboreal/future4C/species_ARR_arboreal_future4C.rds")
saveRDS(daily_CTmax_arboreal_mean_acc_future4C, file="RData/Climate_vulnerability/Arboreal/future4C/daily_CTmax_arboreal_mean_acc_future4C.rds")
saveRDS(daily_CTmax_arboreal_max_acc_future4C, file="RData/Climate_vulnerability/Arboreal/future4C/daily_CTmax_arboreal_max_acc_future4C.rds")

```


# **Climate vulnerability assessment** 

## **Vegetated substrate**  {.tabset .tabset_fade .tabset_pills}

Here, we assume that animals are acclimated daily to the mean weekly temperature experienced prior to each day.

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate.pbs** 

Weighted means and standard errors were calculated according to Formula 22 in Higgins & Thompson (2002). Quantifying heterogeneity in a meta-analysis. Stat Med 21:1539–1558

### **Current climate** 

```{r, eval=F}

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_mean_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_current <- daily_CTmax_mean_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_current <- daily_CTmax_mean_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_current <- daily_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_mean_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_current)

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_mean_current   <- pop_vulnerability_mean_current  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current  <- left_join(pop_vulnerability_mean_current , distinct_coord, by="lon_lat")
pop_vulnerability_mean_current  <- pop_vulnerability_mean_current  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_current <- subset(pop_vulnerability_mean_current, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_current, file="RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_current)

saveRDS(community_vulnerability_mean_current, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")

```

### **Future climate (+2C)**

```{r, eval=F}
daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_mean_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_2C <- daily_CTmax_mean_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_2C <- daily_CTmax_mean_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_2C <- daily_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_mean_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_2C)

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_mean_2C   <- pop_vulnerability_mean_2C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C  <- left_join(pop_vulnerability_mean_2C , distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C  <- pop_vulnerability_mean_2C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_2C <- subset(pop_vulnerability_mean_2C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_2C, file="RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_2C)

saveRDS(community_vulnerability_mean_2C, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")

```

### **Future climate (+4C)**

```{r, eval=F}
daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_mean_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_4C <- daily_CTmax_mean_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_4C <- daily_CTmax_mean_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_4C <- daily_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_mean_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_4C)

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_mean_4C   <- pop_vulnerability_mean_4C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C  <- left_join(pop_vulnerability_mean_4C , distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C  <- pop_vulnerability_mean_4C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_4C <- subset(pop_vulnerability_mean_4C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_4C, file="RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_4C)

saveRDS(community_vulnerability_mean_4C, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

```

### **Clip grid cells to match land masses**

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate.pbs** 

```{r, eval=F}
community_df_mean_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_current), function(i) {
  row <- community_df_mean_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")


################################# Do the same for mean future 2C #########################

community_df_mean_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future2C), function(i) {
  row <- community_df_mean_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")



################################# Do the same for mean future 4C #########################

community_df_mean_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future4C), function(i) {
  row <- community_df_mean_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

```

### **Subset of arboreal species** 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate_arboreal_species.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate_arboreal_species.pbs** 

The code to clip the grid cells to match land masses can be found in **R/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate_arboreal_species.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate_arboreal_species.pbs** 

```{r, eval=F}
##############################################################################################################
############### Acclimation to mean weekly temperature on substrate, current climate ######################

pop_vulnerability_mean_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_vulnerability_mean_current_arb <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")

# Filter to arboreal species
pop_vulnerability_mean_current <- pop_vulnerability_mean_current[pop_vulnerability_mean_current$tip.label %in% pop_vulnerability_mean_current_arb$tip.label,]

######## Community-level patterns ################

community_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_current)

saveRDS(community_vulnerability_mean_current, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_arboreal_sp.rds")

rm(community_vulnerability_mean_current)

###################################################################################################################
############### Acclimation to mean weekly temperature on substrate, future climate (+2C) ######################

pop_vulnerability_mean_2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_vulnerability_mean_2C_arb <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")

# Filter to arboreal species
pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C[pop_vulnerability_mean_2C$tip.label %in% pop_vulnerability_mean_2C_arb$tip.label,]

######## Community-level patterns ################

community_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_2C)

saveRDS(community_vulnerability_mean_2C, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_arboreal_sp.rds")

rm(community_vulnerability_mean_2C)

###################################################################################################################
############### Acclimation to mean weekly temperature on substrate, future climate (+4C) ######################

pop_vulnerability_mean_4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")
pop_vulnerability_mean_4C_arb <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

# Filter to arboreal species
pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C[pop_vulnerability_mean_4C$tip.label %in% pop_vulnerability_mean_4C_arb$tip.label,]

######## Community-level patterns ################

community_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_4C)

saveRDS(community_vulnerability_mean_4C, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_arboreal_sp.rds")

#################################################################################################
################################ Clipping grid cells to match land masses #######################
#################################################################################################

################################# Current climate #######################################
community_df_mean_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_arboreal_sp.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_current), function(i) {
  row <- community_df_mean_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells_arboreal_sp.rds")


################################# Future climate (+2C)   ##################################

community_df_mean_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_arboreal_sp.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future2C), function(i) {
  row <- community_df_mean_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells_arboreal_sp.rds")



################################# Future climate (+4C) ########################################

community_df_mean_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_arboreal_sp.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future4C), function(i) {
  row <- community_df_mean_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells_arboreal_sp.rds")

```


## **Pond or wetland** {.tabset .tabset_fade .tabset_pills}

Here, we assume that animals are acclimated daily to the mean weekly temperature experienced prior to each day.

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond.R** and the resources used in **pbs/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond.pbs** 

Weighted means and standard errors were calculated according to Formula 22 in Higgins & Thompson (2002). Quantifying heterogeneity in a meta-analysis. Stat Med 21:1539–1558

### **Current climate** 

```{r, eval=F}

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Pond/current/daily_CTmax_pond_mean_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_current <- daily_CTmax_mean_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_current <- daily_CTmax_mean_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_current <- daily_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_mean_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_current)

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_mean_current   <- pop_vulnerability_mean_current  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current  <- left_join(pop_vulnerability_mean_current , distinct_coord, by="lon_lat")
pop_vulnerability_mean_current  <- pop_vulnerability_mean_current  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_current <- subset(pop_vulnerability_mean_current, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_current, file="RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp =  first(max_temp),  
    community_max_temp_se =  first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_current)

saveRDS(community_vulnerability_mean_current, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")

```

### **Future climate (+2C)**

```{r, eval=F}
daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Pond/future2C/daily_CTmax_pond_mean_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_2C <- daily_CTmax_mean_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_2C <- daily_CTmax_mean_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_2C <- daily_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_mean_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_2C)

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_mean_2C   <- pop_vulnerability_mean_2C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C  <- left_join(pop_vulnerability_mean_2C , distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C  <- pop_vulnerability_mean_2C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_2C <- subset(pop_vulnerability_mean_2C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_2C, file="RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se =  first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_2C)

saveRDS(community_vulnerability_mean_2C, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")

```

### **Future climate (+4C)**

```{r, eval=F}
daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Pond/future4C/daily_CTmax_pond_mean_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_4C <- daily_CTmax_mean_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_4C <- daily_CTmax_mean_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_4C <- daily_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_mean_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_4C)

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_mean_4C   <- pop_vulnerability_mean_4C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C  <- left_join(pop_vulnerability_mean_4C , distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C  <- pop_vulnerability_mean_4C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_4C <- subset(pop_vulnerability_mean_4C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_4C, file="RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_4C)

saveRDS(community_vulnerability_mean_4C, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")


```

### **Clip grid cells to match land masses**

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/Clipping_grid_cells_pond.R** and the resources used in **pbs/Climate_vulnerability/Pond/Clipping_grid_cells_pond.pbs** 

```{r, eval=F}

community_df_mean_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_current), function(i) {
  row <- community_df_mean_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")


################################# Do the same for mean future 2C #########################

community_df_mean_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future2C), function(i) {
  row <- community_df_mean_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")



################################# Do the same for mean future 4C #########################

community_df_mean_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future4C), function(i) {
  row <- community_df_mean_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

```


## **Above-ground vegetation** {.tabset .tabset_fade .tabset_pills}


Here, we assume that animals are acclimated daily to the mean weekly temperature experienced prior to each day.

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal.R** and the resources used in **pbs/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal.pbs** 

Weighted means and standard errors were calculated according to Formula 22 in Higgins & Thompson (2002). Quantifying heterogeneity in a meta-analysis. Stat Med 21:1539–1558

### **Current climate** 

```{r, eval=F}
daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Arboreal/current/daily_CTmax_arboreal_mean_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_current <- daily_CTmax_mean_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_current <- daily_CTmax_mean_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_current <- daily_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_mean_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_current)

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_mean_current  <- pop_vulnerability_mean_current %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current <- left_join(pop_vulnerability_mean_current, distinct_coord, by="lon_lat")
pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_current, file="RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_current)

saveRDS(community_vulnerability_mean_current, file="RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")

```

### **Future climate (+2C)**

```{r, eval=F}
daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future2C/daily_CTmax_arboreal_mean_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_2C <- daily_CTmax_mean_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_2C <- daily_CTmax_mean_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_2C <- daily_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_mean_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_2C)

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_mean_2C  <- pop_vulnerability_mean_2C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C <- left_join(pop_vulnerability_mean_2C, distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_2C, file="RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_2C)

saveRDS(community_vulnerability_mean_2C, file="RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")


```

### **Future climate (+4C)**

```{r, eval=F}
daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future4C/daily_CTmax_arboreal_mean_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_mean_4C <- daily_CTmax_mean_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_mean_4C <- daily_CTmax_mean_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_mean_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_mean_4C <- daily_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_mean_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_4C)

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_mean_4C  <- pop_vulnerability_mean_4C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C <- left_join(pop_vulnerability_mean_4C, distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_4C, file="RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_4C)

saveRDS(community_vulnerability_mean_4C, file="RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```

### **Clip grid cells to match land masses**

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/Clipping_grid_cells_arboreal.R** and the resources used in **pbs/Climate_vulnerability/Arboreal/Clipping_grid_cells_arboreal.pbs** 

```{r, eval=F}

community_df_mean_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_current), function(i) {
  row <- community_df_mean_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")


################################# Do the same for mean future 2C #########################

community_df_mean_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future2C), function(i) {
  row <- community_df_mean_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")



################################# Do the same for mean future 4C #########################

community_df_mean_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future4C), function(i) {
  row <- community_df_mean_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

```

# **Data exploration and summaries** 

## **Population-level data** 

### **Overview of the datasets** {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 

##### **Current climate** 

```{r}
# Load data
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")

kable(head(pop_sub_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")

kable(head(pop_sub_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

kable(head(pop_sub_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

#### **Pond or wetland** 

##### **Current climate** 

```{r}
# Load data
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")

kable(head(pop_pond_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")

kable(head(pop_pond_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")

kable(head(pop_pond_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

#### **Above-ground vegetation** 

##### **Current climate** 

```{r}
# Load data
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")

kable(head(pop_arb_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")

kable(head(pop_arb_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

kable(head(pop_arb_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```


### **Number of populations predicted to overheat** {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 

```{r}
# Load data
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_pop_current <- n_distinct(pop_sub_current[pop_sub_current$overheating_risk>0,])
n_pop_future2C <- n_distinct(pop_sub_future2C[pop_sub_future2C$overheating_risk>0,])
n_pop_future4C <- n_distinct(pop_sub_future4C[pop_sub_future4C$overheating_risk>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_pop_overheating` = c(n_pop_current, n_pop_future2C, n_pop_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px") 

```

#### **Pond or wetland** 

```{r}
# Load data
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_pop_current <- n_distinct(pop_pond_current[pop_pond_current$overheating_risk>0,])
n_pop_future2C <- n_distinct(pop_pond_future2C[pop_pond_future2C$overheating_risk>0,])
n_pop_future4C <- n_distinct(pop_pond_future4C[pop_pond_future4C$overheating_risk>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_pop_overheating` = c(n_pop_current, n_pop_future2C, n_pop_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


#### **Above-ground vegetation** 

```{r}
# Load data
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_pop_current <- n_distinct(pop_arb_current[pop_arb_current$overheating_risk>0,])
n_pop_future2C <- n_distinct(pop_arb_future2C[pop_arb_future2C$overheating_risk>0,])
n_pop_future4C <- n_distinct(pop_arb_future4C[pop_arb_future4C$overheating_risk>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_pop_overheating` = c(n_pop_current, n_pop_future2C, n_pop_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```

#### **Arboreal species on substrate conditions** 

```{r}
# Filter substrate data to only arboreal species
pop_sub_current_arb_subset <- filter(pop_sub_current, tip.label %in% pop_arb_current$tip.label)
pop_sub_future2C_arb_subset <- filter(pop_sub_future2C, tip.label %in% pop_arb_future2C$tip.label)
pop_sub_future4C_arb_subset <- filter(pop_sub_future4C, tip.label %in% pop_arb_future4C$tip.label)


# Counts for each climatic scenario
n_pop_current <- n_distinct(pop_sub_current_arb_subset[pop_sub_current_arb_subset$overheating_risk>0,])
n_pop_future2C <- n_distinct(pop_sub_future2C_arb_subset[pop_sub_future2C_arb_subset$overheating_risk>0,])
n_pop_future4C <- n_distinct(pop_sub_future4C_arb_subset[pop_sub_future4C_arb_subset$overheating_risk>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_pop_overheating` = c(n_pop_current, n_pop_future2C, n_pop_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

```


### **Number of species predicted to overheat**  {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 
```{r}
# Counts for each climatic scenario
n_sp_current <- n_distinct(pop_sub_current$tip.label[pop_sub_current$overheating_risk>0])
n_sp_future2C <- n_distinct(pop_sub_future2C$tip.label[pop_sub_future2C$overheating_risk>0])
n_sp_future4C <- n_distinct(pop_sub_future4C$tip.label[pop_sub_future4C$overheating_risk>0])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_sp_current, n_sp_future2C, n_sp_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


#### **Pond or wetland** 
```{r}
# Counts for each climatic scenario
n_sp_current <- n_distinct(pop_pond_current$tip.label[pop_pond_current$overheating_risk>0])
n_sp_future2C <- n_distinct(pop_pond_future2C$tip.label[pop_pond_future2C$overheating_risk>0])
n_sp_future4C <- n_distinct(pop_pond_future4C$tip.label[pop_pond_future4C$overheating_risk>0])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_sp_current, n_sp_future2C, n_sp_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


#### **Above-ground vegetation** 
```{r}
# Counts for each climatic scenario
n_sp_current <- n_distinct(pop_arb_current$tip.label[pop_arb_current$overheating_risk>0])
n_sp_future2C <- n_distinct(pop_arb_future2C$tip.label[pop_arb_future2C$overheating_risk>0])
n_sp_future4C <- n_distinct(pop_arb_future4C$tip.label[pop_arb_future4C$overheating_risk>0])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_sp_current, n_sp_future2C, n_sp_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```

#### **Arboreal species on substrate conditions** 

```{r}
# Counts for each climatic scenario
n_sp_current <- n_distinct(pop_sub_current_arb_subset$tip.label[pop_sub_current_arb_subset$overheating_risk>0])
n_sp_future2C <- n_distinct(pop_sub_future2C_arb_subset$tip.label[pop_sub_future2C_arb_subset$overheating_risk>0])
n_sp_future4C <- n_distinct(pop_sub_future4C_arb_subset$tip.label[pop_sub_future4C_arb_subset$overheating_risk>0])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_sp_current, n_sp_future2C, n_sp_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


### **Data summaries**  {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 
```{r}
kable(summary(pop_sub_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_sub_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_sub_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

```


#### **Pond or wetland** 
```{r}
kable(summary(pop_pond_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_pond_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_pond_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


#### **Above-ground vegetation** 
```{r}
kable(summary(pop_arb_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_arb_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

kable(summary(pop_arb_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```



## **Community-level data** 

### **Overview of the datasets** {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 

##### **Current climate** 

```{r}
# Load data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")

kable(head(community_sub_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")

kable(head(community_sub_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

kable(head(community_sub_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

#### **Pond or wetland** 

##### **Current climate** 

```{r}
# Load data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")

kable(head(community_pond_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")

kable(head(community_pond_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

kable(head(community_pond_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

#### **Above-ground vegetation** 

##### **Current climate** 

```{r}
# Load data
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")

kable(head(community_arb_current), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+2C)** 

```{r}
# Load data
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")

kable(head(community_arb_future2C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```

##### **Future climate (+4C)** 

```{r}
# Load data
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

kable(head(community_arb_future4C), "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 
```



### **Number of communities with overheating species** {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 

```{r}
# Load data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_commu_current <- n_distinct(community_sub_current[community_sub_current$n_species_overheating>0,])
n_commu_future2C <- n_distinct(community_sub_future2C[community_sub_future2C$n_species_overheating>0,])
n_commu_future4C <- n_distinct(community_sub_future4C[community_sub_future4C$n_species_overheating>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_commu_current, n_commu_future2C, n_commu_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")

```

#### **Pond or wetland** 
```{r}
# Load data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_commu_current <- n_distinct(community_pond_current[community_pond_current$n_species_overheating>0,])
n_commu_future2C <- n_distinct(community_pond_future2C[community_pond_future2C$n_species_overheating>0,])
n_commu_future4C <- n_distinct(community_pond_future4C[community_pond_future4C$n_species_overheating>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_commu_current, n_commu_future2C, n_commu_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


#### **Above-ground vegetation** 
```{r}
# Load data 
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

# Counts for each climatic scenario
n_commu_current <- n_distinct(community_arb_current[community_arb_current$n_species_overheating>0,])
n_commu_future2C <- n_distinct(community_arb_future2C[community_arb_future2C$n_species_overheating>0,])
n_commu_future4C <- n_distinct(community_arb_future4C[community_arb_future4C$n_species_overheating>0,])

results_summary <- data.frame(
  `Climate_Scenario` = c("Current Climate", "Future Climate (+2C)", "Future Climate (+4C)"),
  `Number_sp_overheating` = c(n_commu_current, n_commu_future2C, n_commu_future4C)
)

kable(results_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "250px")
```


### **Data summaries** {.tabset .tabset_fade .tabset_pills}

#### **Vegetated substrate** 
```{r}
summary(community_sub_current)
summary(community_sub_future2C)
summary(community_sub_future4C)
```


#### **Pond or wetland** 
```{r}
summary(community_pond_current)
summary(community_pond_future2C)
summary(community_pond_future4C)
```


#### **Above-ground vegetation** 
```{r}
summary(community_arb_current)
summary(community_arb_future2C)
summary(community_arb_future4C)
```



## **Predicted CTmax of each species** 

```{r}
# Load imputed data
imputed_data <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")

# Filter to imputed data and select relevant columns
imputed_data <- filter(imputed_data, imputed=="yes")

imputed_data <- dplyr::select(imputed_data, 
                              species = tip.label, 
                              order,
                              IUCN_status,
                              ecotype,
                              acclimation_temperature = acclimation_temp,
                              predicted_CTmax = filled_mean_UTL5,
                              lower_95CI = lower_mean_UTL,
                              upper_95CI = upper_mean_UTL)

# Display data
kable(imputed_data, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 

# Summarise data at the species level 
data_summary <- imputed_data %>% 
      group_by(species, order, IUCN_status, ecotype) %>% 
      summarise(acclimation_temperature = mean(acclimation_temperature),
                predicted_CTmax = mean(predicted_CTmax))

# Display data
kable(data_summary, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px")
```


## **Predicted plasticity of each species** 

```{r, fig.width = 20, fig.height = 15}
# Load estimated intercepts and acclimation response ratios
species_ARR <- readRDS("RData/Climate_vulnerability/Pond/current/species_ARR_pond_current.rds")

# Display data
kable(species_ARR, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 

# Summary statistics 
summary(species_ARR$slope)

species_ARR %>% summarise(ARR = mean(slope), 
                          sd = sd(slope))

# Figure
ggplot(species_ARR) + 
  geom_density(aes(slope), 
               fill = "#CE5B97",
               alpha = 1) + 
  xlab("Acclimation Response Ratio (ARR)") + 
  ylab("Number of species") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

ggsave(file = "fig/Figure_S3.png", width = 20, height = 15, dpi = 500)
```


## **Identity of overheating species**

```{r, fig.width=12, fig.height=8}
# Return a list of species predicted to overheat
sp_overheating <- pop_sub_future4C %>% 
  group_by(tip.label) %>% 
  summarise(overheating_days = mean(overheating_days)) %>% 
  filter(overheating_days>0)

# Identify whether overheating species were studied previously 

## Load training data used for the imputation
 training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
 
# Filter to experimental data
training_data <- filter(training_data, imputed=="no")

# Identify if the overheating species were in the original dataset
sp_overheating <- sp_overheating %>% 
  mutate(previously_studied = ifelse(tip.label %in% training_data$tip.label, "yes", "no"))

# Display data
kable(sp_overheating, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px")

sp_overheating$previously_studied=as.factor(sp_overheating$previously_studied)

summary(sp_overheating)

# 69.26% (338/488) of the species identified with a positive overheating risk were not assessed experimentally.

ggplot(sp_overheating, aes(x = previously_studied, 
                           y = log(overheating_days),
                           col = previously_studied,
                           fill = previously_studied))+
   stat_halfeye(
    adjust = 1,
    justification = -0.5,
    .width = 0,
    point_colour = NA,
    alpha = 0.5,
    width = 0.5
  ) +
  geom_jitter(width = 0.15, alpha = 0.85) +
  geom_boxplot(
    width = 0.4,
    outlier.color = NA,
    alpha = 0.9,
    color = "black",
    lwd = 1.15,
    notch = TRUE,
    fill = NA
  ) +   
  theme_classic() +
  ylab("Overheating days (log scale)")+ 
  xlab("Experimentally assessed in previous studies") + 
  theme(axis.title.x = element_text (size = 20, vjust = -0.2),
        axis.title.y = element_text (size = 20, hjust = 0.5),
        axis.text.y = element_text (size = 15),
        axis.text.x = element_text (size = 15),
        panel.border = element_rect(fill=NA, size = 2)) 
```

Figure A1: Mean number of predicted overheating days in terrestrial conditions for species that were assessed experimentally previously (blue), or were fully imputed (pink). 

## **Performance of the imputation** 

```{r, fig.width = 12, fig.height = 8}
# Load data that was used for the imputation
data_for_imp <- readRDS("RData/General_data/pre_data_for_imputation.rds")

# Load datasets from the cross-validation
first_crossV <- readRDS(file = "Rdata/Imputation/results/1st_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "1")
second_crossV <- readRDS(file = "Rdata/Imputation/results/2nd_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "2")
third_crossV <- readRDS(file = "Rdata/Imputation/results/3rd_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "3")
fourth_crossV <- readRDS(file = "Rdata/Imputation/results/4th_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "4")
fifth_crossV <- readRDS(file = "Rdata/Imputation/results/5th_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "5")

all_imputed_dat<- bind_rows(first_crossV,
                            second_crossV,
                            third_crossV,
                            fourth_crossV,
                            fifth_crossV)

# Filter to data that was used for the cross-validation
imp_data <- all_imputed_dat[all_imputed_dat$dat_to_validate=="yes",]
imp_data <- dplyr::filter(imp_data,is.na(tip.label)==FALSE) 

# Add row number
row_n_imp <- data.frame(row_n = imp_data$row_n)

# Filter to original data
original_data <- data_for_imp[data_for_imp$row_n %in% row_n_imp$row_n,]
original_data<- dplyr:::select(original_data, row_n, mean_UTL)

# Combine dataframes
data<- dplyr::left_join(original_data, imp_data, by="row_n")
data <- rename(data, original_CTmax = mean_UTL.x,
                     imputed_CTmax = filled_mean_UTL5)

# Remove observations that were cross-validated twice
duplicates <- data %>% 
  group_by(row_n) %>% 
  summarise(n=n()) %>% 
  filter(n>1) 
duplicates <- duplicates$row_n

data <- data[!(data$row_n %in% duplicates & data$crossV == "5"), ]


data %>% summarise(mean=mean(original_CTmax), 
                   sd=sd(original_CTmax), 
                   n=n())

data %>% summarise(mean=mean(imputed_CTmax), 
                   sd=sd(imputed_CTmax), 
                   n=n())

ggplot(data) + 
  geom_point(aes(x = acclimation_temp, y = original_CTmax), 
             fill = "orange",
             col = "black",
             shape = 21,
             size = 4,
             alpha = 0.75) + 
  geom_point(aes(x = acclimation_temp, y = imputed_CTmax), 
             fill ="#2A788EFF",
             col = "black",
             shape = 21,
             size = 4,
             alpha = 0.75) + 
  geom_smooth(aes(x = acclimation_temp, y = original_CTmax), 
              col="orange", 
              fill = "orange", 
              method="lm",
              linewidth = 2) +
  geom_smooth(aes(x = acclimation_temp, y = imputed_CTmax), 
              col = "#2A788EFF", 
              fill = "#2A788EFF",
              method="lm",
              linewidth = 2) +
  theme_classic() +
  xlab("Acclimation temperature") + 
  ylab("CTmax") + 
  theme(axis.title = element_text(size = 20))
```

Figure A2: Relationship between acclimation temperature and CTmax in the original (orange) and imputed (blue) cross-validated data. 

# **Statistical analyses** 

## **Thermal safety margin** 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_TSM.R** and the resources used in **pbs/Models/Running_models_TSM.pbs** 

### **Population-level patterns** {.tabset .tabset_fade .tabset_pills} 

**Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")
```


#### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in TSM using generalized additive models. These models do not account for the phylogenetic relatedness between species, yet they are better at capturing non-linear patterns in TSM with latitude. While we could have fitted models with smooth terms using brms or stan, these models exceeded our computational capacities. 

##### **Run the models** 

```{r, eval = F}

# Function to run population-level TSM models in parallel 
run_TSM_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(TSM ~ s(lat, bs = "tp"), 
                 random = ~ (1 | genus/species),
                 data = data,
                 weights = 1/(data$TSM_se^2),
                 REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
                     lat = seq(min(data$lat), max(data$lat), length = 1000),
                     TSM = NA, 
                     TSM_se = NA, 
                     genus = NA, 
                     species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/TSM/summary_GAM_pop_lat_TSM_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/TSM/summary_MER_pop_lat_TSM_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/TSM/predictions_pop_lat_TSM_", habitat_scenario, ".rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_pop_lat_TSM_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_pop_lat_TSM_arboreal_future4C.rds"))
```


##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Find limits for colours of the plot
tsm_min <- min(min(pop_sub_current$TSM, na.rm = TRUE), 
               min(pop_sub_future4C$TSM, na.rm = TRUE), 
               min(pop_arb_current$TSM, na.rm = TRUE), 
               min(pop_arb_future4C$TSM, na.rm = TRUE), 
               min(pop_pond_current$TSM, na.rm = TRUE), 
               min(pop_pond_future4C$TSM, na.rm = TRUE))

tsm_max <- max(max(pop_sub_current$TSM, na.rm = TRUE), 
               max(pop_sub_future4C$TSM, na.rm = TRUE), 
               max(pop_arb_current$TSM, na.rm = TRUE), 
               max(pop_arb_future4C$TSM, na.rm = TRUE), 
               max(pop_pond_current$TSM, na.rm = TRUE), 
               max(pop_pond_future4C$TSM, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_future4C.rds")


pop_TSM_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("TSM") +
  ylim(0, tsm_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_TSM_sub
```

Figure A3: Latitudinal variation in thermal safety margin for amphibians on terrestrial conditions. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015. Blue ribbons and points depict TSM in current microclimates. Orange ribbons and points depict TSM in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict TSM in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_future4C.rds")


pop_TSM_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("TSM") +
  ylim(0, tsm_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_TSM_pond
```
Figure A4: Latitudinal variation in thermal safety margin for amphibians in ponds or wetlands. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015. Blue ribbons and points depict TSM in current microclimates. Orange ribbons and points depict TSM in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict TSM in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


###### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_future4C.rds")


pop_TSM_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Thermal safety margin") +
  ylim(0, tsm_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_TSM_arb
```

Figure A5: Latitudinal variation in thermal safety margin for amphibians in above-ground vegetation. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015. Blue ribbons and points depict TSM in current microclimates. Orange ribbons and points depict TSM in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict TSM in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **All habitats** 

```{r, fig.height=20, fig.width=10}
all_habitats <- (pop_TSM_sub /
                 pop_TSM_pond /
                 pop_TSM_arb /
                 plot_layout(ncol = 1))

all_habitats
```

Figure A6: Latitudinal variation in thermal safety margin for amphibians on terrestrial conditions (top panel), in water bodies (middle panel) or in above-ground vegetation (bottom panel). Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015. Blue ribbons and points depict TSM in current microclimates. Orange ribbons and points depict TSM in future climates with 2 degrees Celsius above preindustrial levels. Red ribbons and points depict TSM in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean thermal safety margin in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset**
```{r, eval =F}
# Run analyses with MCMCglmm to estimate mean TSM in each microhabitat and scenario

# Combine datasets
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

# Duplicate tip.label column values
all_data$species <- all_data$tip.label 

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

# Force the tree to be ultrametric
tree <- force.ultrametric(tree, method="extend") 

Ainv<-inverseA(tree)$Ainv

# Convert tibble to dataframe (needed for MCMCglmm)
all_data <- as.data.frame(all_data)

# Set prior
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(TSM ~ habitat_scenario - 1, # No intercept
                random = ~ species + tip.label + idh(TSM_se):units, # Genus, species, phylogenetic relatedness, and weights
                ginverse=list(tip.label = Ainv),
                singular.ok=TRUE,
                prior = prior,
                verbose=FALSE,
                data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/TSM/model_MCMCglmm_TSM.rds")
saveRDS(predictions, file = "RData/Models/TSM/predictions_MCMCglmm_TSM.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(TSM ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                       random = ~ species + tip.label + idh(TSM_se):units, 
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/TSM/model_MCMCglmm_TSM_contrast.rds")
```

###### **Subset of overheating populations** 

Here, we only focus on the populations that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to populations predicted to overheat
all_data$habitat_scenario <- as.character(all_data$habitat_scenario)
all_data$species <- all_data$tip.label
all_data <- filter(all_data, overheating_days > 0)

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv

all_data <- as.data.frame(all_data)

# Run model
model_TSM <- MCMCglmm(TSM ~ habitat_scenario - 1, # No intercept
                      random = ~ species + tip.label + idh(TSM_se):units, # Species, phylogenetic relatedness, and weights
                      ginverse=list(tip.label = Ainv),
                      singular.ok=TRUE,
                      prior = prior,
                      verbose=FALSE,
                      nitt = 600000,
                      thin = 500,
                      burnin = 100000,
                      data = all_data) 

# Get predictions
predictions <- data.frame(emmeans(model_TSM, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_TSM, file = "RData/Models/TSM/model_MCMCglmm_TSM_overheating_pop.rds")
saveRDS(predictions, file = "RData/Models/TSM/predictions_MCMCglmm_TSM_overheating_pop.rds")
```


##### **Model summaries** 

###### **Full dataset**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_TSM <- readRDS("RData/Models/TSM/model_MCMCglmm_TSM.rds")
summary(model_MCMC_TSM)

# Model prediction
print(readRDS("RData/Models/TSM/predictions_MCMCglmm_TSM.rds")
)

# Model diagnostics
plot(model_MCMC_TSM)
```

```{r}
# Model summary (contrasts)
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/model_MCMCglmm_TSM_contrast.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Subset of overheating populations** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_TSM <- readRDS("RData/Models/TSM/model_MCMCglmm_TSM_overheating_pop.rds")
summary(model_MCMC_TSM)

# Model prediction
print(readRDS("RData/Models/TSM/predictions_MCMCglmm_TSM_overheating_pop.rds")
)

# Model diagnostics
plot(model_MCMC_TSM)
```


### **Community-level patterns** {.tabset .tabset_fade .tabset_pills} 

**Load the data** 

```{r}
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```


#### **Generalized additive mixed models** 

Here, we investigate community-level latitudinal patterns in TSM using generalized additive models.

##### **Run the models** 

```{r, eval = F}
# Function to run community-level TSM models in parallel 
run_community_TSM_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(community_TSM ~ s(lat, bs = "tp"),
                        data = data,
                        weights = 1/(data$community_TSM_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
                     lat = seq(min(data$lat), max(data$lat), length = 1000),
                     community_TSM = NA, 
                     community_TSM_se = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, 
          file = paste0("RData/Models/TSM/summary_GAM_community_lat_TSM_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, 
          file = paste0("RData/Models/TSM/summary_MER_community_lat_TSM_", habitat_scenario, ".rds"))
  saveRDS(new_data, 
          file = paste0("RData/Models/TSM/predictions_community_lat_TSM_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  pond_current = community_pond_current,
  pond_future2C = community_pond_future2C,
  pond_future4C = community_pond_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)


# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/summary_MER_community_lat_TSM_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/summary_GAM_community_lat_TSM_arboreal_future4C.rds"))
```

##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

Load data
```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Pond data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>%
    filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_pond_current)


# Find limits for colours of the plot
tsm_min <- min(min(community_sub_current$community_TSM, na.rm = TRUE),
               min(community_sub_future4C$community_TSM, na.rm = TRUE), 
               min(community_arb_current$community_TSM, na.rm = TRUE),
               min(community_arb_future4C$community_TSM, na.rm = TRUE),
               min(community_pond_current$community_TSM, na.rm = TRUE),
               min(community_pond_future4C$community_TSM, na.rm = TRUE))

tsm_max <- max(max(community_sub_current$community_TSM, na.rm = TRUE),
               max(community_sub_future4C$community_TSM, na.rm = TRUE), 
               max(community_arb_current$community_TSM, na.rm = TRUE),
               max(community_arb_future4C$community_TSM, na.rm = TRUE), 
               max(community_pond_current$community_TSM, na.rm = TRUE),
               max(community_pond_future4C$community_TSM, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 6}
# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_sub_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future4C.rds")

lat_sub_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1 ) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("TSM") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future2C + 
                   map_sub_TSM_future4C + 
                   lat_sub_all + 
                   plot_layout(ncol = 4))

substrate_plot
```

Figure A7: Community-level patterns in thermal safety margin for amphibians on terrestrial conditions. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015 in each community (1-degree grid cell). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in TSM in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.

###### **Pond or wetland**

```{r, fig.width = 15, fig.height = 6}
# Current
map_pond_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_pond_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_pond_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_pond_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_current.rds")
pred_community_pond_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future2C.rds")
pred_community_pond_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future4C.rds")

lat_pond_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_pond_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_pond_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_pond_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_pond_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black", 
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("TSM") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

pond_plot <- (map_pond_TSM_current + 
                map_pond_TSM_future2C +
                map_pond_TSM_future4C + 
                lat_pond_all + 
                plot_layout(ncol = 4))

pond_plot
```

Figure A8: Community-level patterns in thermal safety margin for amphibians in water bodies. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015 in each community (1-degree grid cell). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in TSM in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.

###### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 6}
# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_arb_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(name = "TSM",
                     option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future4C.rds")

lat_arb_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("TSM") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                  map_arb_TSM_future2C + 
                  map_arb_TSM_future4C + 
                  lat_arb_all + 
                  plot_layout(ncol = 4))

arboreal_plot
```

Figure A9: Community-level patterns in thermal safety margin for amphibians in above-ground vegetation. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015 in each community (1-degree grid cell). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in TSM in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


###### **All habitats** 

```{r, fig.width = 15, fig.height = 8}

all_habitats <- (substrate_plot/pond_plot/arboreal_plot/plot_layout(ncol = 1))

all_habitats
```

Figure A10: Community-level patterns in thermal safety margin for amphibians on terrestrial conditions (top row), in water bodies (middle row), or in above-ground vegetation (bottom row). Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature during the warmest quarters of 2006-2015 in each community (1-degree grid cell). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in TSM in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean thermal safety margin in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset** 

```{r, eval =F}

all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  community_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  community_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  community_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

all_community_data <- as.data.frame(all_community_data)

prior_community  <- list(R = list(V = 1, nu = 0.002), 
                         G = list(G4 = list(V = 1, fix = 1)))

# Intercept-less model 
model_MCMC_community <- MCMCglmm(community_TSM ~ habitat_scenario - 1, # No intercept
                                 random = ~ idh(community_TSM_se):units, 
                                 singular.ok=TRUE,
                                 prior = prior_community,
                                 verbose=FALSE,
                                 data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC_community, file = "RData/Models/TSM/model_MCMCglmm_community_TSM.rds")
saveRDS(predictions, file = "RData/Models/TSM/predictions_MCMCglmm_community_TSM.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_MCMC_community_contrast <- MCMCglmm(community_TSM ~ relevel(habitat_scenario, ref = "substrate_current"), # Contrast
                                          random = ~ idh(community_TSM_se):units, 
                                          singular.ok=TRUE,
                                          prior = prior_community,
                                          verbose=FALSE,
                                          data = all_community_data)

saveRDS(model_MCMC_community_contrast, file = "RData/Models/TSM/model_MCMCglmm_community_TSM_contrast.rds")

```

###### **Subset of overheating communities** 

Here, we only focus on the communities that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to overheating communities 
all_community_data$habitat_scenario <- as.character(all_community_data$habitat_scenario)

all_community_data <- filter(all_community_data, n_species_overheating > 0)

# Run model
model_TSM_community <- MCMCglmm(community_TSM ~ habitat_scenario - 1, 
                                random = ~ idh(community_TSM_se):units, 
                                singular.ok=TRUE,
                                prior = prior_community,
                                verbose=FALSE,
                                nitt = 600000,
                                thin = 500,
                                burnin = 100000,
                                data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_TSM_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_TSM_community, file = "RData/Models/TSM/model_MCMCglmm_community_TSM_overheating_communities.rds")
saveRDS(predictions, file = "RData/Models/TSM/predictions_MCMCglmm_community_TSM_overheating_communities.rds")

```


##### **Model summaries** 

###### **Full dataset** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_TSM <- readRDS("RData/Models/TSM/model_MCMCglmm_community_TSM.rds")
summary(model_MCMC_TSM)

# Model prediction
print(readRDS("RData/Models/TSM/predictions_MCMCglmm_community_TSM.rds")
)

# Model diagnostics
plot(model_MCMC_TSM)
```

```{r}
# Model summary (contrasts)
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/model_MCMCglmm_community_TSM_contrast.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Subset of overheating communities** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_TSM <- readRDS("RData/Models/TSM/model_MCMCglmm_community_TSM_overheating_communities.rds")
summary(model_MCMC_TSM)

# Model prediction
print(readRDS("RData/Models/TSM/predictions_MCMCglmm_community_TSM_overheating_communities.rds")
)

# Model diagnostics
plot(model_MCMC_TSM)
```



## **CTmax** 

Here, we investigate the variation in CTmax across habitats and warming scenarios. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_CTmax.R** and the resources used in **pbs/Models/Running_models_CTmax.pbs** 

### **Population-level patterns** {.tabset .tabset_fade .tabset_pills} 

 **Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")
```


#### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in CTmax using generalized additive models. These models do not account for the phylogenetic relatedness between species, yet they are better at capturing non-linear patterns in CTmax with latitude. While we could have fitted models with smooth terms using brms or stan, these models exceeded our computational capacities. 

##### **Run the models** 

```{r, eval = F}
# Function to run population-level CTmax models in parallel 
run_CTmax_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(CTmax ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$CTmax_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    CTmax = NA, 
    CTmax_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$CTmax_pred <- pred$fit
  new_data$CTmax_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = CTmax_pred + 1.96 * CTmax_pred_se,
                     lower = CTmax_pred - 1.96 * CTmax_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/CTmax/summary_MER_pop_lat_CTmax_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/CTmax/predictions_pop_lat_CTmax_", habitat_scenario, ".rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_CTmax_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_pop_lat_CTmax_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_pop_lat_CTmax_arboreal_future4C.rds"))
```


##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Find limits for colours of the plot
CTmax_min <- min(min(pop_sub_current$CTmax, na.rm = TRUE), 
                 min(pop_sub_future4C$CTmax, na.rm = TRUE), 
                 min(pop_arb_current$CTmax, na.rm = TRUE), 
                 min(pop_arb_future4C$CTmax, na.rm = TRUE), 
                 min(pop_pond_current$CTmax, na.rm = TRUE), 
                 min(pop_pond_future4C$CTmax, na.rm = TRUE))

CTmax_max <- max(max(pop_sub_current$CTmax, na.rm = TRUE), 
                 max(pop_sub_future4C$CTmax, na.rm = TRUE), 
                 max(pop_arb_current$CTmax, na.rm = TRUE), 
                 max(pop_arb_future4C$CTmax, na.rm = TRUE), 
                 max(pop_pond_current$CTmax, na.rm = TRUE), 
                 max(pop_pond_future4C$CTmax, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_future4C.rds")


pop_CTmax_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("CTmax") +
  ylim(CTmax_min, CTmax_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_CTmax_sub
```

Figure A11: Latitudinal variation in CTmax for amphibians on terrestrial conditions. CTmax is the mean predicted CTmax across the the warmest quarters of 2006-2015. Blue ribbons and points depict CTmax in current microclimates. Orange ribbons and points depict CTmax in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict CTmax in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_future4C.rds")


pop_CTmax_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("CTmax") +
  ylim(CTmax_min, CTmax_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_CTmax_pond
```
Figure A12: Latitudinal variation in CTmax for amphibians in water bodies. CTmax is the mean predicted CTmax across the the warmest quarters of 2006-2015. Blue ribbons and points depict CTmax in current microclimates. Orange ribbons and points depict CTmax in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict CTmax in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_future4C.rds")


pop_CTmax_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("CTmax") +
  ylim(CTmax_min, CTmax_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_CTmax_arb
```

Figure A13: Latitudinal variation in CTmax for amphibians in above-ground vegetation. CTmax is the mean predicted CTmax across the the warmest quarters of 2006-2015. Blue ribbons and points depict CTmax in current microclimates. Orange ribbons and points depict CTmax in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict CTmax in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **All habitats** 

```{r, fig.height=20, fig.width=10}
all_habitats <- (pop_CTmax_sub /
                 pop_CTmax_pond /
                 pop_CTmax_arb /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A14: Latitudinal variation in CTmax for amphibians on terrestrial conditions (top panel), in water bodies (middle panel) or in above-ground vegetation (bottom panel). CTmax is the mean predicted CTmax across the the warmest quarters of 2006-2015. Blue ribbons and points depict CTmax in current microclimates. Orange ribbons and points depict CTmax in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict CTmax in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean CTmax in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset** 

```{r, eval =F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv

all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(CTmax ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(CTmax_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/CTmax/model_MCMCglmm_CTmax.rds")
saveRDS(predictions, file = "RData/Models/CTmax/predictions_MCMCglmm_CTmax.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

# The contrast model could not estimate the phylogenetic effect (likely because CTmax values are rather close).
# Therefore, only a the species-level random effect was kept

prior2  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, fix = 1)))

model_MCMC_contrast <- MCMCglmm(CTmax ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + idh(CTmax_se):units,
                                singular.ok=TRUE,
                                prior = prior2,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/CTmax/model_MCMCglmm_CTmax_contrast.rds")
```

###### **Subset of overheating populations** 

Here, we only focus on the populations that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to populations predicted to overheat
all_data$habitat_scenario <- as.character(all_data$habitat_scenario)
all_data$species <- all_data$tip.label
all_data <- filter(all_data, overheating_days > 0)

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv

all_data <- as.data.frame(all_data)

# Run model
model_CTmax <- MCMCglmm(CTmax ~ habitat_scenario - 1, # No intercept
                        random = ~ species + tip.label + idh(CTmax_se):units, # Species, phylogenetic relatedness, and weights
                        ginverse=list(tip.label = Ainv),
                        singular.ok=TRUE,
                        prior = prior,
                        verbose=FALSE,
                        nitt = 600000,
                        thin = 500,
                        burnin = 100000,
                        data = all_data) 

# Get predictions
predictions <- data.frame(emmeans(model_CTmax, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_CTmax, file = "RData/Models/CTmax/model_MCMCglmm_CTmax_overheating_pop.rds")
saveRDS(predictions, file = "RData/Models/CTmax/predictions_MCMCglmm_CTmax_overheating_pop.rds")
```

##### **Model summaries** 

###### **Full dataset**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/model_MCMCglmm_CTmax.rds")
summary(model_MCMC_CTmax)

# Model prediction
print(readRDS("RData/Models/CTmax/predictions_MCMCglmm_CTmax.rds"))

# Model diagnostics
plot(model_MCMC_CTmax)
```

```{r}
# Model summary (contrasts)
model_MCMC_CTmax_contrast <- readRDS("RData/Models/CTmax/model_MCMCglmm_CTmax_contrast.rds")
summary(model_MCMC_CTmax_contrast)
```

###### **Subset of overheating populations**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/model_MCMCglmm_CTmax_overheating_pop.rds")
summary(model_MCMC_CTmax)

# Model prediction
print(readRDS("RData/Models/CTmax/predictions_MCMCglmm_CTmax_overheating_pop.rds"))

# Model diagnostics
plot(model_MCMC_CTmax)
```


### **Community-level patterns**  {.tabset .tabset_fade .tabset_pills} 

**Load the data** 

```{r}
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```


#### **Generalized additive mixed models** 

Here, we investigate community-level latitudinal patterns in CTmax using generalized additive models.

##### **Run the models** 

```{r, eval = F}
# Function to run community-level CTmax models in parallel 
run_community_CTmax_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(community_CTmax ~ s(lat, bs = "tp"),
                        data = data,
                        weights = 1/(data$community_CTmax_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    community_CTmax = NA, 
    community_CTmax_se = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$CTmax_pred <- pred$fit
  new_data$CTmax_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = CTmax_pred + 1.96 * CTmax_pred_se,
                     lower = CTmax_pred - 1.96 * CTmax_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/CTmax/summary_GAM_community_lat_CTmax_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/CTmax/summary_MER_community_lat_CTmax_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/CTmax/predictions_community_lat_CTmax_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  pond_current = community_pond_current,
  pond_future2C = community_pond_future2C,
  pond_future4C = community_pond_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)


# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_CTmax_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/summary_MER_community_lat_CTmax_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/summary_GAM_community_lat_CTmax_arboreal_future4C.rds"))
```

##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

Load data
```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Pond data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>%
    filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_sub_current)


# Find limits for colours of the plot
CTmax_min <- min(min(community_sub_current$community_CTmax, na.rm = TRUE),
               min(community_sub_future4C$community_CTmax, na.rm = TRUE), 
               min(community_arb_current$community_CTmax, na.rm = TRUE),
               min(community_arb_future4C$community_CTmax, na.rm = TRUE),
               min(community_pond_current$community_CTmax, na.rm = TRUE),
               min(community_pond_future4C$community_CTmax, na.rm = TRUE))

CTmax_max <- max(max(community_sub_current$community_CTmax, na.rm = TRUE),
               max(community_sub_future4C$community_CTmax, na.rm = TRUE), 
               max(community_arb_current$community_CTmax, na.rm = TRUE),
               max(community_arb_future4C$community_CTmax, na.rm = TRUE), 
               max(community_pond_current$community_CTmax, na.rm = TRUE),
               max(community_pond_future4C$community_CTmax, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 6}
# Current
map_sub_CTmax_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     name = "CTmax",
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_sub_CTmax_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_CTmax_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_future4C.rds")

lat_sub_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(CTmax_min, CTmax_max)+
  xlab("") +
  ylab("CTmax") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_CTmax_current + 
                   map_sub_CTmax_future2C + 
                   map_sub_CTmax_future4C + 
                   lat_sub_all + 
                   plot_layout(ncol = 4))

substrate_plot
```

Figure A15: Community-level patterns in CTmax for amphibians on terrestrial conditions. CTmax estimates were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in CTmax in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


###### **Pond or wetland**

```{r, fig.width = 15, fig.height = 6}
# Current
map_pond_CTmax_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     name = "CTmax",
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_pond_CTmax_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future2C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_pond_CTmax_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future4C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_pond_current <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_current.rds")
pred_community_pond_future2C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_future2C.rds")
pred_community_pond_future4C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_substrate_future4C.rds")

lat_pond_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_pond_future4C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_pond_future2C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_pond_current, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_pond_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(CTmax_min, CTmax_max)+
  xlab("") +
  ylab("CTmax") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

pond_plot <- (map_pond_CTmax_current + 
                map_pond_CTmax_future2C +
                map_pond_CTmax_future4C + 
                lat_pond_all + 
                plot_layout(ncol = 4))

pond_plot
```

Figure A16: Community-level patterns in CTmax for amphibians in water bodies. CTmax estimates were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in CTmax in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.

###### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 6}
# Current
map_arb_CTmax_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     name = "CTmax",
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_arb_CTmax_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_CTmax_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = community_CTmax), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(name = "CTmax",
                     option = "inferno", 
                     na.value = "gray1", 
                     breaks = seq(25, 50, by = 5), 
                     limits=c(CTmax_min, CTmax_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/CTmax/predictions_community_lat_CTmax_arboreal_future4C.rds")

lat_arb_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current, 
             aes(x = lat, y = community_CTmax), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(CTmax_min, CTmax_max)+
  xlab("") +
  ylab("CTmax") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_CTmax_current + 
                  map_arb_CTmax_future2C + 
                  map_arb_CTmax_future4C + 
                  lat_arb_all + 
                  plot_layout(ncol = 4))

arboreal_plot
```

Figure A17: Community-level patterns in CTmax for amphibians in above-ground vegetation. CTmax estimates were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in CTmax in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


###### **All habitats** 

```{r, fig.width = 15, fig.height = 8}

all_habitats <- (substrate_plot/pond_plot/arboreal_plot/plot_layout(ncol = 1))

all_habitats
```

Figure A18: Community-level patterns in CTmax for amphibians on terrestrial conditions (top row), in water bodies (middle row), or in above-ground vegetation (bottom row). CTmax estimates were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in CTmax in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean thermal safety margin in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset** 

```{r, eval =F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  community_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  community_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  community_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

all_community_data <- as.data.frame(all_community_data)

prior_community  <- list(R = list(V = 1, nu = 0.002), 
                         G = list(G4 = list(V = 1, fix = 1)))

# Intercept-less model 
model_MCMC_community <- MCMCglmm(community_CTmax ~ habitat_scenario - 1, # No intercept
                                 random = ~ idh(community_CTmax_se):units, 
                                 singular.ok=TRUE,
                                 prior = prior_community,
                                 verbose=FALSE,
                                 data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC_community, file = "RData/Models/CTmax/model_MCMCglmm_community_CTmax.rds")
saveRDS(predictions, file = "RData/Models/CTmax/predictions_MCMCglmm_community_CTmax.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_MCMC_community_contrast <- MCMCglmm(community_CTmax ~ relevel(habitat_scenario, ref = "substrate_current"), # Contrast
                                          random = ~ idh(community_CTmax_se):units, 
                                          singular.ok=TRUE,
                                          prior = prior_community,
                                          verbose=FALSE,
                                          data = all_community_data)

saveRDS(model_MCMC_community_contrast, file = "RData/Models/CTmax/model_MCMCglmm_community_CTmax_contrast.rds")

```

###### **Subset of overheating communities** 

Here, we only focus on the communities that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to overheating communities 
all_community_data$habitat_scenario <- as.character(all_community_data$habitat_scenario)

all_community_data <- filter(all_community_data, n_species_overheating > 0)

# Run model
model_CTmax_community <- MCMCglmm(community_CTmax ~ habitat_scenario - 1, 
                                random = ~ idh(community_TSM_se):units, 
                                singular.ok=TRUE,
                                prior = prior_community,
                                verbose=FALSE,
                                nitt = 600000,
                                thin = 500,
                                burnin = 100000,
                                data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_CTmax_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_CTmax_community, file = "RData/Models/CTmax/model_MCMCglmm_community_CTmax_overheating_communities.rds")
saveRDS(predictions, file = "RData/Models/CTmax/predictions_MCMCglmm_community_CTmax_overheating_communities.rds")

```

##### **Model summaries** 

###### **Full dataset** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/model_MCMCglmm_community_CTmax.rds")
summary(model_MCMC_CTmax)

# Model prediction
print(readRDS("RData/Models/CTmax/predictions_MCMCglmm_community_CTmax.rds"))

# Model diagnostics
plot(model_MCMC_CTmax)
```

```{r}
# Model summary (contrasts)
model_MCMC_CTmax_contrast <- readRDS("RData/Models/CTmax/model_MCMCglmm_community_CTmax_contrast.rds")

summary(model_MCMC_CTmax_contrast)
```

###### **Subset of overheating communities** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/model_MCMCglmm_community_CTmax_overheating_communities.rds")
summary(model_MCMC_CTmax)

# Model prediction
print(readRDS("RData/Models/CTmax/predictions_MCMCglmm_community_CTmax_overheating_communities.rds"))

# Model diagnostics
plot(model_MCMC_CTmax)
```


## **Maximum operative body temperature** 

Here, we investigate the variation in maximum operative body temperatures across habitats and warming scenarios. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_max_temp.R** and the resources used in **pbs/Models/Running_models_max_temp.pbs** 

### **Population-level patterns** {.tabset .tabset_fade .tabset_pills} 

**Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")
```


#### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in maximum body temperature using generalized additive models. These models do not account for the phylogenetic relatedness between species, yet they are better at capturing non-linear patterns with latitude. While we could have fitted models with smooth terms using brms or stan, these models exceeded our computational capacities. 

##### **Run the models** 

```{r, eval = F}
# Function to run population-level max_temp models in parallel 
run_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(max_temp ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    max_temp = NA, 
    max_temp_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/max_temp/summary_MER_pop_lat_max_temp_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/max_temp/predictions_pop_lat_max_temp_", habitat_scenario, ".rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_pop_lat_max_temp_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_pop_lat_max_temp_arboreal_future4C.rds"))
```


##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Find limits for colours of the plot
max_temp_min <- min(min(pop_sub_current$max_temp, na.rm = TRUE), 
                 min(pop_sub_future4C$max_temp, na.rm = TRUE), 
                 min(pop_arb_current$max_temp, na.rm = TRUE), 
                 min(pop_arb_future4C$max_temp, na.rm = TRUE), 
                 min(pop_pond_current$max_temp, na.rm = TRUE), 
                 min(pop_pond_future4C$max_temp, na.rm = TRUE))

max_temp_max <- max(max(pop_sub_current$max_temp, na.rm = TRUE), 
                 max(pop_sub_future4C$max_temp, na.rm = TRUE), 
                 max(pop_arb_current$max_temp, na.rm = TRUE), 
                 max(pop_arb_future4C$max_temp, na.rm = TRUE), 
                 max(pop_pond_current$max_temp, na.rm = TRUE), 
                 max(pop_pond_future4C$max_temp, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_future4C.rds")


pop_max_temp_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Body temperature") +
  ylim(max_temp_min, max_temp_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_max_temp_sub
```

Figure A19: Latitudinal variation in maximum operative body temperatures for amphibians on terrestrial conditions. Body temperatures are averaged across the the warmest quarters of 2006-2015. Blue ribbons and points depict body temperatures in current microclimates. Orange ribbons and points depict body temperatures in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict body temperatures in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_future4C.rds")


pop_max_temp_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Body temperature") +
  ylim(max_temp_min, max_temp_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_max_temp_pond
```
Figure A20: Latitudinal variation in maximum operative body temperatures for amphibians in water bodies. Body temperatures are averaged across the the warmest quarters of 2006-2015. Blue ribbons and points depict body temperatures in current microclimates. Orange ribbons and points depict body temperatures in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict body temperatures in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_future4C.rds")


pop_max_temp_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Body temperature") +
  ylim(max_temp_min, max_temp_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_max_temp_arb
```

Figure A21: Latitudinal variation in maximum operative body temperatures for amphibians in above-ground vegetation. Body temperatures are averaged across the the warmest quarters of 2006-2015. Blue ribbons and points depict body temperatures in current microclimates. Orange ribbons and points depict body temperatures in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict body temperatures in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

###### **All habitats** 

```{r, fig.height=20, fig.width=10}
all_habitats <- (pop_max_temp_sub /
                 pop_max_temp_pond /
                 pop_max_temp_arb /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A22: Latitudinal variation in maximum operative body temperatures for amphibians on terrestrial conditions (top panel), in water bodies (middle panel) or in above-ground vegetation (bottom panel). Body temperatures are averaged across the the warmest quarters of 2006-2015. Blue ribbons and points depict body temperatures in current microclimates. Orange ribbons and points depict body temperatures in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict body temperatures in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean body temperature in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset** 

```{r, eval =F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

plan(sequential) 

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(max_temp ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(max_temp_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/max_temp/model_MCMCglmm_max_temp.rds")
saveRDS(predictions, file = "RData/Models/max_temp/predictions_MCMCglmm_max_temp.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(max_temp_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/max_temp/model_MCMCglmm_max_temp_contrast.rds")
```

###### **Subset of overheating populations** 

Here, we only focus on the populations that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to populations predicted to overheat
all_data$habitat_scenario <- as.character(all_data$habitat_scenario)
all_data$species <- all_data$tip.label
all_data <- filter(all_data, overheating_days > 0)

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv

all_data <- as.data.frame(all_data)

# Run model
model_max_temp <- MCMCglmm(max_temp ~ habitat_scenario - 1, # No intercept
                           random = ~ species + tip.label + idh(max_temp_se):units, # Species, phylogenetic relatedness, and weights
                           ginverse=list(tip.label = Ainv),
                           singular.ok=TRUE,
                           prior = prior,
                           verbose=FALSE,
                           nitt = 600000,
                           thin = 500,
                           burnin = 100000,
                           data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_max_temp, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_max_temp, file = "RData/Models/max_temp/model_MCMCglmm_max_temp_overheating_pop.rds")
saveRDS(predictions, file = "RData/Models/max_temp/predictions_MCMCglmm_max_temp_overheating_pop.rds")
```

##### **Model summaries** 

###### **Full dataset** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/model_MCMCglmm_max_temp.rds")
summary(model_MCMC_max_temp)

# Model prediction
print(readRDS("RData/Models/max_temp/predictions_MCMCglmm_max_temp.rds"))

# Model diagnostics
plot(model_MCMC_max_temp)
```

```{r}
# Model summary (contrasts)
model_MCMC_max_temp_contrast <- readRDS("RData/Models/max_temp/model_MCMCglmm_max_temp_contrast.rds")

summary(model_MCMC_max_temp_contrast)
```

###### **Subset of overheating populations** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/model_MCMCglmm_max_temp_overheating_pop.rds")
summary(model_MCMC_max_temp)

# Model prediction
print(readRDS("RData/Models/max_temp/predictions_MCMCglmm_max_temp_overheating_pop.rds"))

# Model diagnostics
plot(model_MCMC_max_temp)
```

### **Community-level patterns** {.tabset .tabset_fade .tabset_pills} 

**Load the data** 

```{r}
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```


#### **Generalized additive mixed models** 

Here, we investigate community-level latitudinal patterns in max_temp using generalized additive models.

##### **Run the models** 

```{r, eval = F}
# Function to run community-level max_temp models in parallel 
run_community_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(community_max_temp ~ s(lat, bs = "tp"),
                        data = data,
                        weights = 1/(data$community_max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    community_max_temp = NA, 
    community_max_temp_se = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, 
          file = paste0("RData/Models/max_temp/summary_GAM_community_lat_max_temp_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, 
          file = paste0("RData/Models/max_temp/summary_MER_community_lat_max_temp_", habitat_scenario, ".rds"))
  saveRDS(new_data, 
          file = paste0("RData/Models/max_temp/predictions_community_lat_max_temp_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  pond_current = community_pond_current,
  pond_future2C = community_pond_future2C,
  pond_future4C = community_pond_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

plan(multicore(workers=3)) 

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_substrate_future4C.rds"))
```

###### **Pond or wetland** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_pond_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_pond_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_pond_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_pond_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_pond_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_pond_future4C.rds"))
```


###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/summary_MER_community_lat_max_temp_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/summary_GAM_community_lat_max_temp_arboreal_future4C.rds"))
```

##### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

Load data
```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Pond data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>%
    filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_sub_current)


# Find limits for colours of the plot
max_temp_min <- min(min(community_sub_current$community_max_temp, na.rm = TRUE),
               min(community_sub_future4C$community_max_temp, na.rm = TRUE), 
               min(community_arb_current$community_max_temp, na.rm = TRUE),
               min(community_arb_future4C$community_max_temp, na.rm = TRUE),
               min(community_pond_current$community_max_temp, na.rm = TRUE),
               min(community_pond_future4C$community_max_temp, na.rm = TRUE))

max_temp_max <- max(max(community_sub_current$community_max_temp, na.rm = TRUE),
               max(community_sub_future4C$community_max_temp, na.rm = TRUE), 
               max(community_arb_current$community_max_temp, na.rm = TRUE),
               max(community_arb_future4C$community_max_temp, na.rm = TRUE), 
               max(community_pond_current$community_max_temp, na.rm = TRUE),
               max(community_pond_future4C$community_max_temp, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 6}
# Current
map_sub_max_temp_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     name = "Body temperature",
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_sub_max_temp_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_max_temp_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_future4C.rds")

lat_sub_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, max_temp_max)+
  xlab("") +
  ylab("Body temperature") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_max_temp_current + 
                   map_sub_max_temp_future2C + 
                   map_sub_max_temp_future4C + 
                   lat_sub_all + 
                   plot_layout(ncol = 4))

substrate_plot
```

Figure A23: Community-level patterns in maximum operative body temperatures for amphibians on terrestrial conditions. Body temperatures were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in max_temp in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


###### **Pond or wetland**

```{r, fig.width = 15, fig.height = 6}
# Current
map_pond_max_temp_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     name = "Body temperature",
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_pond_max_temp_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future2C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_pond_max_temp_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future4C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_pond_current <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_current.rds")
pred_community_pond_future2C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_future2C.rds")
pred_community_pond_future4C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_substrate_future4C.rds")

lat_pond_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_pond_future4C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_pond_future2C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_pond_current, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_pond_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, max_temp_max)+
  xlab("") +
  ylab("Body temperature") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

pond_plot <- (map_pond_max_temp_current + 
                map_pond_max_temp_future2C +
                map_pond_max_temp_future4C + 
                lat_pond_all + 
                plot_layout(ncol = 4))

pond_plot
```

Figure A24: Community-level patterns in maximum operative body temperatures for amphibians in water bodies. Body temperatures were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in max_temp in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.

###### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 6}
# Current
map_arb_max_temp_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     name = "Body temperature",
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_arb_max_temp_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_max_temp_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = community_max_temp), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "rocket", 
                     na.value = "gray1", 
                     breaks = seq(-5, 35, by = 10), 
                     limits=c(max_temp_min, max_temp_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/max_temp/predictions_community_lat_max_temp_arboreal_future4C.rds")

lat_arb_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current, 
             aes(x = lat, y = community_max_temp), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, max_temp_max)+
  xlab("") +
  ylab("max_temp") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_max_temp_current + 
                  map_arb_max_temp_future2C + 
                  map_arb_max_temp_future4C + 
                  lat_arb_all + 
                  plot_layout(ncol = 4))

arboreal_plot
```

Figure A25: Community-level patterns in maximum operative body temperatures for amphibians in above-ground vegetation. Body temperatures were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in max_temp in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


###### **All habitats** 

```{r, fig.height = 8, fig.width = 15}

all_habitats <- (substrate_plot/pond_plot/arboreal_plot/plot_layout(ncol = 1))

all_habitats
```

Figure A26: Community-level patterns in maximum operative body temperatures for amphibians on terrestrial conditions (top row), in water bodies (middle row), or in above-ground vegetation (bottom row). Body temperatures were averaged within communities (1-degree grid cells). The first column refer to current climates (blue), the middle column assume +2C of warming above pre-industrial levels (orange), and the right column assume +4C of warming above pre-industrial levels (pink). The right panel depicts latitudinal patterns in max_temp in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (pink). Black colour depicts areas with no data.


#### **Bayesian linear mixed models** 

Here, we used Bayesian linear mixed models to estimate the mean thermal safety margin in each microhabitat and climatic scenario. These models account for the different degrees of phylogenetic relatedness and decompose sources of variation among species. 

##### **Run the models** 

###### **Full dataset** 

```{r, eval =F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  community_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  community_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  community_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

all_community_data <- as.data.frame(all_community_data)

prior_community  <- list(R = list(V = 1, nu = 0.002), 
                         G = list(G4 = list(V = 1, fix = 1)))

# Intercept-less model 
model_MCMC_community <- MCMCglmm(community_max_temp ~ habitat_scenario - 1, # No intercept
                                 random = ~ idh(community_max_temp_se):units, 
                                 singular.ok=TRUE,
                                 prior = prior_community,
                                 verbose=FALSE,
                                 data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC_community, file = "RData/Models/max_temp/model_MCMCglmm_community_max_temp.rds")
saveRDS(predictions, file = "RData/Models/max_temp/predictions_MCMCglmm_community_max_temp.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_MCMC_community_contrast <- MCMCglmm(community_max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # Contrast
                                          random = ~ idh(community_max_temp_se):units, 
                                          singular.ok=TRUE,
                                          prior = prior_community,
                                          verbose=FALSE,
                                          data = all_community_data)

saveRDS(model_MCMC_community_contrast, file = "RData/Models/max_temp/model_MCMCglmm_community_max_temp_contrast.rds")


```

###### **Subset of overheating communities** 

Here, we only focus on the communities that are predicted to overheat. 

```{r, eval =F}
# Reload dataset without pond data
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Filter to overheating communities 
all_community_data$habitat_scenario <- as.character(all_community_data$habitat_scenario)

all_community_data <- filter(all_community_data, n_species_overheating > 0)

model_max_temp_community <- MCMCglmm(community_max_temp ~ habitat_scenario - 1, # No intercept
                                     random = ~ idh(community_max_temp_se):units, 
                                     singular.ok=TRUE,
                                     prior = prior_community,
                                     verbose=FALSE,
                                     nitt = 600000,
                                     thin = 500,
                                     burnin = 100000,
                                     data = all_community_data)

# Get predictions
predictions <- data.frame(emmeans(model_max_temp_community, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_community_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_max_temp_community, file = "RData/Models/max_temp/model_MCMCglmm_community_max_temp_overheating_communities.rds")
saveRDS(predictions, file = "RData/Models/max_temp/predictions_MCMCglmm_community_max_temp_overheating_communities.rds")

```

##### **Model summaries** 

###### **Full dataset** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/model_MCMCglmm_community_max_temp.rds")
summary(model_MCMC_max_temp)

# Model prediction
print(readRDS("RData/Models/max_temp/predictions_MCMCglmm_community_max_temp.rds"))

# Model diagnostics
plot(model_MCMC_max_temp)
```

```{r}
# Model summary (contrasts)
model_MCMC_max_temp_contrast <- readRDS("RData/Models/max_temp/model_MCMCglmm_community_max_temp_contrast.rds")

summary(model_MCMC_max_temp_contrast)
```

###### **Subset of overheating communities** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/model_MCMCglmm_community_max_temp_overheating_communities.rds")
summary(model_MCMC_max_temp)

# Model prediction
print(readRDS("RData/Models/max_temp/predictions_MCMCglmm_community_max_temp_overheating_communities.rds"))

# Model diagnostics
plot(model_MCMC_max_temp)
```


## **Overheating risk** {.tabset .tabset_fade .tabset_pills} 

Here, we investigate the variation in overheating risk across microhabitats and climatic scenarios. Note that none of the populations were predicted to overheat in water bodies. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_overheating_risk.R** and the resources used in **pbs/Models/Running_models_overheating_risk.pbs** 

**Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

```


### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in overheating risk using generalized additive models. These models do not account for the phylogenetic relatedness between species, yet they are better at capturing non-linear patterns with latitude. While we could have fitted models with smooth terms using brms or stan, these models exceeded our computational capacities. 

#### **Run the models** 

```{r, eval = F}
run_overheating_risk_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(overheating_risk ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_risk = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)


# Set up parallel processing
plan(multicore(workers=2))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_risk_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/summary_MER_pop_lat_overheating_risk_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/summary_GAM_pop_lat_overheating_risk_arboreal_future4C.rds"))
```


#### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_substrate_future4C.rds")


pop_overheating_risk_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = overheating_risk), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = overheating_risk), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = overheating_risk), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Overheating risk") +
  ylim(0, 1) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_overheating_risk_sub
```

Figure A27: Latitudinal variation in overheating risk for amphibians on terrestrial conditions. Overheating risk represents the probability (0-1) that a population exceeds its physiological limits at least once in the 910 days investigated. Blue ribbons and points depict overheating_risk in current microclimates. Orange ribbons and points depict overheating_risk in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_risk in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


##### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}

# Load model predictions
pred_arb_current <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/overheating_risk/predictions_pop_lat_overheating_risk_arboreal_future4C.rds")


pop_overheating_risk_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = overheating_risk), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = overheating_risk), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = overheating_risk), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.025)) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Overheating risk") +
  ylim(0, 1) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_overheating_risk_arb
```

Figure A28: Latitudinal variation in overheating risk for amphibians in above ground vegetation. Overheating risk represents the probability (0-1) that a population exceeds its physiological limits at least once in the 910 days investigated. Blue ribbons and points depict overheating_risk in current microclimates. Orange ribbons and points depict overheating_risk in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_risk in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

##### **All habitats** 

```{r, fig.height=15, fig.width=10}
all_habitats <- (pop_overheating_risk_sub /
                 pop_overheating_risk_arb /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A29: Latitudinal variation in overheating risk for amphibians on terrestrial conditions (top row) or in above ground vegetation (bottom row). Overheating risk represents the probability (0-1) that a population exceeds its physiological limits at least once in the 910 days investigated. Blue ribbons and points depict overheating_risk in current microclimates. Orange ribbons and points depict overheating_risk in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_risk in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


### **Linear mixed models** 

Here, we used linear mixed models to estimate the mean overheating risk in each microhabitat and climatic scenario. Note that we could not use bayesian linear mixed models because the models failed to mix, even after hundreds of thousands of iterations. These models therefore do not account for variation due to phylogeny, and confidence intervals are likely to be wider than predicted. 

#### **Run the models** 

```{r, eval =F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
model_risk <-  glmer(overheating_risk ~ habitat_scenario - 1 + (1|genus/species), 
                     family = "binomial",
                     control = glmerControl(optimizer ='optimx', 
                                            optCtrl=list(method='nlminb')),
                     data = all_data)

# Get predictions
predictions <- as.data.frame(ggpredict(model_risk, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model and predictions
saveRDS(model_risk, file = "RData/Models/overheating_risk/model_lme4_overheating_risk.rds")
saveRDS(predictions, file = "RData/Models/overheating_risk/predictions_lme4_overheating_risk.rds")

#### Contrasts 
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

# Run model
model_risk_contrast <-  glmer(overheating_risk ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                              family = "binomial",
                              control = glmerControl(optimizer ='optimx', 
                                                     optCtrl=list(method='nlminb')),
                              data = all_data)

# Save model 
saveRDS(model_risk_contrast, file = "RData/Models/overheating_risk/model_lme4_overheating_risk_contrast.rds")

```

#### **Model summaries** 

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_overheating_risk <- readRDS("RData/Models/overheating_risk/model_lme4_overheating_risk.rds")
summary(model_overheating_risk)

# Model predictions
print(readRDS("RData/Models/overheating_risk/predictions_lme4_overheating_risk.rds"))
```


```{r}
# Model summary (contrasts)
model_overheating_risk_contrast <- readRDS("RData/Models/overheating_risk/model_lme4_overheating_risk_contrast.rds")

summary(model_overheating_risk_contrast)
```



## **Overheating days** {.tabset .tabset_fade .tabset_pills} 

Here, we investigate the variation in overheating days across microhabitats and climatic scenarios. Note that none of the populations were predicted to overheat in water bodies. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_overheating_days.R** and the resources used in **pbs/Models/Running_models_overheating_days.pbs** 

**Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")
```


### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in overheating days using generalized additive models. These models do not account for the phylogenetic relatedness between species, yet they are better at capturing non-linear patterns with latitude. While we could have fitted models with smooth terms using brms or stan, these models exceeded our computational capacities. 

#### **Run the models** 

```{r, eval = F}
run_overheating_days_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(overheating_days ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_days = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_days_pred <- pred$fit
  new_data$overheating_days_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_days_pred + 1.96 * overheating_days_pred_se,
                     lower = overheating_days_pred - 1.96 * overheating_days_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_days/predictions_pop_lat_overheating_days_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)


# Set up parallel processing
plan(multicore(workers=2))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_days_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/summary_MER_pop_lat_overheating_days_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/summary_GAM_pop_lat_overheating_days_arboreal_future4C.rds"))
```


#### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_substrate_future4C.rds")


pop_overheating_days_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = overheating_days), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = overheating_days), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = overheating_days), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Overheating days") +
  ylim(0, 131) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_overheating_days_sub
```

Figure A30: Latitudinal variation in overheating days for amphibians on terrestrial conditions. Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


##### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/overheating_days/predictions_pop_lat_overheating_days_arboreal_future4C.rds")


pop_overheating_days_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = overheating_days), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = overheating_days), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = overheating_days), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2, 
             position = position_jitter(width = 0.25, height = 0.25)) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("Overheating days") +
  ylim(0, 131) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

pop_overheating_days_arb
```

Figure A31: Latitudinal variation in overheating days for amphibians in above ground vegetation. Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 

##### **All habitats** 

```{r, fig.height=15, fig.width=10}
all_habitats <- (pop_overheating_days_sub /
                 pop_overheating_days_arb /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A32: Latitudinal variation in overheating days for amphibians on terrestrial conditions (top row) or in above ground vegetation (bottom row). Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from generalised additive mixed models. 


### **Linear mixed models** 

Here, we used linear mixed models to estimate the mean number of overheating days in each microhabitat and climatic scenario. Note that we could not use bayesian linear mixed models because the models failed to mix, even after hundreds of thousands of iterations. These models therefore do not account for variation due to phylogeny, and confidence intervals are likely to be wider than predicted.

#### **Run the models** 

##### **Full dataset** 

```{r, eval =F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
## Note that this model fails if we add an observation-level random effect
model_days <-  glmer(overheating_days ~ habitat_scenario - 1 + (1|genus/species), 
                     family = "poisson",
                     control = glmerControl(optimizer = "bobyqa",
                                            optCtrl = list(maxfun = 1000000000)),
                     data = all_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_days, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model and predictions
saveRDS(model_days, file = "RData/Models/overheating_days/model_lme4_overheating_days.rds")
saveRDS(predictions, file = "RData/Models/overheating_days/predictions_lme4_overheating_days.rds")

#### Contrasts 
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_days_contrast <-  glmer(overheating_days ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                              family = "poisson",
                              control = glmerControl(optimizer = "bobyqa",
                                                     optCtrl = list(maxfun = 1000000000)),
                              data = all_data)

# Save model 
saveRDS(model_days_contrast, file = "RData/Models/overheating_days/model_lme4_overheating_days_contrast.rds")
```

##### **Subset of overheating populations** 

```{r, eval =F}
# Filter to populations predicted to overheat
all_data <- filter(all_data, overheating_days > 0)

model_days_overheating_pop <-  glmer(overheating_days ~ habitat_scenario - 1 + (1|genus/species/obs), 
                                     family = "poisson",
                                     control = glmerControl(optimizer = "bobyqa",
                                                            optCtrl = list(maxfun = 1000000000)),
                                     data = all_data)


# Get predictions
predictions_overheating_pop <- as.data.frame(ggpredict(model_days_overheating_pop, 
                                                       terms = "habitat_scenario", 
                                                       type = "simulate", 
                                                       interval = "confidence", 
                                                       nsim = 1000))

predictions_overheating_pop <- predictions_overheating_pop %>% rename(habitat_scenario = x, 
                                                                      prediction = predicted,
                                                                      se = std.error, 
                                                                      lower_CI = conf.low, 
                                                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model and predictions
saveRDS(model_days_overheating_pop, file = "RData/Models/overheating_days/model_lme4_overheating_days_overheating_pop.rds")
saveRDS(predictions_overheating_pop, file = "RData/Models/overheating_days/predictions_lme4_overheating_days_overheating_pop.rds")

```


#### **Model summaries** 

##### **Full dataset**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_overheating_days <- readRDS("RData/Models/overheating_days/model_lme4_overheating_days.rds")

summary(model_overheating_days)

# Model predictions
print(readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days.rds"))

```

```{r}
# Model summary (contrasts)
model_overheating_days_contrast <- readRDS("RData/Models/overheating_days/model_lme4_overheating_days_contrast.rds")

summary(model_overheating_days_contrast)
```

##### **Subset of overheating populations**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_overheating_days_overheating_pop <- readRDS("RData/Models/overheating_days/model_lme4_overheating_days_overheating_pop.rds")
summary(model_overheating_days_overheating_pop)

# Model prediction
print(readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_overheating_pop.rds"))
```


## **Relationship between TSM and overheating events**  

Here, we investigate the association between thermal safety margins and the predicted number of overheating events across microhabitats and climatic scenarios. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_overheating_days_by_TSM.R** and the resources used in **pbs/Models/Running_models_overheating_days_by_TSM.pbs** 

**Load the data** 

```{r}
# Load population-level data

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")
```


### **Linear mixed models** 

Note that we could not use bayesian linear mixed models because the models failed to mix, even after hundreds of thousands of iterations. Therefore, these predictions do not account for variation due to phylogenetic relatedness and confidence intervals are likely wider than those predicted. 

#### **Run the models** 

```{r, eval = F}
# Function to run the MCMCglmm for each habitat scenario
run_model <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  dataset <- dataset %>% mutate(obs = as.character(row_number()))
  
  data <- dataset
  
  # Set the seed for reproducibility
  set.seed(123)
  
  # Fit the model
  model <-  glmer(overheating_days ~ TSM + (1|genus/species/obs), 
                  family = "poisson",
                  control = glmerControl(optimizer = "bobyqa",
                                         optCtrl = list(maxfun = 1000000000)),
                  data = data)
  
  # Get predictions
  predictions <- data.frame(emmeans(model, 
                                    specs = "TSM", 
                                    data = data, 
                                    at = list(TSM = seq(min(data$TSM), max(data$TSM), length=100)), 
                                    type="response"))
  
  predictions <- predictions %>% rename(prediction = rate)
                               
  saveRDS(model, file = paste0("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_", habitat_scenario, ".rds"))
  saveRDS(predictions, file = paste0("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_", habitat_scenario, ".rds"))
}

dataset_list <- list(substrate_current = pop_sub_current, 
                     substrate_future2C = pop_sub_future2C,
                     substrate_future4C = pop_sub_future4C, 
                     arboreal_current = pop_arb_current, 
                     arboreal_future2C = pop_arb_future2C,
                     arboreal_future4C = pop_arb_future4C)

plan(sequential)

results <- future_lapply(names(dataset_list), function(x) {
  run_model(dataset_list[[x]], x)
}, future.packages = c("lme4", "emmeans", "ggeffects", "dplyr"))
```

#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_substrate_current.rds")))
```

**Future climate (+2C)**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_substrate_future2C.rds")))
```

**Future climate (+4C)**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_substrate_future4C.rds")))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_arboreal_current.rds")))
```

**Future climate (+2C)**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_arboreal_future2C.rds")))

```

**Future climate (+4C)**
```{r}
# Model summary
print(summary(readRDS("RData/Models/overheating_days/model_lme4_overheating_days_by_TSM_arboreal_future4C.rds")))
```


#### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

```{r, fig.width = 15, fig.height = 8}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_substrate_future4C.rds")

pop_days_TSM_sub <- ggplot() + 
  geom_ribbon(data = pred_sub_future4C,
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL), 
              fill = "#EF4187", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL),
              fill = "#FAA43A", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) + 
  geom_ribbon(data = pred_sub_current,
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL), 
              fill = "#5DC8D9", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) +
  xlab("TSM") + 
  ylab("Overheating days") + 
  xlim(0, 20) + 
  ylim(-0.25, 131) + 
  theme_classic() + 
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA), 
        panel.background = element_rect(fill = "transparent", colour = NA), 
        text = element_text(color = "black"), 
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30), 
        axis.text.x = element_text(color = "black",
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(color = "black",
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 3))

pop_days_TSM_sub
```

Figure A34: Relationship between the number of overheating days and TSM in terrestrial conditions. Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from the models.

##### **Above-ground vegetation** 

```{r, fig.width = 15, fig.height = 8}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/overheating_days/predictions_lme4_overheating_days_by_TSM_arboreal_future4C.rds")

pop_days_TSM_arb <- ggplot() + 
  geom_ribbon(data = pred_arb_future4C,
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL), 
              fill = "#EF4187", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL),
              fill = "#FAA43A", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) + 
  geom_ribbon(data = pred_arb_current,
              aes(x = TSM, ymin = asymp.LCL, ymax = asymp.UCL), 
              fill = "#5DC8D9", 
              colour = "black",
              linewidth = 0.5,
              alpha = 0.75) +
  xlab("TSM") + 
  ylab("Overheating days") + 
  xlim(0, 20) + 
  ylim(-0.25, 131) + 
  theme_classic() + 
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA), 
        panel.background = element_rect(fill = "transparent", colour = NA), 
        text = element_text(color = "black"), 
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30), 
        axis.text.x = element_text(color = "black",
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(color = "black",
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 3))

pop_days_TSM_arb
```

Figure A35: Relationship between the number of overheating days and TSM in above-ground vegetation. Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from the models.

##### **All habitats ** 

```{r, fig.height=15, fig.width=10}
all_habitats <- (pop_days_TSM_sub /
                 pop_days_TSM_arb /
                 plot_layout(ncol = 1))

all_habitats
```

Figure A36: Relationship between the number of overheating days and TSM in terrestrial (top row) or arboreal conditions (bottom row). Overheating days represents the number of days that a population exceeds its physiological limits across the 910 days investigated. Blue ribbons and points depict overheating_days in current microclimates. Orange ribbons and points depict overheating_days in future climates with 2 degrees Celsius above preindustrial levels. Pink ribbons and points depict overheating_days in future climates with 4 degrees Celsius above preindustrial levels. Ribbons delimit the lower and upper 95% confidence intervals predicted from the models.


## **Number of species overheating** {.tabset .tabset_fade .tabset_pills} 

Here, we investigate the variation in the number of species predicted to overheating in each community. Note that none of the populations were predicted to overheat in water bodies. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_n_species_overheating.R** and the resources used in **pbs/Models/Running_models_n_species_overheating.pbs** 

**Load the data** 

```{r}
# Load population-level data

# Substrate
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

# Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```


### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in the number of species overheating in each community using generalized additive models. 

#### **Run the models** 

```{r, eval = F}
run_community_n_species_overheating_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(n_species_overheating ~ s(lat, bs = "tp"),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    n_species_overheating = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$n_species_overheating_pred <- pred$fit
  new_data$n_species_overheating_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = n_species_overheating_pred + 1.96 * n_species_overheating_pred_se,
                     lower = n_species_overheating_pred - 1.96 * n_species_overheating_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_", habitat_scenario, ".rds"))
}

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_n_species_overheating_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/summary_MER_community_lat_number_sp_overheating_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/summary_GAM_community_lat_number_sp_overheating_arboreal_future4C.rds"))
```


#### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Set colours
magma_subset <- viridis::magma(100)[40:100]
color_func <- colorRampPalette(c("gray95", magma_subset))
colors_magma <- color_func(100)

community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

sp_min <- min(min(community_sub_current$n_species_overheating, na.rm = TRUE),
              min(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              min(community_pond_current$n_species_overheating, na.rm = TRUE),
              min(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              min(community_arb_current$n_species_overheating, na.rm = TRUE),
              min(community_arb_future4C$n_species_overheating, na.rm = TRUE))

sp_max <- max(max(community_sub_current$n_species_overheating, na.rm = TRUE),
              max(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              max(community_pond_current$n_species_overheating, na.rm = TRUE),
              max(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              max(community_arb_current$n_species_overheating, na.rm = TRUE),
              max(community_arb_future4C$n_species_overheating, na.rm = TRUE))

```


##### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 8}

# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0.1, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_sub_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_substrate_future4C.rds")

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C,
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current,  
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") + 
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black") + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black") + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black") + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 85)+
  xlab("Latitude") +
  ylab("Number of species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future2C + 
                   map_sub_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 4))

substrate_plot
```

Figure A37: Number of species predicted to overheat in each community for amphibians on terrestrial conditions. The number of species overheating as assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015). The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.


##### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 8}

# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0.1, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_arb_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/n_species_overheating/predictions_community_lat_number_sp_overheating_arboreal_future4C.rds")

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C,
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current,  
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") + 
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black") + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black") + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black") + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 85)+
  xlab("Latitude") +
  ylab("Number of species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                   map_arb_TSM_future2C + 
                   map_arb_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 4))

arboreal_plot
```

Figure A38: Number of species predicted to overheat in each community for amphibians in above-ground vegetation. The number of species overheating as assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015). The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.

##### **All habitats** 

```{r, fig.height=7, fig.width = 15}

all_habitats <- (substrate_plot /
                 arboreal_plot /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A39: Number of species predicted to overheat in each community for amphibians on terrestrial conditions (top panel) or in above-ground vegetation (bottom panel). The number of species overheating as assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015). The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.


### **Linear mixed models** 

Here, we used linear mixed models to estimate the mean number of species predicted to overheat in each microhabitat and climatic scenario. Note that we could not use bayesian linear mixed models because the models failed to mix, even after hundreds of thousands of iterations. 

#### **Run the models** 

##### **Full dataset** 

```{r, eval =F}
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")


all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_n_sp <- glmer(n_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                    family = "poisson",
                    control = glmerControl(optimizer = "bobyqa",
                                           optCtrl = list(maxfun = 1000000000)),
                    data = all_community_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_n_sp, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_n_sp, file = "RData/Models/n_species_overheating/model_lme4_number_sp_overheating.rds")
saveRDS(predictions, file = "RData/Models/n_species_overheating/predictions_lme4_number_sp_overheating.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_n_sp_contrast <- glmer(n_species_overheating ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                             family = "poisson",
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)

saveRDS(model_n_sp_contrast, file = "RData/Models/n_species_overheating/model_lme4_number_sp_overheating_contrast.rds")

```

##### **Subset of overheating communities** 

```{r, eval =F}
# Filter to overheating communities 
all_community_data <- filter(all_community_data, n_species_overheating > 0)

# Run model
model_n_sp_overheating_communities <- glmer(n_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                                            family = "poisson",
                                            control = glmerControl(optimizer = "bobyqa",
                                                                   optCtrl = list(maxfun = 1000000000)),
                                            data = all_community_data)


# Get predictions
predictions_overheating_communities <- as.data.frame(ggpredict(model_n_sp_overheating_communities, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions_overheating_communities <- predictions_overheating_communities %>% 
                               rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_n_sp_overheating_communities, file = "RData/Models/n_species_overheating/model_lme4_number_sp_overheating_overheating_communities.rds")
saveRDS(predictions_overheating_communities, file = "RData/Models/n_species_overheating/predictions_lme4_number_sp_overheating_overheating_communities.rds")

```


#### **Model summaries** 

##### **Full dataset**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_n_species_overheating <- readRDS("RData/Models/n_species_overheating/model_lme4_number_sp_overheating.rds")
summary(model_n_species_overheating)

# Model prediction
print(readRDS("RData/Models/n_species_overheating/predictions_lme4_number_sp_overheating.rds"))
```

```{r}
# Model summary (contrasts)
model_n_species_overheating_contrast <- readRDS("RData/Models/n_species_overheating/model_lme4_number_sp_overheating_contrast.rds")
summary(model_n_species_overheating_contrast)
```

##### **Subset of overheating communities**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_n_species_overheating <- readRDS("RData/Models/n_species_overheating/model_lme4_number_sp_overheating_overheating_communities.rds")
summary(model_n_species_overheating)

# Model prediction
print(readRDS("RData/Models/n_species_overheating/predictions_lme4_number_sp_overheating_overheating_communities.rds"))
```



## **Proportion of species overheating** {.tabset .tabset_fade .tabset_pills} 

Here, we investigate the variation in the proportion of species predicted to overheat in each community. Note that none of the populations were predicted to overheat in water bodies. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Running_models_prop_species_overheating.R** and the resources used in **pbs/Models/Running_models_prop_species_overheating.pbs** 

**Load the data** 

```{r}
# Load population-level data

# Substrate
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

# Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

```


### **Generalized additive mixed models** 

Here, we investigate latitudinal patterns in the number of species overheating in each community using generalized additive models. 

#### **Run the models** 

```{r, eval = F}
run_community_proportion_overheating_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(proportion_species_overheating ~ s(lat, bs = "tp"),
                        data = data,
                        weights = data$n_species,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    proportion_species_overheating = NA, 
    n_species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_", habitat_scenario, ".rds"))
}


# Create a list of datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

# Set up parallel processing
plan(multicore(workers=3))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_proportion_overheating_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/summary_MER_community_lat_proportion_sp_overheating_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/summary_GAM_community_lat_proportion_sp_overheating_arboreal_future4C.rds"))
```


#### **Visualize the results** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Set colours
magma_subset <- viridis::magma(100)[40:100]
color_func <- colorRampPalette(c("gray95", magma_subset))
colors_magma <- color_func(100)

community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

```


##### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 8}

# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0.1, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_sub_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_substrate_future4C.rds")

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C,
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current,  
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") + 
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black") + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black") + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black") + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 1)+
  xlab("Latitude") +
  ylab("Proportion of species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future2C + 
                   map_sub_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 4))

substrate_plot
```

Figure A40: Proportion of species predicted to overheat in each community for amphibians on terrestrial conditions. The proportion of species overheating was assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015) divided by the total number of species in a given community. The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.


##### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 8}

# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0.1, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_arb_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = colors_magma, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/prop_species_overheating/predictions_community_lat_proportion_sp_overheating_arboreal_future4C.rds")

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C,
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current,  
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") + 
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black") + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black") + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black") + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 1)+
  xlab("Latitude") +
  ylab("Proportion of species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                   map_arb_TSM_future2C + 
                   map_arb_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 4))

arboreal_plot
```

Figure A41: Proportion of species predicted to overheat in each community for amphibians in above-ground vegetation. The proportion of species overheating was assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015) divided by the total number of species in a given community. The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.

##### **All habitats** 

```{r, fig.height=7, fig.width = 15}

all_habitats <- (substrate_plot /
                 arboreal_plot /
                 plot_layout(ncol = 1))

all_habitats
```


Figure A42: Proportion of species predicted to overheat in each community for amphibians on terrestrial conditions (top panel) or in above-ground vegetation (bottom panel). TThe proportion of species overheating was assessed as the sum of species overheating at least once in the period surveyed (910 days between 2006 and 2015) divided by the total number of species in a given community. The right panel depicts latitudinal patterns in the number of species overheating in current climates (blue), or assuming +2C (orange) or +4C above pre-industrial levels (red). Gray colour depicts species areas where none of the species overheat. Black colour depicts areas with no data.


### **Linear mixed models** 

Here, we used linear mixed models to estimate the mean proportion of species predicted to overheat in each microhabitat and climatic scenario. Note that we could not use bayesian linear mixed models because the models failed to mix, even after hundreds of thousands of iterations. 

#### **Run the models** 

##### **Full dataset** 

```{r, eval =F}
# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")


all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_prop <- glmer(proportion_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                    family = "binomial",
                    weights = n_species,
                    control = glmerControl(optimizer = "bobyqa",
                                            optCtrl = list(maxfun = 1000000000)),
                    data = all_community_data)



# Get predictions
predictions <- as.data.frame(ggpredict(model_prop, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_prop, file = "RData/Models/prop_species_overheating/model_lme4_prop_species_overheating.rds")
saveRDS(predictions, file = "RData/Models/prop_species_overheating/predictions_lme4_prop_species_overheating.rds")


###### Contrasts 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

# Run model
model_prop_contrast <- glmer(proportion_species_overheating ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                             family = "binomial",
                             weights = n_species,
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)
# Save model
saveRDS(model_prop_contrast, file = "RData/Models/prop_species_overheating/model_lme4_prop_species_overheating_contrast.rds")

```

##### **Subset of overheating communities** 

```{r, eval =F}
# Filter to overheating communities 
all_community_data <- filter(all_community_data, n_species_overheating > 0)

# Run model
# Intercept-less model 
model_prop_overheating_communities <- glmer(proportion_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                                            family = "binomial",
                                            weights = n_species,
                                            control = glmerControl(optimizer = "bobyqa",
                                                                   optCtrl = list(maxfun = 1000000000)),
                                            data = all_community_data)



# Get predictions
predictions_overheating_communities <- as.data.frame(ggpredict(model_prop_overheating_communities, 
                                                              terms = "habitat_scenario", 
                                                              type = "random", 
                                                              interval = "confidence", 
                                                              nsim = 1000))

predictions_overheating_communities <- predictions_overheating_communities %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model summaries and predictions
saveRDS(model_prop_overheating_communities, file = "RData/Models/prop_species_overheating/model_lme4_prop_species_overheating_overheating_communities.rds")
saveRDS(predictions_overheating_communities, file = "RData/Models/prop_species_overheating/predictions_lme4_prop_species_overheating_overheating_communities.rds")

```


#### **Model summaries** 

##### **Full dataset**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_prop_sp_overheating <- readRDS("RData/Models/prop_species_overheating/model_lme4_prop_species_overheating.rds")

summary(model_prop_sp_overheating)

# Model predictions
print(readRDS("RData/Models/prop_species_overheating/predictions_lme4_prop_species_overheating.rds"))
```

```{r}
# Model summary (contrasts)
model_prop_sp_overheating_contrast <- readRDS("RData/Models/prop_species_overheating/model_lme4_prop_species_overheating_contrast.rds")
summary(model_prop_sp_overheating_contrast)
```

##### **Subset of overheating populations**

```{r, fig.width = 12, fig.height = 12}
# Model summary 
model_prop_sp_overheating <- readRDS("RData/Models/prop_species_overheating/model_lme4_prop_species_overheating_overheating_communities.rds")
summary(model_prop_sp_overheating)

# Model prediction
print(readRDS("RData/Models/prop_species_overheating/predictions_lme4_prop_species_overheating_overheating_communities.rds"))
```

## **Phylogenetic signal in CTmax** {.tabset .tabset_fade .tabset_pills} 

```{r}
# Load the experimental data
training_data <- readRDS(file="RData/General_data/pre_data_for_imputation.rds")
training_data <- filter(training_data, imputed == "no")
tree <- readRDS(file="RData/General_data/tree_for_imputation.rds")

# Reorganise levels of some variables
training_data <- training_data %>% 
  mutate(species = tip.label,
         acclimated,
         life_stage_tested = factor(life_stage_tested),
         life_stage_tested=factor(life_stage_tested,
                              levels=c("adult", "adults", "larvae"),
                              labels=c("adults", "adults", "larvae")),
         endpoint2 = factor(endpoint, 
                        levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                        labels=c("LRR", "OS", "LRR", "other", "other", "other")),
         ecotype = factor(ecotype)) 

# Remove the family column to run MCMCglmm
training_data <- dplyr::select(training_data, -family) 

# Match data to phylogenetic tree
matchpos <- match(training_data$tip.label, tree$tip.label)
training_data$matchpos <- matchpos
training_data <- training_data %>% filter(is.na(matchpos) == F) 

tree <- drop.tip(tree, tree$tip.label[-match(training_data$tip.label, tree$tip.label)]) 

# Force the tree to be ultrametric
tree<-force.ultrametric(tree, method="extend") 

# Phylogenetic co-variance matrix
Ainv<-inverseA(tree)$Ainv

# Set paramaeter expanded prior
 prior<-  list(R = list(V=1, nu=0.001), 
               G = list(G1=list(V = 1, nu = 0.002, alpha.mu = 0, alpha.V = 1e4), 
                        G2=list(V = 1, nu = 0.002, alpha.mu = 0, alpha.V = 1e4)))

# Fit model with all complete case predictors
model <- MCMCglmm(mean_UTL ~ acclimation_temp + 
                             endpoint2 + 
                             acclimated + 
                             life_stage_tested + 
                             ecotype, 
                  random = ~ tip.label + # Phylogeny + species random effects
                             species,
                  ginverse = list(tip.label = Ainv),
                  pl = TRUE, 
                  pr = TRUE, 
                  nitt = 130000, 
                  thin = 100, 
                  burnin = 30000, 
                  singular.ok = TRUE, 
                  prior = prior, 
                  verbose = FALSE, 
                  data = training_data)
summary(model)

# Calculate proportion of non-residual variance explained by phylogeny
lambda <- model$VCV[,"tip.label"]/(model$VCV[,"tip.label"] + model$VCV[,"species"]) 
posterior.mode(lambda) # Lambda
HPDinterval(lambda) # Highest posterior density
```


# **Sensitivity analyses** 

## **Changing biophysical model parameters** {.tabset .tabset_fade .tabset_pills}

Here, we compared predictions of overheating risk for a high-risk species in a given location assuming different biophsyical parameters.

This code can be run locally, but note that the ectotherm model simulating pond parameters takes time to run (~30 min). 


### **Terrestrial conditions** {.tabset .tabset_fade .tabset_pills}

#### **Standard parameters** 

##### **Find the location and body mass of the species at highest risk** 
```{r}
# Identify the location and species on which to do the sensitivity analysis (species most vulnerable warming)
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")

pop_sub_current <- filter(pop_sub_current, tip.label == "Noblella myrmecoides") # Most high-risk species in terrestrial conditions
high_risk <- pop_sub_current %>% slice_max(order_by = overheating_days, n = 1)
high_risk # The location -69.5, -9.5 is at highest risk for this species

# Find body mass of this assemblage 
presence <- readRDS(file = "RData/General_data/species_coordinates_adjusted.rds")
data_for_imp <- readRDS(file = "RData/General_data/pre_data_for_imputation.rds")

presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label,
                                                    body_mass), by = "tip.label")
median_body_mass <- presence_body_mass %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
  dplyr::ungroup()

median_body_mass[median_body_mass$lon == -69.5 & median_body_mass$lat == -9.5,] # 4.28 g
```

##### **Run the biophysical model** 
```{r}
# Run the biophysical models using the parameters used in the paper 

# Set parameters
dstart <- "01/01/2005"
dfinish <- "31/12/2015"
coords<- c(-69.5, -9.5)

# Run the microclimate model
micro_default <-  NicheMapR::micro_ncep(loc = coords, 
                                dstart = dstart, 
                                dfinish = dfinish, 
                                scenario=4,
                                minshade=85,
                                maxshade=90,
                                Usrhyt = 0.01,
                                cap = 1,
                                ERR = 1.5, 
                                spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')

# Run the ectotherm model
micro <- micro_default
ecto <- NicheMapR::ectotherm(live= 0, 
                             Ww_g = 4.28, 
                             shape = 4, 
                             pct_wet = 80)
environ <- as.data.frame(ecto$environ)

# Calculate daily temperature
daily_temp <- environ %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Create a function to calculate the rolling weekly temperature
calc_yearly_rolling_mean <- function(data) {
  data$mean_weekly_temp <- zoo::rollapply(data$mean_temp, width = 7, FUN = mean,
                                          align = "right", partial = TRUE, fill = NA)
  data$max_weekly_temp <- zoo::rollapply(data$max_temp, width = 7, FUN = mean,
                                         align = "right", partial = TRUE, fill = NA)
  return(data)
}


# Calculate mean weekly temperature
daily_temp <- daily_temp %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days <- daily_temp %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)

```

##### **Calculate climate vulnerability** 

```{r}
# Load imputed data
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")

CTmax_data <- dplyr::select(results_imputation, CTmax = filled_mean_UTL5, lowerCI = lower_mean_UTL,
                            upperCI = upper_mean_UTL, acclimation_temp, tip.label, imputed)  # Select relevant columns

original_data <- dplyr::filter(CTmax_data, imputed == "no")  # Original experimental data
imputed_data <- dplyr::filter(CTmax_data, imputed == "yes")  # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>%
  mutate(se = (upperCI - CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

# Filter to the species of interest 
species_data_n_myrc <- species_data %>% 
  dplyr::filter(tip.label=="Noblella myrmecoides")

# Run meta-analytic model
fit <- metafor::rma(yi = CTmax, sei = se, mod = ~acclimation_temp, data = species_data_n_myrc)
prediction <- predict(fit, newmods = daily_temp_warmest_days$mean_weekly_temp)
daily_CTmax <- dplyr::select((cbind(daily_temp_warmest_days, cbind(predicted_CTmax = prediction$pred,
                                                                   predicted_CTmax_se = prediction$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability <- daily_CTmax %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability, file = "RData/Climate_vulnerability/Substrate/future4C/daily_vulnerability_sensitivity_analysis.rds")

pop_vulnerability <- daily_vulnerability %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  ) 

pop_vulnerability  
```

#### **Smaller body size** 

##### **Run the biophysical model** 
```{r}
micro <- micro_default # Same microclimate model as above

# Run the ectotherm model
ecto_small <- NicheMapR::ectotherm(live= 0, 
                                   Ww_g = 0.5, # Small body mass
                                   shape = 4, 
                                   pct_wet = 80)
environ_small <- as.data.frame(ecto_small$environ)

# Calculate daily temperature
daily_temp_small <- environ_small %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_small <- daily_temp_small %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_small_warmest_days <- daily_temp_small %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)

# Summary statistics
daily_temp_small %>% summarise(mean = mean(max_temp), 
                               sd = sd(max_temp),
                               max = max(max_temp))
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_small <- predict(fit, newmods = daily_temp_small_warmest_days$mean_weekly_temp)
daily_CTmax_small <- dplyr::select((cbind(daily_temp_small_warmest_days, 
                                          cbind(predicted_CTmax = prediction_small$pred,
                                                predicted_CTmax_se = prediction_small$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_small <- daily_CTmax_small %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_small, file = "RData/Climate_vulnerability/Substrate/future4C/daily_vulnerability_small_body_size_sensitivity_analysis.rds")

pop_vulnerability_small <- daily_vulnerability_small %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_small 
```

#### **Larger body size** 

##### **Run the biophysical model** 
```{r}
micro <- micro_default # Same microclimate model as above

# Run the ectotherm model
ecto_large <- NicheMapR::ectotherm(live= 0, 
                                   Ww_g = 50,  # Large body mass
                                   shape = 4, 
                                   pct_wet = 80)
environ_large <- as.data.frame(ecto_large$environ)

# Calculate daily temperature
daily_temp_large <- environ_large %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_large <- daily_temp_large %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_large_warmest_days <- daily_temp_large %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_large <- predict(fit, newmods = daily_temp_large_warmest_days$mean_weekly_temp)
daily_CTmax_large <- dplyr::select((cbind(daily_temp_large_warmest_days, 
                                          cbind(predicted_CTmax = prediction_large$pred,
                                                predicted_CTmax_se = prediction_large$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_large <- daily_CTmax_large %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_large, file = "RData/Climate_vulnerability/Substrate/future4C/daily_vulnerability_large_body_size_sensitivity_analysis.rds")

pop_vulnerability_large <- daily_vulnerability_large %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_large 
```

#### **Underground conditions** 

##### **Run the biophysical model** 
```{r}
micro <- micro_default # Same microclimate model as above
ecto <- NicheMapR::ectotherm(live= 0, 
                             Ww_g = 4.28, 
                             shape = 4, 
                             pct_wet = 80) # Same ectotherm model as previously
environ <- as.data.frame(ecto$environ)

dummy_burrow <- dplyr::select(environ, DOY, YEAR) # Create dummy variable to store results at different depths
soil_temp <- as.data.frame(micro$soil) # Extract soil temperatures at different depths
environ_burrow <- cbind(dummy_burrow, dplyr::select(soil_temp, D2.5cm, D5cm, D10cm, D15cm, D20cm)) # Get soil depths up to 20 cm
environ_burrow <- pivot_longer(environ_burrow, 
                               cols = D2.5cm:D20cm,
                               names_to = "DEPTH", 
                               names_prefix = "D", 
                               values_to = "TC") # Pivot longer

# Calculate daily temperature
daily_temp_burrow <- environ_burrow %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY, DEPTH) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_burrow <- daily_temp_burrow %>%
  dplyr::group_by(YEAR, DEPTH) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_burrow_warmest_days <- daily_temp_burrow %>%
  dplyr::group_by(YEAR, DEPTH) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_burrow <- predict(fit, newmods = daily_temp_burrow_warmest_days$mean_weekly_temp)
daily_CTmax_burrow <- dplyr::select((cbind(daily_temp_burrow_warmest_days, 
                                           cbind(predicted_CTmax = prediction_burrow$pred,
                                                 predicted_CTmax_se = prediction_burrow$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_burrow <- daily_CTmax_burrow %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_burrow, file = "RData/Climate_vulnerability/Substrate/future4C/daily_vulnerability_burrow_sensitivity_analysis.rds")

pop_vulnerability_burrow <- daily_vulnerability_burrow %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(DEPTH) %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_burrow 

```


#### **Open habitats** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model with reduced shade
micro_open <-  NicheMapR::micro_ncep(loc = coords, 
                                dstart = dstart, 
                                dfinish = dfinish, 
                                scenario=4,
                                minshade=50, # Reduced shade (50%)
                                maxshade=90,
                                Usrhyt = 0.01,
                                cap = 1,
                                ERR = 1.5, 
                                spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')
# Run the ectotherm model
micro <- micro_open
ecto_open <- NicheMapR::ectotherm(live= 0, 
                                  Ww_g = 4.28, 
                                  shape = 4, 
                                  pct_wet = 80)
environ_open <- as.data.frame(ecto_open$environ)

# Calculate daily temperature
daily_temp_open<- environ_open %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_open <- daily_temp_open %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_open_warmest_days <- daily_temp_open %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_open <- predict(fit, newmods = daily_temp_open_warmest_days$mean_weekly_temp)
daily_CTmax_open <- dplyr::select((cbind(daily_temp_open_warmest_days, 
                                         cbind(predicted_CTmax = prediction_open$pred,
                                               predicted_CTmax_se = prediction_open$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_open <- daily_CTmax_open %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_open, file = "RData/Climate_vulnerability/Substrate/future4C/daily_vulnerability_open_habitat_sensitivity_analysis.rds")

pop_vulnerability_open <- daily_vulnerability_open %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_open 
```

#### **Compare the results** 

```{r, fig.height = 20, fig.width = 16}
# Open habitats and burrows
habitat_selection <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_open, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "red") + 
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "2.5cm"), 
               aes(x=daily_TSM), 
               fill = "gold", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "5cm"), 
               aes(x=daily_TSM), 
               fill = "#BA9E49", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "10cm"), 
               aes(x=daily_TSM), 
               fill = "darkorange", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "15cm"), 
               aes(x=daily_TSM), 
               fill = "#F1AF79", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "20cm"), 
               aes(x=daily_TSM), 
               fill = "#995C51", 
               alpha = 0.7) +
  geom_density(data = daily_vulnerability, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-6.5, 5) + 
  ylim(0, 1.05) +
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))


# Body size

body_size <- 
ggplot()+ 
  geom_density(data = daily_vulnerability_small, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#49BAAE") + 
  geom_density(data = daily_vulnerability_large, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#BA4989") +
  geom_density(data = daily_vulnerability, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))


terrestrial_parameters <- body_size / habitat_selection 

terrestrial_parameters

ggsave(terrestrial_parameters, file = "fig/Figure_S9.png", height = 20, width=16, dpi = 500)
```



### **Aquatic conditions** {.tabset .tabset_fade .tabset_pills}

#### **Standard parameters** 

##### **Run the biophysical model** 
```{r}

micro <- micro_default # Same microclimate model as before
micro$metout[, 13] <- 0 # Make sure the pond stays in the shade

ecto_pond <- ectotherm(container=1, # container model
                       conth=1500, # shallow pond of 1.5m depth
                       contw=12000,# pond of 12m width
                       contype=1, # container sunk into the ground like a pond
                       rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
                       continit = 1500, # Initial container water level (1.5m)
                       conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
                       contwet=100, # 100% of container surface area acting as free water exchanger
                       contonly=1)

environ_pond <- as.data.frame(ecto_pond$environ)

# Calculate daily temperature
daily_temp_pond <- environ_pond %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_pond <- daily_temp_pond %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_pond <- daily_temp_pond %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability** 
```{r}
# Generate predictions
prediction_pond <- predict(fit, newmods = daily_temp_warmest_days_pond$mean_weekly_temp)
daily_CTmax_pond <- dplyr::select((cbind(daily_temp_warmest_days_pond, 
                                                 cbind(predicted_CTmax = prediction_pond$pred,
                                                       predicted_CTmax_se = prediction_pond$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_pond <- daily_CTmax_pond %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_pond, file = "RData/Climate_vulnerability/Pond/future4C/daily_vulnerability_pond_sensitivity_analysis.rds")

pop_vulnerability_pond <- daily_vulnerability_pond %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_pond 
```

#### **Shallower pond** 

##### **Run the biophysical model** 
```{r}
micro <- micro_default # Same microclimate model as before
micro$metout[, 13] <- 0 # Make sure the pond stays in the shade

ecto_pond_shallow <- ectotherm(container=1, # container model
                               conth=50, # shallow pond of 50 cm depth
                               contw=12000,# pond of 12m width
                               contype=1, # container sunk into the ground like a pond
                               rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
                               continit = 1500, # Initial container water level (1.5m)
                               conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
                               contwet=100, # 100% of container surface area acting as free water exchanger
                               contonly=1)

environ_pond_shallow <- as.data.frame(ecto_pond_shallow$environ)

# Calculate daily temperature
daily_temp_pond_shallow <- environ_pond_shallow %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_pond_shallow <- daily_temp_pond_shallow %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_pond_shallow <- daily_temp_pond_shallow %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)

```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_pond_shallow <- predict(fit, newmods = daily_temp_warmest_days_pond_shallow$mean_weekly_temp)
daily_CTmax_pond_shallow <- dplyr::select((cbind(daily_temp_warmest_days_pond_shallow, 
                                         cbind(predicted_CTmax = prediction_pond_shallow$pred,
                                               predicted_CTmax_se = prediction_pond_shallow$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_pond_shallow <- daily_CTmax_pond_shallow %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_pond_shallow, file = "RData/Climate_vulnerability/Pond/future4C/daily_vulnerability_shallow_pond_sensitivity_analysis.rds")

pop_vulnerability_pond_shallow <- daily_vulnerability_pond_shallow %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_pond_shallow 
```


#### **Deeper pond** 

##### **Run the biophysical model** 
```{r}
micro <- micro_default # Same microclimate model as before
micro$metout[, 13] <- 0 # Make sure the pond stays in the shade

ecto_pond_deep <- ectotherm(container=1, # container model
                            conth=3000, # deep pond of 3 meters depth
                            contw=12000,# pond of 12m width
                            contype=1, # container sunk into the ground like a pond
                            rainmult = 1000000000, # rainfall multiplier, to keep the pond wet
                            continit = 1500, # Initial container water level (1.5m)
                            conthole = 0, # Daily loss of height (mm) due to hole in container (e.g. infiltration)
                            contwet=100, # 100% of container surface area acting as free water exchanger
                            contonly=1)

environ_pond_deep <- as.data.frame(ecto_pond_deep$environ)

# Calculate daily temperature
daily_temp_pond_deep <- environ_pond_deep %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_pond_deep <- daily_temp_pond_deep %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_pond_deep <- daily_temp_pond_deep %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_pond_deep <- predict(fit, newmods = daily_temp_warmest_days_pond_deep$mean_weekly_temp)
daily_CTmax_pond_deep <- dplyr::select((cbind(daily_temp_warmest_days_pond_deep, 
                                                 cbind(predicted_CTmax = prediction_pond_deep$pred,
                                                       predicted_CTmax_se = prediction_pond_deep$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_pond_deep <- daily_CTmax_pond_deep %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_pond_deep, file = "RData/Climate_vulnerability/Pond/future4C/daily_vulnerability_deep_pond_sensitivity_analysis.rds")

pop_vulnerability_pond_deep <- daily_vulnerability_pond_deep %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_pond_deep 
```

#### **Compare the results** 

```{r, fig.height = 10, fig.width = 12}
# Pond depth

aquatic_parameters <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_pond_shallow, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "lightblue") + 
  geom_density(data = daily_vulnerability_pond_deep, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "darkblue") +
  geom_density(data = daily_vulnerability_pond, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 6) + 
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

aquatic_parameters

ggsave(aquatic_parameters, file = "fig/Figure_S10.png", height = 10, width=12, dpi = 500)

```


### **Arboreal conditions** {.tabset .tabset_fade .tabset_pills}

#### **Standard conditions** 

##### **Find the location and body mass of the species at highest risk** 
```{r}
# Identify the location and species on which to do the sensitivity analysis (species most vulnerable warming)
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")

pop_arb_current <- filter(pop_arb_current, tip.label == "Pristimantis ockendeni") # Most high-risk species in arboreal conditions
high_risk_arb <- pop_arb_current %>% slice_max(order_by = overheating_days, n = 1)
high_risk_arb # The location -71.5, -4.5 is at highest risk for this species

# Find body mass of this assemblage 
presence_arb <- readRDS(file = "RData/General_data/species_coordinates_adjusted_arboreal.rds")

presence_body_mass_arb <- merge(presence_arb, dplyr::select(data_for_imp, tip.label,
                                                    body_mass), by = "tip.label")
median_body_mass_arb <- presence_body_mass_arb %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
  dplyr::ungroup()

median_body_mass_arb[median_body_mass_arb$lon == -71.5 & median_body_mass_arb$lat == -4.5,] # 2.85 g
```

##### **Run the biophysical model** 
```{r}
# Set coordinates
coords_arb <- c(-71.5, -4.5)

# Run the microclimate model
micro_arb <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                    dstart = dstart, 
                                    dfinish = dfinish, 
                                    scenario=4, # 4C of warming
                                    minshade=85,
                                    maxshade=90,
                                    Usrhyt = 2, # 2 meters above ground
                                    windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                                    microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                                    ERR = 1.5,
                                    spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                    terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')

# Run the ectotherm model
micro <- micro_arb
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2m)

ecto_arb <- NicheMapR::ectotherm(live= 0, 
                                 Ww_g = 2.85, 
                                 shape = 4, 
                                 pct_wet = 80)

environ_arb <- as.data.frame(ecto_arb$environ)

# Calculate daily temperature
daily_temp_arb <- environ_arb %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb <- daily_temp_arb %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb <- daily_temp_arb %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```


##### **Calculate climate vulnerability** 

```{r}
# Load imputed data
results_imputation <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")

CTmax_data <- dplyr::select(results_imputation, CTmax = filled_mean_UTL5, lowerCI = lower_mean_UTL,
                            upperCI = upper_mean_UTL, acclimation_temp, tip.label, imputed)  # Select relevant columns

original_data <- dplyr::filter(CTmax_data, imputed == "no")  # Original experimental data
imputed_data <- dplyr::filter(CTmax_data, imputed == "yes")  # Imputed data

# Calculate standard error of each observation
imputed_data <- imputed_data %>%
  mutate(se = (upperCI - CTmax)/1.96)

# Group data by species
species_data <- imputed_data %>%
  group_by(tip.label)

# Filter to the species of interest 
species_data_p_ock <- species_data %>% 
  dplyr::filter(tip.label=="Pristimantis ockendeni")

# Generate predictions
fit_p_ock <- metafor::rma(yi = CTmax, sei = se, mod = ~acclimation_temp, data = species_data_p_ock)
prediction_arb <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb$mean_weekly_temp)
daily_CTmax_arb <- dplyr::select((cbind(daily_temp_warmest_days_arb, 
                                              cbind(predicted_CTmax = prediction_arb$pred,
                                                    predicted_CTmax_se = prediction_arb$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb <- daily_CTmax_arb %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_arb, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_sensitivity_analysis.rds")

pop_vulnerability_arb <- daily_vulnerability_arb %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb 

```

#### **Lower plant height** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_short <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                          dstart = dstart, 
                                          dfinish = dfinish, 
                                          scenario=4,
                                          minshade=85,
                                          maxshade=90,
                                          Usrhyt = 0.5, # 0.5 m above ground
                                          windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                                          microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                                          ERR = 1.5,
                                          spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                          terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_short
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (50 cm)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (50 cm)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (50 cm)

ecto_arb_short <- NicheMapR::ectotherm(live= 0, 
                                       Ww_g = 2.85, 
                                       shape = 4, 
                                       pct_wet = 80)

environ_arb_short <- as.data.frame(ecto_arb_short$environ)

# Calculate daily temperature
daily_temp_arb_short <- environ_arb_short %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_short <- daily_temp_arb_short %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_short <- daily_temp_arb_short %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)

```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_short <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_short$mean_weekly_temp)
daily_CTmax_arb_short <- dplyr::select((cbind(daily_temp_warmest_days_arb_short, 
                                                 cbind(predicted_CTmax = prediction_arb_short$pred,
                                                       predicted_CTmax_se = prediction_arb_short$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_short <- daily_CTmax_arb_short %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_arb_short, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_short_height_sensitivity_analysis.rds")

pop_vulnerability_arb_short <- daily_vulnerability_arb_short %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_short 

```


#### **Higher plant height** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_tall <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                         dstart = dstart, 
                                         dfinish = dfinish, 
                                         scenario=4,
                                         minshade=85,
                                         maxshade=90,
                                         Usrhyt = 5, # 5 meters above ground
                                         Refhyt = 5,
                                         windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                                         microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                                         ERR = 1.5,
                                         spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                         terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_tall
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (5 m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (5 m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (5 m)

ecto_arb_tall <- NicheMapR::ectotherm(live= 0, 
                                      Ww_g = 2.85, 
                                      shape = 4, 
                                      pct_wet = 80)

environ_arb_tall <- as.data.frame(ecto_arb_tall$environ)

# Calculate daily temperature
daily_temp_arb_tall <- environ_arb_tall %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_tall <- daily_temp_arb_tall %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_tall <- daily_temp_arb_tall %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_tall <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_tall$mean_weekly_temp)
daily_CTmax_arb_tall <- dplyr::select((cbind(daily_temp_warmest_days_arb_tall, 
                                              cbind(predicted_CTmax = prediction_arb_tall$pred,
                                                    predicted_CTmax_se = prediction_arb_tall$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_tall <- daily_CTmax_arb_tall %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_arb_tall, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_tall_height_sensitivity_analysis.rds")

pop_vulnerability_arb_tall <- daily_vulnerability_arb_tall %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_tall 
```

#### **75% radiation diffused** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_mid_diff <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                             dstart = dstart, 
                                             dfinish = dfinish, 
                                             scenario=4,
                                             minshade=85,
                                             maxshade=90,
                                             Usrhyt = 2,
                                             windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                                             microclima.LAI = 0.75, # 75% of the radiation is diffused because of vegetation
                                             ERR = 1.5,
                                             spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                             terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_mid_diff
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2 m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2 m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2 m)

ecto_arb_mid_diff <- NicheMapR::ectotherm(live= 0, 
                                          Ww_g = 2.85, 
                                          shape = 4, 
                                          pct_wet = 80)

environ_arb_mid_diff <- as.data.frame(ecto_arb_mid_diff$environ)

# Calculate daily temperature
daily_temp_arb_mid_diff <- environ_arb_mid_diff %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_mid_diff <- daily_temp_arb_mid_diff %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_mid_diff <- daily_temp_arb_mid_diff %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)

```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_mid_diff <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_mid_diff$mean_weekly_temp)
daily_CTmax_arb_mid_diff <- dplyr::select((cbind(daily_temp_warmest_days_arb_mid_diff, 
                                              cbind(predicted_CTmax = prediction_arb_mid_diff$pred,
                                                    predicted_CTmax_se = prediction_arb_mid_diff$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_mid_diff <- daily_CTmax_arb_mid_diff %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_arb_mid_diff, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_med_solar_diff_sensitivity_analysis.rds")

pop_vulnerability_arb_mid_diff <- daily_vulnerability_arb_mid_diff %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_mid_diff 
```


#### **50% radiation diffused** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_low_diff <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                             dstart = dstart, 
                                             dfinish = dfinish, 
                                             scenario=4,
                                             minshade=85,
                                             maxshade=90,
                                             Usrhyt = 2,
                                             windfac = 0.2, # Reduce wind speed by 80% in dense vegetation
                                             microclima.LAI = 0.5, # 50% of the radiation is diffused because of vegetation
                                             ERR = 1.5,
                                             spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                             terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_low_diff
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2 m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2 m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2 m)

ecto_arb_low_diff <- NicheMapR::ectotherm(live= 0, 
                                          Ww_g = 2.85, 
                                          shape = 4, 
                                          pct_wet = 80)

environ_arb_low_diff <- as.data.frame(ecto_arb_low_diff$environ)

# Calculate daily temperature
daily_temp_arb_low_diff <- environ_arb_low_diff %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_low_diff <- daily_temp_arb_low_diff %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_low_diff <- daily_temp_arb_low_diff %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_low_diff <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_low_diff$mean_weekly_temp)
daily_CTmax_arb_low_diff <- dplyr::select((cbind(daily_temp_warmest_days_arb_low_diff, 
                                             cbind(predicted_CTmax = prediction_arb_low_diff$pred,
                                                   predicted_CTmax_se = prediction_arb_low_diff$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_low_diff <- daily_CTmax_arb_low_diff %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))


saveRDS(daily_vulnerability_arb_low_diff, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_low_solar_diff_sensitivity_analysis.rds")

pop_vulnerability_arb_low_diff <- daily_vulnerability_arb_low_diff %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_low_diff 
```

#### **100% wind reduction** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_no_wind <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                            dstart = dstart, 
                                            dfinish = dfinish, 
                                            scenario=4,
                                            minshade=85,
                                            maxshade=90,
                                            Usrhyt = 2,
                                            windfac = 0, # Reduce wind speed by 100% in vegetation
                                            microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                                            ERR = 1.5,
                                            spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                            terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_no_wind
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2 m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2 m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2 m)

ecto_arb_no_wind <- NicheMapR::ectotherm(live= 0, 
                                         Ww_g = 2.85, 
                                         shape = 4, 
                                         pct_wet = 80)

environ_arb_no_wind <- as.data.frame(ecto_arb_no_wind$environ)

# Calculate daily temperature
daily_temp_arb_no_wind <- environ_arb_no_wind %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_no_wind <- daily_temp_arb_no_wind %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_no_wind <- daily_temp_arb_no_wind %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_no_wind <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_no_wind$mean_weekly_temp)
daily_CTmax_arb_no_wind <- dplyr::select((cbind(daily_temp_warmest_days_arb_no_wind, 
                                                 cbind(predicted_CTmax = prediction_arb_no_wind$pred,
                                                       predicted_CTmax_se = prediction_arb_no_wind$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_no_wind <- daily_CTmax_arb_no_wind %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))


saveRDS(daily_vulnerability_arb_no_wind, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_no_wind_sensitivity_analysis.rds")

pop_vulnerability_arb_no_wind <- daily_vulnerability_arb_no_wind %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_no_wind 
```


#### **50% wind reduction** 

##### **Run the biophysical model** 
```{r}
# Run the microclimate model
micro_arb_high_wind <-  NicheMapR::micro_ncep(loc = coords_arb, 
                                              dstart = dstart, 
                                              dfinish = dfinish, 
                                              scenario=4,
                                              minshade=85,
                                              maxshade=90,
                                              Usrhyt = 2,
                                              windfac = 0.5, # Reduce wind speed by 50% in vegetation
                                              microclima.LAI = 0.9, # 90% of the radiation is diffused because of vegetation
                                              ERR = 1.5,
                                              spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time',
                                              terra_source = 'E:/p_pottier/Climatic_data/data/climatic_data_TerraClimate/data')


# Run the ectotherm model
micro <- micro_arb_high_wind
micro$metout[, 3] <- micro$metout[, 4] # Make the local height equal to reference height (2 m)
micro$metout[, 5] <- micro$metout[, 6] # Make the local height equal to reference height (2 m)
micro$metout[, 7] <- micro$metout[, 8] # Make the local height equal to reference height (2 m)

ecto_arb_high_wind <- NicheMapR::ectotherm(live= 0, 
                                           Ww_g = 2.85, 
                                           shape = 4, 
                                           pct_wet = 80)

environ_arb_high_wind <- as.data.frame(ecto_arb_high_wind$environ)

# Calculate daily temperature
daily_temp_arb_high_wind <- environ_arb_high_wind %>%
  dplyr::mutate(YEAR = YEAR + 2004) %>%
  dplyr::group_by(YEAR, DOY) %>%
  dplyr::summarize(max_temp = max(TC), 
                   mean_temp = mean(TC), .groups = "drop") 

# Calculate mean weekly temperature
daily_temp_arb_high_wind <- daily_temp_arb_high_wind %>%
  dplyr::group_by(YEAR) %>%
  dplyr::group_modify(~calc_yearly_rolling_mean(.))

# Identify the warmest 91 days (3 months) of each year
daily_temp_warmest_days_arb_high_wind <- daily_temp_arb_high_wind %>%
  dplyr::group_by(YEAR) %>%
  dplyr::top_n(91, max_temp) %>% 
  dplyr::filter(YEAR > 2005)
```

##### **Calculate climate vulnerability**
```{r}
# Generate predictions
prediction_arb_high_wind <- predict(fit_p_ock, newmods = daily_temp_warmest_days_arb_high_wind$mean_weekly_temp)
daily_CTmax_arb_high_wind <- dplyr::select((cbind(daily_temp_warmest_days_arb_high_wind, 
                                                 cbind(predicted_CTmax = prediction_arb_high_wind$pred,
                                                       predicted_CTmax_se = prediction_arb_high_wind$se))), -max_weekly_temp)

# Calculate climate vulnerability metrics
daily_vulnerability_arb_high_wind <- daily_CTmax_arb_high_wind %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

saveRDS(daily_vulnerability_arb_high_wind, file = "RData/Climate_vulnerability/Arboreal/future4C/daily_vulnerability_arboreal_high_wind_sensitivity_analysis.rds")

pop_vulnerability_arb_high_wind <- daily_vulnerability_arb_high_wind %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  ungroup() %>% 
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0)
  )  

pop_vulnerability_arb_high_wind 
```

#### **Compare the results** 
```{r, fig.height = 30, fig.width = 18}
# Plant height
plant_height <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_tall, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "darkgreen") + 
  geom_density(data = daily_vulnerability_arb_short, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "lightgreen") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

# Diffusion of solar radiation
plant_solar_rad <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_low_diff, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#cc4778") + 
  geom_density(data = daily_vulnerability_arb_mid_diff, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#7e03a8") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

# Wind reduction
plant_wind_reduc <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_no_wind, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#BA4953") + 
  geom_density(data = daily_vulnerability_arb_high_wind, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#49BAAE") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

arboreal_parameters <- plant_height / plant_solar_rad / plant_wind_reduc

arboreal_parameters

ggsave(arboreal_parameters, file = "fig/Figure_S11.png", height = 30, width=18, dpi = 500)

```

## **Validation of operative body temperature estimates** 

Here, we provide a brief validation of operative body temperatures predicted from our models. As a case in point, we compare our estimates to field body temperatures of 11 species of frogs in Mexico (taken from Lara-Resendiz & Luja, 2018, Revista Mexicana de Biodiversidad)

### **Prepare data** 
```{r}
# Get Tb measurements from the study (Table 1)
data <- data.frame(
  Species = c("Agalychnis dacnicolor", "Craugastor occidentalis", "Hyla eximia", "Incilius mazatlanensis", 
              "Leptodactylus melanonotus", "Lithobates catesbeianus", "Lithobates forreri", "Plectrohyla bistincta",
              "Smilisca baudinii", "Smilisca fodiens", "Tlalocohyla smithii"),
  Tb = c("21.7±1.97 (17.2-29.8)", "20.5±2.29 (18.2-25.8)", "22.8±1.12 (20.4-24)", "24.4±1.48 (22.5-26.6)", 
         "24.6±3.36 (21.5-33.3)", "24.8±0.88 (23.4-25.8)", "23.9±1.84 (20.9-27.7)", "22.5±3.09 (15.1-29.9)",
         "23.4±2.29 (20.8-29)", "22.7±1.07 (21.4-24)", "21.3±2.03 (14.5-25.7)")
)

# Extract the mean and range of body temperatures
data$Tb_mean <- as.numeric(sub("\\±.*", "", data$Tb))
data$Tb_range <- gsub(".*\\((.*)\\).*", "\\1", data$Tb)
range_split <- strsplit(as.character(data$Tb_range), "-")
data$Min <- sapply(range_split, function(x) as.numeric(x[1]))
data$Max <- sapply(range_split, function(x) as.numeric(x[2]))


data <- data %>% dplyr::select(Species, Mean = Tb_mean, Min, Max)

# Species at the first site
data_Tepic <- filter(data, 
                     Species == "Agalychnis dacnicolor" |
                       Species == "Hyla eximia" |
                       Species == "Incilius mazatlanensis" |
                       Species == "Leptodactylus melanonotus" | 
                       Species == "Lithobates catesbeianus" | 
                       Species == "Lithobates forreri" |
                       Species == "Smilisca baudinii" | 
                       Species == "Smilisca fodiens" | 
                       Species == "Tlalocohyla smithii") 

# Species at the second site
data_CD    <- filter(data, 
                     Species == "Craugastor occidentalis" |
                       Species == "Lithobates forreri" |
                       Species == "Plectrohyla bistincta" |
                       Species == "Smilisca baudinii" | 
                       Species == "Tlalocohyla smithii" ) 
```

*** **Compare body temperatures at the first site** 
```{r, fig.height = 10, fig.width = 10}
# Set parameters
dstart <- "01/01/2013"
dfinish <- "31/12/2015" # Wide range of dates, but will only select June to October 2013/2015
coords<- c(-104.85, 21.48) # Tepic, most sampled site

# Run the microclimate model
micro_valid <-  NicheMapR::micro_ncep(loc = coords, 
                                      dstart = dstart, 
                                      dfinish = dfinish, 
                                      scenario=0,
                                      minshade=85,
                                      maxshade=90,
                                      Usrhyt = 0.01,
                                      cap = 1,
                                      ERR = 1.5, 
                                      spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time')

micro <- micro_valid

# Find body mass of the closest location
presence <- readRDS(file = "RData/General_data/species_coordinates_adjusted.rds")
data_for_imp <- readRDS(file = "RData/General_data/pre_data_for_imputation.rds")

presence_body_mass <- merge(presence, dplyr::select(data_for_imp, tip.label,
                                                    body_mass), by = "tip.label")
median_body_mass <- presence_body_mass %>%
  dplyr::group_by(lon, lat) %>%
  dplyr::summarise(median_mass = median(body_mass, na.rm = TRUE)) %>%
  dplyr::ungroup()

median_body_mass[median_body_mass$lon == -104.5 & median_body_mass$lat == 21.5,] # 24.9 g

# Run the ectotherm model
ecto <- NicheMapR::ectotherm(live= 0, 
                             Ww_g = 24.9,  
                             shape = 4, 
                             pct_wet = 80)
environ <- as.data.frame(ecto$environ)

environ_2013 <- filter(environ, 
                      YEAR == "1" & 
                      DAY > 152 & DAY < 304) # June to October 2013
environ_2015 <- filter(environ, 
                       YEAR == "3" & 
                         DAY > 882 & DAY < 1034) # June to October 2015

stats_2013 <- environ_2013 %>%
  summarise(
    Min = min(TC, na.rm = TRUE),
    Max = max(TC, na.rm = TRUE),
    Mean = mean(TC, na.rm = TRUE)
  )

stats_2015 <- environ_2015 %>%
  summarise(
    Min = min(TC, na.rm = TRUE),
    Max = max(TC, na.rm = TRUE),
    Mean = mean(TC, na.rm = TRUE)
  )

stats_2013
stats_2015 # Virtually the same

x_limits <- c(0.99, 1.01)
set.seed(567)
Tb_jittered <- data_Tepic %>%
  mutate(x_jitter = 1 + runif(n(), -0.01, 0.01)) # Adjust the jitter range as needed


first_site <- 
ggplot() +
  # Add a "ribbon" to represent the range from Min to Max
  geom_rect(data = stats_2013, aes(xmin = x_limits[1], xmax = x_limits[2], ymin = Min, ymax = Max),
            fill = "grey80", alpha = 0.5) +
  # Add a line for the Mean
  geom_hline(data = stats_2015, aes(yintercept = Mean), color = "black", size = 1) +
  geom_pointrange(data = Tb_jittered, aes(x = x_jitter, y = Mean, ymin = Min, ymax = Max, col = Species),
                  size = 1, linewidth = 1) + 
  scale_x_continuous(name = "", labels = NULL, breaks = NULL) +  # This line is duplicated in your code; you only need it once
  theme_classic() + 
  xlab("") + 
  ylab("Temperature (°C)") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.y = element_text(size = 40, margin = margin(t = 0, r = 30, b = 0, l = 0)), 
        axis.text.y = element_text(size = 30, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        legend.text = element_text(size = 15, face = "italic"),
        legend.title = element_text(size = 18),
        panel.border = element_rect(fill = NA, size = 2))

first_site
```

*** **Compare body temperatures at the second site** 
```{r, fig.width = 10, fig.height = 10}
coords <- c(-105.03, 21.45) # El  Cuarenteño

# Run the microclimate model
micro_valid_CD <-  NicheMapR::micro_ncep(loc = coords, 
                                      dstart = dstart, 
                                      dfinish = dfinish, 
                                      scenario=0,
                                      minshade=85,
                                      maxshade=90,
                                      Usrhyt = 0.01,
                                      cap = 1,
                                      ERR = 1.5, 
                                      spatial = 'E:/p_pottier/Climatic_data/data/NCEP_time')

micro <- micro_valid_CD

# Run the ectotherm model
ecto_CD <- NicheMapR::ectotherm(live= 0, 
                             Ww_g = 24.9,  
                             shape = 4, 
                             pct_wet = 80)
environ_CD <- as.data.frame(ecto$environ)

environ_2013_CD <- filter(environ_CD, 
                       YEAR == "1" & 
                         DAY > 152 & DAY < 304) # June to October 2013
environ_2015_CD <- filter(environ, 
                       YEAR == "3" & 
                         DAY > 882 & DAY < 1034) # June to October 2015

stats_2013_CD <- environ_2013_CD %>%
  summarise(
    Min = min(TC, na.rm = TRUE),
    Max = max(TC, na.rm = TRUE),
    Mean = mean(TC, na.rm = TRUE)
  )

stats_2015_CD <- environ_2015_CD %>%
  summarise(
    Min = min(TC, na.rm = TRUE),
    Max = max(TC, na.rm = TRUE),
    Mean = mean(TC, na.rm = TRUE)
  )

stats_2013_CD
stats_2015_CD # Virtually the same


set.seed(999)
Tb_jittered_CD <- data_CD %>%
  mutate(x_jitter = 1 + runif(n(), -0.01, 0.01)) # Adjust the jitter range as needed

second_site <- 
ggplot() +
  # Add a "ribbon" to represent the range from Min to Max
  geom_rect(data = stats_2013_CD, aes(xmin = x_limits[1], xmax = x_limits[2], ymin = Min, ymax = Max),
            fill = "grey80", alpha = 0.5) +
  # Add a line for the Mean
  geom_hline(data = stats_2013_CD, aes(yintercept = Mean), color = "black", size = 1) +
  geom_pointrange(data = Tb_jittered_CD, aes(x = x_jitter, y = Mean, ymin = Min, ymax = Max, col = Species),
                  size = 1, linewidth = 1) + 
  scale_x_continuous(name = "", labels = NULL, breaks = NULL) +  # This line is duplicated in your code; you only need it once
  theme_classic() + 
  xlab("") + 
  ylab("Temperature (°C)") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.y = element_text(size = 40, margin = margin(t = 0, r = 30, b = 0, l = 0)), 
        axis.text.y = element_text(size = 30, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        legend.text = element_text(size = 15, face = "italic"),
        legend.title = element_text(size = 18),
        panel.border = element_rect(fill = NA, size = 2))

second_site
```

### **Final plot** 
```{r, fig.height = 15, fig.width = 11}
validation_OBT <- first_site / second_site

validation_OBT

ggsave(validation_OBT, file = "fig/Figure_S12.png", height = 15, width = 11, dpi = 500)
```


## **Alternative climate vulnerability metrics** {.tabset .tabset_fade .tabset_pills}

### **Acclimation to the maximum weekly temperature** 

#### **Vegetated substrate**  {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate.pbs** 

##### **Current climate** 

```{r, eval=F}

daily_CTmax_max_current <- readRDS(file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_max_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_current <- daily_CTmax_max_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_current <- daily_CTmax_max_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
          rle_run <- rle(overheating_day)
          rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })
  

rm(daily_CTmax_max_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_current <- daily_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_current <- pop_vulnerability_max_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_max_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_current)

pop_vulnerability_max_current <- pop_vulnerability_max_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_max_current  <- pop_vulnerability_max_current %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_current <- left_join(pop_vulnerability_max_current, distinct_coord, by="lon_lat")
pop_vulnerability_max_current <- pop_vulnerability_max_current %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_current <- subset(pop_vulnerability_max_current, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_current, file="RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_max_current <- pop_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_current)

saveRDS(community_vulnerability_max_current, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current.rds")

rm(community_vulnerability_max_current)

```

##### **Future climate (+2C)** 

```{r, eval = F}

daily_CTmax_max_2C <- readRDS(file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_max_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_2C <- daily_CTmax_max_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_2C <- daily_CTmax_max_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_2C <- daily_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_max_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_2C)

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_max_2C   <- pop_vulnerability_max_2C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_2C  <- left_join(pop_vulnerability_max_2C , distinct_coord, by="lon_lat")
pop_vulnerability_max_2C  <- pop_vulnerability_max_2C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_2C<- subset(pop_vulnerability_max_2C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_2C, file="RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_2C)

saveRDS(community_vulnerability_max_2C, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C.rds")

rm(community_vulnerability_max_2C)
```


##### **Future climate (+4C)** 

```{r, eval = F}

daily_CTmax_max_4C <- readRDS(file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_max_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_4C <- daily_CTmax_max_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_4C <- daily_CTmax_max_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_4C <- daily_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_max_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_4C)

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_max_4C   <- pop_vulnerability_max_4C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_4C  <- left_join(pop_vulnerability_max_4C , distinct_coord, by="lon_lat")
pop_vulnerability_max_4C  <- pop_vulnerability_max_4C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_4C <- subset(pop_vulnerability_max_4C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_4C, file="RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_4C)

saveRDS(community_vulnerability_max_4C, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C.rds")

rm(community_vulnerability_max_4C)
```


##### **Clip grid cells to match land masses** 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Clipping_grid_cells_substrate.pbs** 

```{r, eval = F}
community_df_max_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_current), function(i) {
  row <- community_df_max_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current_clipped_cells.rds")



################################# Do the same for the future climate #########################

community_df_max_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future2C), function(i) {
  row <- community_df_max_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C_clipped_cells.rds")

################

community_df_max_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future4C), function(i) {
  row <- community_df_max_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C_clipped_cells.rds")


```


#### **Pond or wetland**   {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond.R** and the resources used in **pbs/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond.pbs** 

##### **Current climate** 

```{r, eval = F}

daily_CTmax_max_current <- readRDS(file="RData/Climate_vulnerability/Pond/current/daily_CTmax_pond_max_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_current <- daily_CTmax_max_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_current <- daily_CTmax_max_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_current <- daily_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_current <- pop_vulnerability_max_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_max_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_current)

pop_vulnerability_max_current <- pop_vulnerability_max_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_max_current  <- pop_vulnerability_max_current %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_current <- left_join(pop_vulnerability_max_current, distinct_coord, by="lon_lat")
pop_vulnerability_max_current <- pop_vulnerability_max_current %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_current <- subset(pop_vulnerability_max_current, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_current, file="RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_max_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_max_current <- pop_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_current)

saveRDS(community_vulnerability_max_current, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current.rds")

rm(community_vulnerability_max_current)

```

##### **Future climate (+2C)** 

```{r, eval = F}

daily_CTmax_max_2C <- readRDS(file="RData/Climate_vulnerability/Pond/future2C/daily_CTmax_pond_max_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_2C <- daily_CTmax_max_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_2C <- daily_CTmax_max_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_2C <- daily_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_max_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_2C)

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_max_2C   <- pop_vulnerability_max_2C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_2C  <- left_join(pop_vulnerability_max_2C , distinct_coord, by="lon_lat")
pop_vulnerability_max_2C  <- pop_vulnerability_max_2C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_2C<- subset(pop_vulnerability_max_2C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_2C, file="RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_max_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_2C)

saveRDS(community_vulnerability_max_2C, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C.rds")

rm(community_vulnerability_max_2C)

```


##### **Future climate (+4C)** 

```{r, eval = F}

daily_CTmax_max_4C <- readRDS(file="RData/Climate_vulnerability/Pond/future4C/daily_CTmax_pond_max_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_4C <- daily_CTmax_max_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_4C <- daily_CTmax_max_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_4C <- daily_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_max_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_4C)

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_max_4C   <- pop_vulnerability_max_4C  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_4C  <- left_join(pop_vulnerability_max_4C , distinct_coord, by="lon_lat")
pop_vulnerability_max_4C  <- pop_vulnerability_max_4C  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_max_4C <- subset(pop_vulnerability_max_4C, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_max_4C, file="RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_max_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_4C)

saveRDS(community_vulnerability_max_4C, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C.rds")
```


##### **Clip grid cells to match land masses** 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/Clipping_grid_cells_pond.R** and the resources used in **pbs/Climate_vulnerability/Pond/Clipping_grid_cells_pond.pbs** 

```{r, eval = F}
community_df_max_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_current), function(i) {
  row <- community_df_max_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current_clipped_cells.rds")



################################# Do the same for the future climate #########################

community_df_max_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future2C), function(i) {
  row <- community_df_max_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C_clipped_cells.rds")

################

community_df_max_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future4C), function(i) {
  row <- community_df_max_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C_clipped_cells.rds")

```


#### **Above-ground vegetation**   {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal.R** and the resources used in **pbs/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal.pbs** 

##### **Current climate**

```{r, eval = F}

daily_CTmax_max_current <- readRDS(file="RData/Climate_vulnerability/Arboreal/current/daily_CTmax_arboreal_max_acc_current.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_current <- daily_CTmax_max_current %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_current <- daily_CTmax_max_current %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_current)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_current <- daily_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_current <- pop_vulnerability_max_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_max_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_current)

pop_vulnerability_max_current <- pop_vulnerability_max_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_max_current  <- pop_vulnerability_max_current %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_current <- left_join(pop_vulnerability_max_current, distinct_coord, by="lon_lat")
pop_vulnerability_max_current <- pop_vulnerability_max_current %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_max_current, file="RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")

######## Community-level patterns ################

community_vulnerability_max_current <- pop_vulnerability_max_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_current)

saveRDS(community_vulnerability_max_current, file="RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current.rds")

rm(community_vulnerability_max_current)


```

##### **Future climate (+2C)** 

```{r, eval = F}

daily_CTmax_max_2C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future2C/daily_CTmax_arboreal_max_acc_future2C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_2C <- daily_CTmax_max_2C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_2C <- daily_CTmax_max_2C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_2C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_2C <- daily_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_max_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_2C)

pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_max_2C  <- pop_vulnerability_max_2C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_2C <- left_join(pop_vulnerability_max_2C, distinct_coord, by="lon_lat")
pop_vulnerability_max_2C <- pop_vulnerability_max_2C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_max_2C, file="RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")

######## Community-level patterns ################

community_vulnerability_max_2C <- pop_vulnerability_max_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_2C)

saveRDS(community_vulnerability_max_2C, file="RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C.rds")

rm(community_vulnerability_max_2C)

```


##### **Future climate (+4C)** 

```{r, eval = F}

daily_CTmax_max_4C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future4C/daily_CTmax_arboreal_max_acc_future4C.rds")

###### Daily TSM and overheating risk ##########

daily_vulnerability_max_4C <- daily_CTmax_max_4C %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, # 95% CI
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% # 50% CI
  # Here, overheating is considered when the upper bound of the confidence interval of CTmax is below max_temp
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) 

# Number of consecutive days of overheating
daily_consecutive_max_4C <- daily_CTmax_max_4C %>%  
  mutate(overheating_day = as.integer((predicted_CTmax - max_temp) < 0),
         upper_95CI_CTmax = predicted_CTmax + 1.96 * predicted_CTmax_se, 
         upper_50CI_CTmax = predicted_CTmax + 0.6745 * predicted_CTmax_se) %>% 
  mutate(overheating_day_strict95 = as.integer((upper_95CI_CTmax - max_temp) < 0),
         overheating_day_strict50 = as.integer((upper_50CI_CTmax - max_temp) < 0)) %>% 
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })


rm(daily_CTmax_max_4C)

########## Climate vulnerability metrics at the population-level  ###########

pop_vulnerability_max_4C <- daily_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    # Sensitivity analyses accounting for uncertainty in CTmax
    overheating_days_strict95 = sum(overheating_day_strict95),
    overheating_days_strict50 = sum(overheating_day_strict50),
    overheating_risk_strict95 = as.integer(sum(overheating_day_strict95) > 0),
    overheating_risk_strict50 = as.integer(sum(overheating_day_strict50) > 0),
    .groups = 'drop'
  )

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_max_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_max_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_max_4C)

pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_max_4C  <- pop_vulnerability_max_4C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_max_4C <- left_join(pop_vulnerability_max_4C, distinct_coord, by="lon_lat")
pop_vulnerability_max_4C <- pop_vulnerability_max_4C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_max_4C, file="RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

######## Community-level patterns ################

community_vulnerability_max_4C <- pop_vulnerability_max_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Sensitivity analyses accounting for uncertainty in CTmax
    n_species_overheating_strict95 = sum(overheating_risk_strict95), 
    n_species_overheating_strict50 = sum(overheating_risk_strict50),
    proportion_species_overheating_strict95 = if_else(n() == 1, first(overheating_risk_strict95), mean(overheating_risk_strict95)),
    proportion_species_overheating_se_strict95 = if_else(n() == 1, 0, sd(overheating_risk_strict95)),
    proportion_species_overheating_strict50 = if_else(n() == 1, first(overheating_risk_strict50), mean(overheating_risk_strict50)),
    proportion_species_overheating_se_strict50 = if_else(n() == 1, 0, sd(overheating_risk_strict50)),
    .groups = 'drop'
  )

rm(pop_vulnerability_max_4C)

saveRDS(community_vulnerability_max_4C, file="RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C.rds")

```


##### **Clip grid cells to match land masses** 

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/Clipping_grid_cells_arboreal.R** and the resources used in **pbs/Climate_vulnerability/Arboreal/Clipping_grid_cells_arboreal.pbs** 

```{r, eval = F}

community_df_max_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_current), function(i) {
  row <- community_df_max_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current_clipped_cells.rds")



################################# Do the same for the future climate #########################

community_df_max_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future2C), function(i) {
  row <- community_df_max_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C_clipped_cells.rds")

################

community_df_max_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future4C), function(i) {
  row <- community_df_max_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C_clipped_cells.rds")

```

### **Removing outliers or not taking averages for TSM** 

Here, we either remove body temperatures falling outside the 5% and 95% percentiles (i.e., potential outlier values), and also calculate the maximum operative body temperature predicted across all dates for sensitivity analyses.

#### **Vegetated substrate**  {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate_sensitivity_analysis.R** and the resources used in **pbs/Climate_vulnerability/Substrate/Calculating_climate_vulnerability_metrics_substrate_sensitivity_analysis.pbs** 

##### **Current climate** 

```{r, eval=F}

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_mean_acc_current.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_current_sens <- daily_CTmax_mean_current %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_current_sens <- daily_CTmax_mean_current %>%
  inner_join(daily_percentiles_mean_current_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_current_sens <- daily_filtered_mean_current_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_current_sens <- daily_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_current_sens <- daily_filtered_mean_current_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_current_sens_95 <- pop_data_95_mean_current_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_current_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_current_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_current_sens <- daily_CTmax_mean_current  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_current_sens <- pop_data_extreme_mean_current_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_current_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_current_sens   <- pop_vulnerability_mean_current_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current_sens  <- left_join(pop_vulnerability_mean_current_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_current_sens  <- pop_vulnerability_mean_current_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_current_sens <- subset(pop_vulnerability_mean_current_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")

```

##### **Future climate (+2C)** 

```{r, eval=F}

daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_mean_acc_future2C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_2C_sens <- daily_CTmax_mean_2C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_2C_sens <- daily_CTmax_mean_2C %>%
  inner_join(daily_percentiles_mean_2C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_2C_sens <- daily_filtered_mean_2C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_2C_sens <- daily_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_2C_sens <- daily_filtered_mean_2C_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_2C_sens_95 <- pop_data_95_mean_2C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_2C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_2C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_2C_sens <- daily_CTmax_mean_2C  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_2C_sens <- pop_data_extreme_mean_2C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_2C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_2C_sens   <- pop_vulnerability_mean_2C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C_sens  <- left_join(pop_vulnerability_mean_2C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C_sens  <- pop_vulnerability_mean_2C_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_2C_sens <- subset(pop_vulnerability_mean_2C_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")

```

##### **Future climate (+4C)** 

```{r, eval=F}

daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_mean_acc_future4C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_4C_sens <- daily_CTmax_mean_4C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_4C_sens <- daily_CTmax_mean_4C %>%
  inner_join(daily_percentiles_mean_4C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_4C_sens <- daily_filtered_mean_4C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_4C_sens <- daily_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_4C_sens <- daily_filtered_mean_4C_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_4C_sens_95 <- pop_data_95_mean_4C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_4C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_4C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_4C_sens <- daily_CTmax_mean_4C  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_4C_sens <- pop_data_extreme_mean_4C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_4C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_4C_sens   <- pop_vulnerability_mean_4C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C_sens  <- left_join(pop_vulnerability_mean_4C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C_sens  <- pop_vulnerability_mean_4C_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_4C_sens <- subset(pop_vulnerability_mean_4C_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_4C_sens, file="RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

```


#### **Pond or wetland**  {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond_sensitivity_analysis.R** and the resources used in **pbs/Climate_vulnerability/Pond/Calculating_climate_vulnerability_metrics_pond_sensitivity_analysis.pbs** 

##### **Current climate** 

```{r, eval=F}

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Pond/current/daily_CTmax_pond_mean_acc_current.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_current_sens <- daily_CTmax_mean_current %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_current_sens <- daily_CTmax_mean_current %>%
  inner_join(daily_percentiles_mean_current_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_current_sens <- daily_filtered_mean_current_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_current_sens <- daily_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_current_sens <- daily_filtered_mean_current_sens %>%
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_current_sens_95 <- pop_data_95_mean_current_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_current_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_current_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_current_sens <- daily_CTmax_mean_current  %>%
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_current_sens <- pop_data_extreme_mean_current_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_current_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_current_sens   <- pop_vulnerability_mean_current_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current_sens  <- left_join(pop_vulnerability_mean_current_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_current_sens  <- pop_vulnerability_mean_current_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_current_sens <- subset(pop_vulnerability_mean_current_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")


```

##### **Future climate (+2C)** 

```{r, eval=F}

daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Pond/future2C/daily_CTmax_pond_mean_acc_future2C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_2C_sens <- daily_CTmax_mean_2C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_2C_sens <- daily_CTmax_mean_2C %>%
  inner_join(daily_percentiles_mean_2C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_2C_sens <- daily_filtered_mean_2C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_2C_sens <- daily_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_2C_sens <- daily_filtered_mean_2C_sens %>%
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_2C_sens_95 <- pop_data_95_mean_2C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_2C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_2C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_2C_sens <- daily_CTmax_mean_2C  %>% 
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_2C_sens <- pop_data_extreme_mean_2C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_2C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_2C_sens   <- pop_vulnerability_mean_2C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C_sens  <- left_join(pop_vulnerability_mean_2C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C_sens  <- pop_vulnerability_mean_2C_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_2C_sens <- subset(pop_vulnerability_mean_2C_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")

```

##### **Future climate (+4C)** 

```{r, eval=F}

daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Pond/future4C/daily_CTmax_pond_mean_acc_future4C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_4C_sens <- daily_CTmax_mean_4C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_4C_sens <- daily_CTmax_mean_4C %>%
  inner_join(daily_percentiles_mean_4C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_4C_sens <- daily_filtered_mean_4C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_4C_sens <- daily_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_4C_sens <- daily_filtered_mean_4C_sens %>%
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_4C_sens_95 <- pop_data_95_mean_4C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_4C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_4C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_4C_sens <- daily_CTmax_mean_4C  %>% 
  group_by(tip.label, lon, lat) %>%
  arrange(desc(max_temp), desc(predicted_CTmax)) %>%  # Sort by max_temp and then by CTmax
  slice_head(n = 1) %>%  # Keep values corresponding to the highest max_temp
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_4C_sens <- pop_data_extreme_mean_4C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_4C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_4C_sens   <- pop_vulnerability_mean_4C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C_sens  <- left_join(pop_vulnerability_mean_4C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C_sens  <- pop_vulnerability_mean_4C_sens  %>% 
  dplyr::select(-lon_lat)

# Remove data from one coordinate because it is not in the TerraClimate database and can't be compared to future climate scenario
pop_vulnerability_mean_4C_sens <- subset(pop_vulnerability_mean_4C_sens, !(lon_adj == -5.7 & lat_adj == -15.95))

saveRDS(pop_vulnerability_mean_4C_sens, file="RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")

```

#### **Above-ground vegetation**  {.tabset .tabset_fade .tabset_pills}

This code ran on an HPC environment, where the original code can be found in **R/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal_sensitivity_analysis.R** and the resources used in **pbs/Climate_vulnerability/Arboreal/Calculating_climate_vulnerability_metrics_arboreal_sensitivity_analysis.pbs** 

##### **Current climate** 

```{r, eval=F}

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Arboreal/current/daily_CTmax_arboreal_mean_acc_current.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_current_sens <- daily_CTmax_mean_current %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_current_sens <- daily_CTmax_mean_current %>%
  inner_join(daily_percentiles_mean_current_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_current_sens <- daily_filtered_mean_current_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_current_sens <- daily_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_current_sens <- daily_filtered_mean_current_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_current_sens_95 <- pop_data_95_mean_current_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_current_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_current_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_current_sens <- daily_CTmax_mean_current  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_current_sens <- pop_data_extreme_mean_current_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))
  
  # Join datasets
  pop_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_current_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_current_sens   <- pop_vulnerability_mean_current_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current_sens  <- left_join(pop_vulnerability_mean_current_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_current_sens  <- pop_vulnerability_mean_current_sens  %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_current_sens <- pop_vulnerability_mean_current_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_current_sens, file="RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")

```

##### **Future climate (+2C)** 

```{r, eval=F}

daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future2C/daily_CTmax_arboreal_mean_acc_future2C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_2C_sens <- daily_CTmax_mean_2C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_2C_sens <- daily_CTmax_mean_2C %>%
  inner_join(daily_percentiles_mean_2C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_2C_sens <- daily_filtered_mean_2C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_2C_sens <- daily_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_2C_sens <- daily_filtered_mean_2C_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_2C_sens_95 <- pop_data_95_mean_2C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_2C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_2C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_2C_sens <- daily_CTmax_mean_2C  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_2C_sens <- pop_data_extreme_mean_2C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_2C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_2C_sens   <- pop_vulnerability_mean_2C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C_sens  <- left_join(pop_vulnerability_mean_2C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C_sens  <- pop_vulnerability_mean_2C_sens  %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C_sens <- pop_vulnerability_mean_2C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")

```

##### **Future climate (+4C)** 

```{r, eval=F}

daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Arboreal/future4C/daily_CTmax_arboreal_mean_acc_future4C.rds")

# Calculate 5% and 95% percentile for each group
daily_percentiles_mean_4C_sens <- daily_CTmax_mean_4C %>%
  group_by(tip.label, lon, lat) %>%
  summarise(p5_max_temp = quantile(max_temp, 0.05),
            p95_max_temp = quantile(max_temp, 0.95))

# Filter data within 5% to 95% percentile range
daily_filtered_mean_4C_sens <- daily_CTmax_mean_4C %>%
  inner_join(daily_percentiles_mean_4C_sens, by = c("tip.label", "lon", "lat")) %>%
  filter(max_temp >= p5_max_temp & max_temp <= p95_max_temp)

# Daily TSM and overheating risk 
daily_vulnerability_mean_4C_sens <- daily_filtered_mean_4C_sens %>% 
  mutate(daily_TSM = predicted_CTmax - max_temp,
         daily_TSM_se = predicted_CTmax_se,
         overheating_day = as.integer((predicted_CTmax - max_temp) < 0))

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_4C_sens <- daily_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Number of overheating days and overheating risk
    overheating_days = sum(overheating_day),
    overheating_risk = as.integer(sum(overheating_day) > 0),
    .groups = 'drop'
  )

pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>% rename(max_temp = mean_max_temp)

# Create a dataframe with only the 95th percentile of max_temp for each population
pop_data_95_mean_4C_sens <- daily_filtered_mean_4C_sens %>%
  group_by(tip.label, lon, lat) %>%
  slice_max(order_by = max_temp, n = 1) %>% 
  ungroup()

# Calculate TSM as the difference with the 95th percentile maximum temperature 
pop_vulnerability_mean_4C_sens_95 <- pop_data_95_mean_4C_sens %>% 
  mutate(TSM_95 = predicted_CTmax - max_temp,
         TSM_95_se = predicted_CTmax_se,
         CTmax_95 = predicted_CTmax,
         CTmax_95_se = predicted_CTmax_se,
         max_temp_95 = max_temp,
         overheating_risk_95 = as.integer((predicted_CTmax - max_temp) < 0)) 


# Combine data frames
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_mean_4C_sens_95,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_95, 
                          TSM_95_se, 
                          CTmax_95, 
                          CTmax_95_se, 
                          max_temp_95,
                          overheating_risk_95), 
            by = c("tip.label", "lon", "lat"))

rm(pop_vulnerability_mean_4C_sens_95)

# Create a dataframe with only the max_temp for each population (minimum TSM)
pop_data_extreme_mean_4C_sens <- daily_CTmax_mean_4C  %>% 
  group_by(tip.label, lon, lat) %>%
  filter(max_temp == max(max_temp)) %>% 
  ungroup()

# Calculate TSM as the difference with the maximum temperature (most extreme TSM)
pop_vulnerability_extreme_mean_4C_sens <- pop_data_extreme_mean_4C_sens %>% 
  mutate(TSM_extreme = predicted_CTmax - max_temp,
         TSM_extreme_se = predicted_CTmax_se,
         CTmax_extreme = predicted_CTmax,
         CTmax_extreme_se = predicted_CTmax_se,
         max_temp_extreme = max_temp,
         overheating_risk_extreme = as.integer((predicted_CTmax - max_temp) < 0))

# Join datasets
pop_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  left_join(dplyr::select(pop_vulnerability_extreme_mean_4C_sens,
                          tip.label, 
                          lon, 
                          lat, 
                          TSM_extreme, 
                          TSM_extreme_se, 
                          CTmax_extreme, 
                          CTmax_extreme_se, 
                          max_temp_extreme,
                          overheating_risk_extreme), 
            by = c("tip.label", "lon", "lat"))

## Add original coordinates
pop_vulnerability_mean_4C_sens   <- pop_vulnerability_mean_4C_sens  %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted_arboreal.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C_sens  <- left_join(pop_vulnerability_mean_4C_sens , distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C_sens  <- pop_vulnerability_mean_4C_sens  %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_4C_sens, file="RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C_sens <- pop_vulnerability_mean_4C_sens %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2),
         TSM_extreme_weights = 1/(TSM_extreme_se^2),
         TSM_95_weights = 1/(TSM_95_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp), 
    community_max_temp_se = first(max_temp_se),
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # TSM calculated as the difference with the maximum body temperature 
    community_TSM_extreme = if_else(n() == 1, first(TSM_extreme), sum(TSM_extreme * TSM_extreme_weights)/sum(TSM_extreme_weights)), 
    community_TSM_extreme_se = if_else(n() == 1, first(TSM_extreme_se), sqrt(sum(TSM_extreme_weights) * (n() - 1) / (((sum(TSM_extreme_weights)^2) - (sum(TSM_extreme_weights^2)))))),
    # TSM calculated as the difference with the 95th percentile body temperature 
    community_TSM_95 = if_else(n() == 1, first(TSM_95), sum(TSM_95 * TSM_95_weights)/sum(TSM_95_weights)), 
    community_TSM_95_se = if_else(n() == 1, first(TSM_95_se), sqrt(sum(TSM_95_weights) * (n() - 1) / (((sum(TSM_95_weights)^2) - (sum(TSM_95_weights^2)))))),
    .groups = 'drop'
  )

saveRDS(community_vulnerability_mean_2C_sens, file="RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

```

## **Thermal safety margin** {.tabset .tabset_fade .tabset_pills}

Only the code and outputs of population-level models are presented here. Community-level models were also fitted, and the outputs can be found in the **RData/Models/TSM/sensitivity_analyses/** folder.

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_max_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_max_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_max_acc_future4C.rds")


# Function to run population-level TSM models in parallel 
run_TSM_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(TSM ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$TSM_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    TSM = NA, 
    TSM_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_", habitat_scenario, "_max_acc.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future4C_max_acc.rds"))
```


###### **Pond or wetland** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future4C_max_acc.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future4C_max_acc.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label 

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(TSM ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(TSM_se):units, # Genus, species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_max_acc.rds")
saveRDS(predictions, file = "RData/Models/TSM/sensitivity_analyses/predictions_MCMCglmm_TSM_max_acc.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(TSM ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(TSM_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_max_acc.rds")
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_TSM <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_max_acc.rds")
summary(model_MCMC_TSM)
```

###### **Contrasts** 

```{r}
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_max_acc.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_TSM)
```

### **Not averaging TSM (maximum temperature)** 

Here, we calculated TSM as the difference between the maximum hourly body temperature experienced and the corresponding CTmax. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_no_averaging_max_temp.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_no_averaging_max_temp.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")


# Function to run population-level TSM models in parallel with the maximum hourly body temperature (TSM_extreme)
run_TSM_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(TSM_extreme ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$TSM_extreme_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    TSM_extreme = NA, 
    TSM_extreme_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_", habitat_scenario, "_max_temp.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_", habitat_scenario, "_max_temp.rds"))
  saveRDS(new_data, file = paste0("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_", habitat_scenario, "_max_temp.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

options(future.globals.maxSize = 99999999999999999999999999)

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_current_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_current_max_temp.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future2C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future2C_max_temp.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future4C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future4C_max_temp.rds"))
```

###### **Pond or wetland** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_current_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_current_max_temp.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future2C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future2C_max_temp.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future4C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future4C_max_temp.rds"))
```

###### **Above-ground vegetation** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_current_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_current_max_temp.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future2C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future2C_max_temp.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future4C_max_temp.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future4C_max_temp.rds"))
```



#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label 

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(TSM_extreme ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(TSM_extreme_se):units, # Genus, species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_max_temp.rds")
saveRDS(predictions, file = "RData/Models/TSM/sensitivity_analyses/predictions_MCMCglmm_TSM_max_temp.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(TSM_extreme ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(TSM_extreme_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_max_temp.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_TSM <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_max_temp.rds")
summary(model_MCMC_TSM)
```

###### **Contrasts** 

```{r}
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_max_temp.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_TSM)
```


### **Not averaging TSM (95th percentile temperature)** 

Here, we calculated TSM as the difference between the 95th percentile hourly body temperature experienced and the corresponding CTmax. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_no_averaging_95th_percentile.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_no_averaging_95th_percentile.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
## Here, we will calculate TSM based on the difference between the 95th percentile hourly operative body temperature and the predicted CTmax at this time point
## This is to contrast with the use of average values (mean maximum temperature of the warmest quarter).

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")


# Function to run population-level TSM models in parallel with the maximum hourly body temperature (TSM_95)
run_TSM_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(TSM_95 ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$TSM_95_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    TSM_95 = NA, 
    TSM_95_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_", habitat_scenario, "_95th_percentile.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_", habitat_scenario, "_95th_percentile.rds"))
  saveRDS(new_data, file = paste0("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_", habitat_scenario, "_95th_percentile.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

options(future.globals.maxSize = 99999999999999999999999999)

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_current_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_current_95th_percentile.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future2C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future2C_95th_percentile.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future4C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future4C_95th_percentile.rds"))
```

###### **Pond or wetland** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_current_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_current_95th_percentile.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future2C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future2C_95th_percentile.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future4C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future4C_95th_percentile.rds"))
```

###### **Above-ground vegetation** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_current_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_current_95th_percentile.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future2C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future2C_95th_percentile.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future4C_95th_percentile.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future4C_95th_percentile.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label 

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(TSM_95 ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(TSM_95_se):units, # Genus, species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_95th_percentile.rds")
saveRDS(predictions, file = "RData/Models/TSM/sensitivity_analyses/predictions_MCMCglmm_TSM_95th_percentile.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(TSM_95 ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(TSM_95_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_95th_percentile.rds")


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_TSM <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_95th_percentile.rds")
summary(model_MCMC_TSM)
```

###### **Contrasts** 

```{r}
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_95th_percentile.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_TSM)
```


### **Without outliers** 

Here, we excluded that fell below the 5th percentile or above the 95th percentile maximum operative body temperature for each population. While these may not be true outlier values, this is equivalent to analyses performed in previous studies (e.g., Pinky et al., 2019. Nature)

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_outliers.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_TSM_sensitivity_analysis_outliers.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
## These datasets are excluding "outlier" values, i.e., values that are below the 5th and above the 95th percentile operative body temperature for each population. 
## These analyses were performed to echo previous work trimming outlier values (e.g., Pinsky et al., 2019. Nature)

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")


# Function to run population-level TSM models in parallel 
run_TSM_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(TSM ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$TSM_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    TSM = NA, 
    TSM_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$TSM_pred <- pred$fit
  new_data$TSM_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = TSM_pred + 1.96 * TSM_pred_se,
                     lower = TSM_pred - 1.96 * TSM_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(new_data, file = paste0("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_", habitat_scenario, "_without_outliers.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

options(future.globals.maxSize = 99999999999999999999999999)

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_TSM_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_substrate_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_substrate_future4C_without_outliers.rds"))
```

###### **Pond or wetland** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_pond_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_pond_future4C_without_outliers.rds"))
```

###### **Above-ground vegetation** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_MER_pop_lat_TSM_arboreal_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/TSM/sensitivity_analyses/summary_GAM_pop_lat_TSM_arboreal_future4C_without_outliers.rds"))
```

#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label 

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(TSM ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(TSM_se):units, # Genus, species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_without_outliers.rds")
saveRDS(new_data, file = "RData/Models/TSM/sensitivity_analyses/predictions_MCMCglmm_TSM_without_outliers.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(TSM ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(TSM_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_without_outliers.rds")


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_TSM <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_without_outliers.rds")
summary(model_MCMC_TSM)
```

###### **Contrasts** 

```{r}
model_MCMC_TSM_contrast <- readRDS("RData/Models/TSM/sensitivity_analyses/model_MCMCglmm_TSM_contrast_without_outliers.rds")
summary(model_MCMC_TSM_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_TSM)
```


## **CTmax** {.tabset .tabset_fade .tabset_pills}

Only the code and outputs of population-level models are presented here. Community-level models were also fitted, and the outputs can be found in the **RData/Models/CTmax/sensitivity_analyses/** folder. 

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_CTmax_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_CTmax_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}

# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_max_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_max_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_max_acc_future4C.rds")


# Function to run population-level CTmax models in parallel 
run_CTmax_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(CTmax ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$CTmax_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    CTmax = NA, 
    CTmax_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$CTmax_pred <- pred$fit
  new_data$CTmax_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = CTmax_pred + 1.96 * CTmax_pred_se,
                     lower = CTmax_pred - 1.96 * CTmax_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/CTmax/sensitivity_analyses/predictions_pop_lat_CTmax_", habitat_scenario, "_max_acc.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_CTmax_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_future4C_max_acc.rds"))
```


###### **Pond or wetland** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_future4C_max_acc.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_future4C_max_acc.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
# Had to remove phylogenetic effects and weights because this model failed to estimate variance components. Only a nested genus/species structure was kept.
model_MCMC <- MCMCglmm(CTmax ~ habitat_scenario - 1, # No intercept
                       random = ~ species + genus:species, 
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_max_acc.rds")
saveRDS(predictions, file = "RData/Models/CTmax/sensitivity_analyses/predictions_MCMCglmm_CTmax_max_acc.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

# Had to remove phylogenetic effects and weights because this model failed to estimate variance components. Only a nested genus/species structure was kept.
model_MCMC_contrast <- MCMCglmm(CTmax ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ genus + genus:species,
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_contrast_max_acc.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_max_acc.rds")
summary(model_MCMC_CTmax)
```

###### **Contrasts** 

```{r}
model_MCMC_CTmax_contrast <- readRDS("RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_contrast_max_acc.rds")
summary(model_MCMC_CTmax_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_CTmax)
```

### **Without outliers** 

Here, we excluded that fell below the 5th percentile or above the 95th percentile maximum operative body temperature for each population. While these may not be true outlier values, this is equivalent to analyses performed in previous studies (e.g., Pinky et al., 2019. Nature)

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_CTmax_sensitivity_analysis_outliers.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_CTmax_sensitivity_analysis_outliers.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")


# Function to run population-level CTmax models in parallel 
run_CTmax_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(CTmax ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$CTmax_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    CTmax = NA, 
    CTmax_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$CTmax_pred <- pred$fit
  new_data$CTmax_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = CTmax_pred + 1.96 * CTmax_pred_se,
                     lower = CTmax_pred - 1.96 * CTmax_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(new_data, file = paste0("RData/Models/CTmax/sensitivity_analyses/predictions_pop_lat_CTmax_", habitat_scenario, "_without_outliers.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

options(future.globals.maxSize = 99999999999999999999999999)

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_CTmax_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_substrate_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_substrate_future4C_without_outliers.rds"))
```


###### **Pond or wetland** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_pond_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_pond_future4C_without_outliers.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_MER_pop_lat_CTmax_arboreal_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/CTmax/sensitivity_analyses/summary_GAM_pop_lat_CTmax_arboreal_future4C_without_outliers.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(CTmax ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(CTmax_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_without_outliers.rds")
saveRDS(predictions, file = "RData/Models/CTmax/sensitivity_analyses/predictions_MCMCglmm_CTmax_without_outliers.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

# Had to remove phylogenetic effects and weights because this model failed to estimate variance components. Only a nested genus/species structure was kept.

prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000))) 

model_MCMC_contrast <- MCMCglmm(CTmax ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ genus + genus:species,
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_contrast_without_outliers.rds")
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_CTmax <- readRDS("RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_without_outliers.rds")
summary(model_MCMC_CTmax)
```

###### **Contrasts** 

```{r}
model_MCMC_CTmax_contrast <- readRDS("RData/Models/CTmax/sensitivity_analyses/model_MCMCglmm_CTmax_contrast_without_outliers.rds")
summary(model_MCMC_CTmax_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_CTmax)
```


## **Maximum operative body temperature** {.tabset .tabset_fade .tabset_pills}


Only the code and outputs of population-level models are presented here. Community-level models were also fitted, and the outputs can be found in the **RData/Models/max_temp/sensitivity_analyses/** folder. 

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_max_temp_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_max_temp_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_max_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_max_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_max_acc_future4C.rds")


# Function to run population-level max_temp models in parallel 
run_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(max_temp ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    max_temp = NA, 
    max_temp_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/max_temp/sensitivity_analyses/predictions_pop_lat_max_temp_", habitat_scenario, "_max_acc.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_future4C_max_acc.rds"))
```


###### **Pond or wetland** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_future4C_max_acc.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_future4C_max_acc.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

plan(sequential) 

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(max_temp ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(max_temp_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_max_acc.rds")
saveRDS(predictions, file = "RData/Models/max_temp/sensitivity_analyses/predictions_MCMCglmm_max_temp_max_acc.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(max_temp_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_contrast_max_acc.rds")

```

###### **Overall means** 

```{r}
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_max_acc.rds")
summary(model_MCMC_max_temp)
```

##### **Contrasts** 

```{r}
model_MCMC_max_temp_contrast <- readRDS("RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_contrast_max_acc.rds")
summary(model_MCMC_max_temp_contrast)
```

##### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_max_temp)
```


### **Without outliers** 

Here, we excluded that fell below the 5th percentile or above the 95th percentile maximum operative body temperature for each population. While these may not be true outlier values, this is equivalent to analyses performed in previous studies (e.g., Pinky et al., 2019. Nature)

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_max_temp_sensitivity_analysis_outliers.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_max_temp_sensitivity_analysis_outliers.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_sensitivity_analysis.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_sensitivity_analysis.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current_sensitivity_analysis.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C_sensitivity_analysis.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C_sensitivity_analysis.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current_sensitivity_analysis.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C_sensitivity_analysis.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C_sensitivity_analysis.rds")


# Function to run population-level max_temp models in parallel 
run_max_temp_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(max_temp ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        weights = 1/(data$max_temp_se^2),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    max_temp = NA, 
    max_temp_se = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$max_temp_pred <- pred$fit
  new_data$max_temp_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = max_temp_pred + 1.96 * max_temp_pred_se,
                     lower = max_temp_pred - 1.96 * max_temp_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model summaries and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_", habitat_scenario, "_without_outliers.rds"))
  saveRDS(new_data, file = paste0("RData/Models/max_temp/sensitivity_analyses/predictions_pop_lat_max_temp_", habitat_scenario, "_without_outliers.rds"))
}

# Create a list of datasets
dataset_list <- list(
  pond_current = pop_pond_current,
  pond_future2C = pop_pond_future2C,
  pond_future4C = pop_pond_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C,
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C
) 

# Set up parallel processing
plan(multicore(workers=2)) 

options(future.globals.maxSize = 99999999999999999999999999)

# Run function
results_pop<- future_lapply(
  names(dataset_list), 
  function(x) {run_max_temp_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_substrate_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_substrate_future4C_without_outliers.rds"))
```


###### **Pond or wetland** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_pond_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_pond_future4C_without_outliers.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_current_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_current_without_outliers.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_future2C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_future2C_without_outliers.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_MER_pop_lat_max_temp_arboreal_future4C_without_outliers.rds"))

# Generalized additive model
print(readRDS("RData/Models/max_temp/sensitivity_analyses/summary_GAM_pop_lat_max_temp_arboreal_future4C_without_outliers.rds"))
```


#### **Bayesian linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C"), 
  pop_pond_current %>% mutate(habitat_scenario = "pond_current"), 
  pop_pond_future2C %>% mutate(habitat_scenario = "pond_future2C"), 
  pop_pond_future4C %>% mutate(habitat_scenario = "pond_future4C")
)


all_data$species <- all_data$tip.label

# Match phylogeny to dataset
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

tree <- drop.tip(tree, tree$tip.label[-match(all_data$tip.label, tree$tip.label)])  

tree <- force.ultrametric(tree, method="extend") # Force the tree to be ultrametric

Ainv<-inverseA(tree)$Ainv
all_data <- as.data.frame(all_data)

plan(sequential) 

# Run models with MCMCglmm 
prior  <- list(R = list(V = 1, nu = 0.002), 
               G = list(G1 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G2 = list(V = 1, nu = 0.002, 
                                  alpha.mu = 0, 
                                  alpha.V = 1000),
                        G3 = list(V = 1, fix = 1)))

set.seed(123)

# Intercept-less model, variation between microhabitat and climate scenarios
model_MCMC <- MCMCglmm(max_temp ~ habitat_scenario - 1, # No intercept
                       random = ~ species + tip.label + idh(max_temp_se):units, # Species, phylogenetic relatedness, and weights
                       ginverse=list(tip.label = Ainv),
                       singular.ok=TRUE,
                       prior = prior,
                       verbose=FALSE,
                       data = all_data)

# Get predictions
predictions <- data.frame(emmeans(model_MCMC, 
                                  by="habitat_scenario", 
                                  specs="habitat_scenario", 
                                  data=all_data, 
                                  type="response"))

predictions <- predictions %>% rename(prediction = emmean)

# Save model summaries and predictions
saveRDS(model_MCMC, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_without_outliers.rds")
saveRDS(predictions, file = "RData/Models/max_temp/sensitivity_analyses/predictions_MCMCglmm_max_temp_without_outliers.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_MCMC_contrast <- MCMCglmm(max_temp ~ relevel(habitat_scenario, ref = "substrate_current"), # substrate_current as the reference level
                                random = ~ species + tip.label + idh(max_temp_se):units, 
                                ginverse=list(tip.label = Ainv),
                                singular.ok=TRUE,
                                prior = prior,
                                verbose=FALSE,
                                data = all_data)

saveRDS(model_MCMC_contrast, file = "RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_contrast_without_outliers.rds")
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_MCMC_max_temp <- readRDS("RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_without_outliers.rds")
summary(model_MCMC_max_temp)
```

###### **Contrasts** 

```{r}
model_MCMC_max_temp_contrast <- readRDS("RData/Models/max_temp/sensitivity_analyses/model_MCMCglmm_max_temp_contrast_without_outliers.rds")
summary(model_MCMC_max_temp_contrast)
```

###### **Model diagnostics** 

```{r, fig.width = 12, fig.height = 12}
plot(model_MCMC_max_temp)
```


## **Overheating risk** {.tabset .tabset_fade .tabset_pills}

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## We do not load pond data because none of the species overheat in water bodies

# Function to run population-level overheating_risk models in parallel 
run_overheating_risk_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(overheating_risk ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_risk = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/predictions_pop_lat_overheating_risk_", habitat_scenario, "_max_acc.rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)


# Set up parallel processing
plan(multicore(workers=2))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_risk_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_substrate_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_substrate_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_substrate_future4C_max_acc.rds"))
```


###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_arboreal_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_arboreal_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_pop_lat_overheating_risk_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_pop_lat_overheating_risk_arboreal_future4C_max_acc.rds"))
```


#### **Linear mixed models** 

```{r, eval = F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
model_risk <-  glmer(overheating_risk ~ habitat_scenario - 1 + (1|genus/species), 
                     family = "binomial",
                     control = glmerControl(optimizer ='optimx', 
                                            optCtrl=list(method='nlminb')),
                     data = all_data)

# Get predictions
predictions <- as.data.frame(ggpredict(model_risk, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)
# Save model and predictions
saveRDS(model_risk, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_max_acc.rds")
saveRDS(predictions, file = "RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_max_acc.rds")

# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_risk_contrast <-  glmer(overheating_risk ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                              family = "binomial",
                              control = glmerControl(optimizer ='optimx', 
                                                     optCtrl=list(method='nlminb')),
                              data = all_data)


saveRDS(model_risk_contrast, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_max_acc.rds")
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_risk <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_max_acc.rds")
summary(model_overheating_risk)

# Predictions
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_max_acc.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_risk_contrast <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_max_acc.rds")
summary(model_overheating_risk_contrast)
```

### **Temperatures exceeded 50% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 50% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## We do not load pond data because none of the species overheat in water bodies


####################### Sensitivity analyses #############################

# Here we only consider overheating events when maximum temperatures exceed 50% of the predicted distribution of CTmax

# Function to run population-level overheating_risk models in parallel (sensitivity analysis, 50%)
run_overheating_risk_analysis_strict50 <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(overheating_risk_strict50 ~ s(lat, bs = "tp"), 
                        random = ~  (1 | genus/species),
                        data = data,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_risk_strict50 = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/predictions_pop_lat_overheating_risk_strict50_", habitat_scenario, ".rds"))
}

# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)

plan(sequential)

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_risk_analysis_strict50(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_substrate_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_substrate_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_substrate_future4C.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_arboreal_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_arboreal_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict50_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict50_arboreal_future4C.rds"))
```

#### **Linear mixed models**

```{r, eval = F}

all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)


# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
model_risk_strict50 <-  glmer(overheating_risk_strict50 ~ habitat_scenario - 1 + (1|genus/species), 
                              family = "binomial",
                              control = glmerControl(optimizer ='optimx', 
                                                     optCtrl=list(method='nlminb')),
                               data = all_data)

# Get predictions
predictions <- as.data.frame(ggpredict(model_risk_strict50, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model and predictions
saveRDS(model_risk_strict50, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_strict50.rds")
saveRDS(predictions, file = "RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_strict50.rds")


# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_risk_strict50_contrast <-  glmer(overheating_risk_strict50 ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                                       family = "binomial",
                                       control = glmerControl(optimizer ='optimx', 
                                                              optCtrl=list(method='nlminb')),
                                       data = all_data)


# Save model 
saveRDS(model_risk_strict50_contrast, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_strict50.rds")
```


##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_risk <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_strict50.rds")
summary(model_overheating_risk)

# Predictions
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_strict50.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_risk_contrast <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_strict50.rds")
summary(model_overheating_risk_contrast)
```

### **Temperatures exceeded 95% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 95% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_risk_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Function to run population-level overheating_risk models in parallel (sensitivity analysis, 95%)
run_overheating_risk_analysis_strict95 <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(overheating_risk_strict95 ~ s(lat, bs = "tp"), 
                        random = ~  (1 | genus/species),
                        data = data,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_risk_strict95 = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_risk/sensitivity_analyses/predictions_pop_lat_overheating_risk_strict95_", habitat_scenario, ".rds"))
}


# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_risk_analysis_strict95(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_substrate_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_substrate_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_substrate_future4C.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_arboreal_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_arboreal_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_MER_lat_overheating_risk_strict95_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/summary_GAM_lat_overheating_risk_strict95_arboreal_future4C.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
# Run model
model_risk_strict95 <-  glmer(overheating_risk_strict95 ~ habitat_scenario - 1 + (1|genus/species), 
                              family = "binomial",
                              control = glmerControl(optimizer ='optimx', 
                                                     optCtrl=list(method='nlminb')),
                              data = all_data)

# Get predictions
predictions <- as.data.frame(ggpredict(model_risk_strict95, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model 
saveRDS(model_risk_strict95, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_strict95.rds")
saveRDS(predictions, file = "RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_strict95.rds")

# Contrasts
model_risk_strict95_contrast <-  glmer(overheating_risk_strict95 ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                                       family = "binomial",
                                       control = glmerControl(optimizer ='optimx', 
                                                              optCtrl=list(method='nlminb')),
                                       data = all_data)

# Save model 
saveRDS(model_risk_strict95_contrast, file = "RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_strict95.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_risk <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_strict95.rds")
summary(model_overheating_risk)

# Predictions
print(readRDS("RData/Models/overheating_risk/sensitivity_analyses/predictions_lme4_overheating_risk_strict95.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_risk_contrast <- readRDS("RData/Models/overheating_risk/sensitivity_analyses/model_lme4_overheating_risk_contrast_strict95.rds")
summary(model_overheating_risk_contrast)
```


## **Overheating days** {.tabset .tabset_fade .tabset_pills}

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")

## We do not load pond data because none of the species overheat in water bodies

# Function to run population-level overheating_days models in parallel 
run_overheating_days_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(overheating_days ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_days = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_days_pred <- pred$fit
  new_data$overheating_days_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_days_pred + 1.96 * overheating_days_pred_se,
                     lower = overheating_days_pred - 1.96 * overheating_days_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_days/sensitivity_analyses/predictions_pop_lat_overheating_days_", habitat_scenario, "_max_acc.rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)


# Set up parallel processing
plan(multicore(workers=2))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_days_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 


Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_substrate_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_substrate_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_substrate_future4C_max_acc.rds"))
```


###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_arboreal_current_max_acc.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_arboreal_future2C_max_acc.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_overheating_days_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_overheating_days_arboreal_future4C_max_acc.rds"))
```


#### **Linear mixed models** 

```{r, eval = F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
## Note that this model fails if we add an observation-level random effect
model_days <-  glmer(overheating_days ~ habitat_scenario - 1 + (1|genus/species), 
                     family = "poisson",
                     control = glmerControl(optimizer = "bobyqa",
                                            optCtrl = list(maxfun = 1000000000)),
                     data = all_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_days, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model and predictions
saveRDS(model_days, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_max_acc.rds")
saveRDS(predictions, file = "RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_max_acc.rds")

# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_days_contrast <-  glmer(overheating_days ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                              family = "poisson",
                              control = glmerControl(optimizer = "bobyqa",
                                                     optCtrl = list(maxfun = 1000000000)),
                              data = all_data)

saveRDS(model_days_contrast, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_max_acc.rds")


```


##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_days <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_max_acc.rds")
summary(model_overheating_days)

# Predictions
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_max_acc.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_days_contrast <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_max_acc.rds")
summary(model_overheating_days_contrast)
```


### **Temperatures exceeded 50% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 50% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## We do not load pond data because none of the species overheat in water bodies


####################### Sensitivity analyses #############################

# Here we only consider overheating events when maximum temperatures exceed 50% of the predicted distribution of CTmax

# Function to run population-level overheating_days models in parallel (sensitivity analysis, 50%)
run_overheating_days_analysis_strict50 <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(overheating_days_strict50 ~ s(lat, bs = "tp"), 
                        random = ~  (1 | genus/species),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_days_strict50 = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_days_pred <- pred$fit
  new_data$overheating_days_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_days_pred + 1.96 * overheating_days_pred_se,
                     lower = overheating_days_pred - 1.96 * overheating_days_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_days/sensitivity_analyses/predictions_pop_lat_overheating_days_strict50_", habitat_scenario, ".rds"))
}

# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)

plan(sequential)

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_days_analysis_strict50(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_substrate_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_substrate_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_substrate_future4C.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_arboreal_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_arboreal_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict50_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict50_arboreal_future4C.rds"))
```

#### **Linear mixed models**

```{r, eval = F}

all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)
# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
## Note that this model fails if we add an observation-level random effect
model_days_strict50 <-  glmer(overheating_days_strict50 ~ habitat_scenario - 1 + (1|genus/species), 
                              family = "poisson",
                              control = glmerControl(optimizer = "bobyqa",
                                                     optCtrl = list(maxfun = 1000000000)),
                              data = all_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_days_strict50, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model and predictions
saveRDS(model_days_strict50, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_strict50.rds")
saveRDS(predictions, file = "RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_strict50.rds")

# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_days_strict50_contrast <-  glmer(overheating_days_strict50 ~ habitat_scenario + (1|genus/species), 
                                       family = "poisson",
                                       control = glmerControl(optimizer = "bobyqa",
                                                              optCtrl = list(maxfun = 1000000000)),
                                       data = all_data)


# Save model
saveRDS(model_days_strict50_contrast, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_strict50.rds")

```


##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_days <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_strict50.rds")
summary(model_overheating_days)

# Predictions
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_strict50.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_days_contrast <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_strict50.rds")
summary(model_overheating_days_contrast)
```

### **Temperatures exceeded 95% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 95% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_overheating_days_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Function to run population-level overheating_days models in parallel (sensitivity analysis, 95%)
run_overheating_days_analysis_strict95 <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset 
  
  # Run model
  model <- gamm4::gamm4(overheating_days_strict95 ~ s(lat, bs = "tp"), 
                        random = ~  (1 | genus/species),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    overheating_days_strict95 = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_days_pred <- pred$fit
  new_data$overheating_days_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_days_pred + 1.96 * overheating_days_pred_se,
                     lower = overheating_days_pred - 1.96 * overheating_days_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_days/sensitivity_analyses/predictions_pop_lat_overheating_days_strict95_", habitat_scenario, ".rds"))
}


# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_overheating_days_analysis_strict95(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_substrate_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_substrate_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_substrate_future4C.rds"))
```

###### **Above-ground vegetation** 

Current climate
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_arboreal_current.rds"))
```

Future climate (+2C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_arboreal_future2C.rds"))
```

Future climate (+4C)
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_lat_overheating_days_strict95_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_lat_overheating_days_strict95_arboreal_future4C.rds"))
```

#### **Linear mixed models**

```{r, eval = F}
# Run model
model_days_strict95 <-  glmer(overheating_days_strict95 ~ habitat_scenario - 1 + (1|genus/species), 
                              family = "poisson",
                              control = glmerControl(optimizer = "bobyqa",
                                                     optCtrl = list(maxfun = 1000000000)),
                              data = all_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_days_strict95, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)
# Save model 
saveRDS(model_days_strict95, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_strict95.rds")
saveRDS(predictions, file = "RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_strict95.rds")

# Contrasts
model_days_strict95_contrast <-  glmer(overheating_days_strict95 ~ habitat_scenario + (1|genus/species), 
                                       family = "poisson",
                                       control = glmerControl(optimizer = "bobyqa",
                                                              optCtrl = list(maxfun = 1000000000)),
                                       data = all_data)


saveRDS(model_days_strict95_contrast, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_strict95.rds")


```


##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_overheating_days <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_strict95.rds")
summary(model_overheating_days)

# Predictions
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_overheating_days_strict95.rds"))
```

###### **Contrasts** 

```{r}
model_overheating_days_contrast <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_overheating_days_contrast_strict95.rds")
summary(model_overheating_days_contrast)
```

## **Consecutive overheating days** 

Here, we specifically quantified the consecutive number of overheating events populations were predicted to experience. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_consecutive_overheating_days.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_consecutive_overheating_days.pbs** 

### **Generalized additive mixed models** 

```{r, eval=F}
# Load population-level data
## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

## We do not load pond data because none of the species overheat in water bodies

# Function to run population-level consecutive_overheating_days models in parallel 
run_consecutive_overheating_days_analysis <- function(dataset, habitat_scenario) {
  
  split_names <- strsplit(as.character(dataset$tip.label), ' ')
  dataset$genus <- sapply(split_names, `[`, 1)
  dataset$species <- sapply(split_names, `[`, 2)
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(consecutive_overheating_days ~ s(lat, bs = "tp"), 
                        random = ~ (1 | genus/species),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    consecutive_overheating_days = NA, 
    genus = NA, 
    species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$consecutive_overheating_days_pred <- pred$fit
  new_data$consecutive_overheating_days_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = consecutive_overheating_days_pred + 1.96 * consecutive_overheating_days_pred_se,
                     lower = consecutive_overheating_days_pred - 1.96 * consecutive_overheating_days_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/overheating_days/sensitivity_analyses/predictions_pop_lat_consecutive_overheating_days_", habitat_scenario, ".rds"))
}


# Create a list of all the datasets
dataset_list <- list(
  arboreal_current = pop_arb_current,
  arboreal_future2C = pop_arb_future2C,
  arboreal_future4C = pop_arb_future4C,
  substrate_current = pop_sub_current,
  substrate_future2C = pop_sub_future2C,
  substrate_future4C = pop_sub_future4C
)


# Run sequentially to reduce memory demands
plan(sequential)

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_consecutive_overheating_days_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```


#### **Model summaries** {.tabset .tabset_fade .tabset_pills} 

##### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_MER_pop_lat_consecutive_overheating_days_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/summary_GAM_pop_lat_consecutive_overheating_days_arboreal_future4C.rds"))
```


### **Linear mixed models**

```{r, eval=F}
all_data <- bind_rows(
  pop_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  pop_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  pop_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  pop_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  pop_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  pop_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

# Load training data for taxonomic information
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
training_data <- dplyr::select(training_data, tip.label, family)

all_data <- distinct(left_join(all_data, training_data, by="tip.label"))

split_names <- strsplit(as.character(all_data$tip.label), ' ')
all_data$genus <- sapply(split_names, `[`, 1)
all_data$species <- sapply(split_names, `[`, 2)

all_data <- as.data.frame(all_data)

set.seed(123)

# Run model
## Note that this model fails if we add an observation-level random effect
model_days <-  glmer(consecutive_overheating_days ~ habitat_scenario - 1 + (1|genus/species), 
                     family = "poisson",
                     control = glmerControl(optimizer = "bobyqa",
                                            optCtrl = list(maxfun = 1000000000)),
                     data = all_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_days, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model summaries and predictions
saveRDS(model_days, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_consecutive_overheating_days.rds")
saveRDS(predictions, file = "RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_consecutive_overheating_days.rds")

# Contrasts
all_data$habitat_scenario <- as.factor(all_data$habitat_scenario)

model_days_contrast <-  glmer(consecutive_overheating_days ~ relevel(habitat_scenario, ref = "substrate_current") + (1|genus/species), 
                              family = "poisson",
                              control = glmerControl(optimizer = "bobyqa",
                                                     optCtrl = list(maxfun = 1000000000)),
                              data = all_data)


saveRDS(model_days_contrast, file = "RData/Models/overheating_days/sensitivity_analyses/model_lme4_consecutive_overheating_days_contrast.rds")
```


##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
# Model summary
model_consecutive_overheating_days <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_consecutive_overheating_days.rds")
summary(model_consecutive_overheating_days)

# Predictions
print(readRDS("RData/Models/overheating_days/sensitivity_analyses/predictions_lme4_consecutive_overheating_days.rds"))
```

###### **Contrasts** 

```{r}
model_consecutive_overheating_days_contrast <- readRDS("RData/Models/overheating_days/sensitivity_analyses/model_lme4_consecutive_overheating_days_contrast.rds")
summary(model_consecutive_overheating_days_contrast)
```


## **Number of species overheating** {.tabset .tabset_fade .tabset_pills}

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C.rds")

# Function to run models quantifying the number of species overheating in each community
run_community_n_species_overheating_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(n_species_overheating ~ s(lat, bs = "tp"),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    n_species_overheating = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$n_species_overheating_pred <- pred$fit
  new_data$n_species_overheating_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = n_species_overheating_pred + 1.96 * n_species_overheating_pred_se,
                     lower = n_species_overheating_pred - 1.96 * n_species_overheating_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/predictions_lat_number_sp_overheating_", habitat_scenario, "_max_acc.rds"))
}

# Create a list of datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

# Set up parallel processing
plan(multicore(workers=3))


# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_n_species_overheating_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_substrate_current_max_acc.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_substrate_future2C_max_acc.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_substrate_future4C_max_acc.rds"))
```

###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_arboreal_current_max_acc.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_arboreal_future2C_max_acc.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_arboreal_future4C_max_acc.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_n_sp <- glmer(n_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                    family = "poisson",
                    control = glmerControl(optimizer = "bobyqa",
                                           optCtrl = list(maxfun = 1000000000)),
                    data = all_community_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_n_sp, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_n_sp, file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_max_acc.rds")
saveRDS(predictions, file = "RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_max_acc.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_n_sp_contrast <- glmer(n_species_overheating ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                             family = "poisson",
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)

saveRDS(model_n_sp_contrast, file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_max_acc.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp <- readRDS("RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_max_acc.rds")
summary(model_n_sp)

# Predictions
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_max_acc.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_contrast <- readRDS("RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_max_acc.rds")
summary(model_n_sp_contrast)
```


### **Temperatures exceeded 50% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 50% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

################ Number of species overheating (sensitivity analyses) ##################

# Here, we only considered an overheating event when maximum temperatures exceeded 50% of the distribution of CTmax 

# Function to run models quantifying the number of species overheating (sensitivity analysis 50%) in each community
run_community_n_species_overheating_analysis_strict50 <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(n_species_overheating_strict50 ~ s(lat, bs = "tp"),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    n_species_overheating_strict50 = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$n_species_overheating_pred <- pred$fit
  new_data$n_species_overheating_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = n_species_overheating_pred + 1.96 * n_species_overheating_pred_se,
                     lower = n_species_overheating_pred - 1.96 * n_species_overheating_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/predictions_lat_number_sp_overheating_strict50_", habitat_scenario, ".rds"))
}

# Create a list of datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

# Set up parallel processing
plan(multicore(workers=3))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_n_species_overheating_analysis_strict50(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict50_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict50_arboreal_future4C.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_n_sp_strict50 <- glmer(n_species_overheating_strict50 ~ habitat_scenario - 1 + (1 |obs), 
                             family = "poisson",
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_n_sp_strict50, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_n_sp_strict50, file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_strict50.rds")
saveRDS(predictions, file = "RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_strict50.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_n_sp_strict50_contrast <- glmer(n_species_overheating_strict50 ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                                      family = "poisson",
                                      control = glmerControl(optimizer = "bobyqa",
                                                             optCtrl = list(maxfun = 1000000000)),
                                      data = all_community_data)


saveRDS(model_n_sp_strict50_contrast, file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_strict50.rds")


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp_strict50 <- readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_strict50.rds")
summary(model_n_sp_strict50)

# Predictions
summary(readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_strict50.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_strict50_contrast <- readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_strict50.rds")
summary(model_n_sp_strict50_contrast)
```



### **Temperatures exceeded 95% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded 95% of the predicted distribution of CTmax. These estimates are extremely conservative.

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_n_species_overheating_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
run_community_n_species_overheating_analysis_strict95 <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(n_species_overheating_strict95 ~ s(lat, bs = "tp"),
                        data = data,
                        family = poisson(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    n_species_overheating_strict95 = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$n_species_overheating_pred <- pred$fit
  new_data$n_species_overheating_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = n_species_overheating_pred + 1.96 * n_species_overheating_pred_se,
                     lower = n_species_overheating_pred - 1.96 * n_species_overheating_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/n_species_overheating/sensitivity_analyses/predictions_lat_number_sp_overheating_strict95_", habitat_scenario, ".rds"))
}

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_n_species_overheating_analysis_strict95(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)
```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_MER_lat_number_sp_overheating_strict95_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/n_species_overheating/sensitivity_analyses/summary_GAM_lat_number_sp_overheating_strict95_arboreal_future4C.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
model_n_sp_strict95 <- glmer(n_species_overheating_strict95 ~ habitat_scenario - 1 + (1 |obs), 
                             family = "poisson",
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)


# Get predictions
predictions <- as.data.frame(ggpredict(model_n_sp_strict95, 
                                       terms = "habitat_scenario", 
                                       type = "simulate", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_n_sp_strict95, file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_strict95.rds")
saveRDS(predictions, file = "RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_strict95.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_n_sp_strict95_contrast <- glmer(n_species_overheating_strict95 ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                                      family = "poisson",
                                      control = glmerControl(optimizer = "bobyqa",
                                                             optCtrl = list(maxfun = 1000000000)),
                                      data = all_community_data)

saveRDS(model_n_sp_strict95_contrast , file = "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_strict95.rds")


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp_strict95 <- readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_strict95.rds")
summary(model_n_sp_strict95)

# Predictions
summary(readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/predictions_lme4_number_sp_overheating_strict95.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_strict95_contrast <- readRDS( "RData/Models/n_species_overheating/sensitivity_analyses/model_lme4_number_sp_overheating_contrast_strict95.rds")
summary(model_n_sp_strict95_contrast)
```


## **Proportion of species overheating** {.tabset .tabset_fade .tabset_pills}

### **Acclimation to the maximum weekly body temperature** 

Here, animals were acclimated daily to the weekly maximum body temperature experienced, as opposed to the weekly mean body temperature. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_max_acc.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_max_acc.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_max_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_max_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_max_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_max_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_max_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_max_acc_future4C.rds")

# Function to run models estimating the mean overheating risk (i.e., proportion of species overheating) 
run_community_proportion_overheating_analysis <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(proportion_species_overheating ~ s(lat, bs = "tp"),
                        data = data,
                        weights = data$n_species,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    proportion_species_overheating = NA, 
    n_species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_community_lat_proportion_sp_overheating_", habitat_scenario, "_max_acc.rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_community_lat_proportion_sp_overheating_", habitat_scenario, "_max_acc.rds"))
  saveRDS(new_data, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/predictions_community_lat_proportion_sp_overheating_", habitat_scenario, "_max_acc.rds"))
}


# Create a list of datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

# Set up parallel processing
plan(multicore(workers=3))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_proportion_overheating_analysis(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 


**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_substrate_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_substrate_current_max_acc.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_substrate_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_substrate_future2C_max_acc.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_substrate_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_substrate_future4C_max_acc.rds"))
```

###### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_arboreal_current_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_arboreal_current_max_acc.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_arboreal_future2C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_arboreal_future2C_max_acc.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_arboreal_future4C_max_acc.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_arboreal_future4C_max_acc.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_prop <- glmer(proportion_species_overheating ~ habitat_scenario - 1 + (1 |obs), 
                    family = "binomial",
                    weights = n_species,
                    control = glmerControl(optimizer = "bobyqa",
                                           optCtrl = list(maxfun = 1000000000)),
                    data = all_community_data)



# Get predictions
predictions <- as.data.frame(ggpredict(model_prop, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model summaries and predictions
saveRDS(model_prop, file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_max_acc.rds")
saveRDS(predictions, file = "RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_max_acc.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_prop_contrast <- glmer(proportion_species_overheating ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                             family = "binomial",
                             weights = n_species,
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)

saveRDS(model_prop_contrast, file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_max_acc.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp <- readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_max_acc.rds")
summary(model_n_sp)

# Predictions
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_max_acc.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_contrast <- readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_max_acc.rds")
summary(model_n_sp_contrast)
```


### **Temperatures exceeded 50% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded either 50% of the predicted distribution of CTmax. These estimates are extremely conservative. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
# Load community-level data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C.rds")

community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C.rds")

################ Proportion of species overheating (sensitivity analyses) ##################

# Here, we only considered an overheating event when maximum temperatures exceeded 50% of the distribution of CTmax 

# Function to run models estimating the mean overheating risk (i.e., proportion of species overheating) 
run_community_proportion_overheating_analysis_strict50 <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(proportion_species_overheating_strict50 ~ s(lat, bs = "tp"),
                        data = data,
                        weights = data$n_species,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    proportion_species_overheating_strict50 = NA, 
    n_species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_community_lat_proportion_sp_overheating_strict50_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_community_lat_proportion_sp_overheating_strict50_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/predictions_community_lat_proportion_sp_overheating_strict50_", habitat_scenario, ".rds"))
}


# Create a list of datasets
dataset_list <- list(
  arboreal_current = community_arb_current,
  arboreal_future2C = community_arb_future2C,
  arboreal_future4C = community_arb_future4C,
  substrate_current = community_sub_current,
  substrate_future2C = community_sub_future2C,
  substrate_future4C = community_sub_future4C
)

# Set up parallel processing
plan(multicore(workers=3))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_proportion_overheating_analysis_strict50(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 


**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict50_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict50_arboreal_future4C.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
all_community_data <- bind_rows(
  community_sub_current %>% mutate(habitat_scenario = "substrate_current"), 
  community_sub_future2C %>% mutate(habitat_scenario = "substrate_future2C"), 
  community_sub_future4C %>% mutate(habitat_scenario = "substrate_future4C"), 
  community_arb_current %>% mutate(habitat_scenario = "arboreal_current"), 
  community_arb_future2C %>% mutate(habitat_scenario = "arboreal_future2C"), 
  community_arb_future4C %>% mutate(habitat_scenario = "arboreal_future4C")
)

all_community_data <- all_community_data %>% mutate(obs = as.character(row_number()))

all_community_data <- as.data.frame(all_community_data)

set.seed(123)

# Intercept-less model 
model_prop_strict50 <- glmer(proportion_species_overheating_strict50 ~ habitat_scenario - 1 + (1 |obs), 
                             family = "binomial",
                             weights = n_species,
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)



# Get predictions
predictions <- as.data.frame(ggpredict(model_prop_strict50, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)


# Save model and predictions
saveRDS(model_prop_strict50, file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_strict50.rds")
saveRDS(predictions, file = "RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_strict50.rds")

# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_prop_strict50_contrast <- glmer(proportion_species_overheating_strict50 ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                                      family = "binomial",
                                      weights = n_species,
                                      control = glmerControl(optimizer = "bobyqa",
                                                             optCtrl = list(maxfun = 1000000000)),
                                      data = all_community_data)


saveRDS(model_prop_strict50_contrast , file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_strict50.rds")


```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp_strict50 <- readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_strict50.rds")
summary(model_n_sp_strict50)

# Predictions
summary(readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_strict50.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_strict50_contrast <- readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_strict50.rds")
summary(model_n_sp_strict50_contrast)
```


### **Temperatures exceeded 95% of the distribution of CTmax** 

Here, we classified an overheating event only when operative body temperatures exceeded either 95% of the predicted distribution of CTmax. These estimates are extremely conservative. 

This code ran on an HPC environment, where the original code can be found in **R/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_strict_estimates.R** and the resources used in **pbs/Models/Sensitivity_analyses/Running_models_prop_species_overheating_sensitivity_analysis_strict_estimates.pbs** 

#### **Generalized additive mixed models** 

```{r, eval=F}
run_community_proportion_overheating_analysis_strict95 <- function(dataset, habitat_scenario) {
  
  data <- dataset
  
  # Run model
  model <- gamm4::gamm4(proportion_species_overheating_strict95 ~ s(lat, bs = "tp"),
                        data = data,
                        weights = data$n_species,
                        family = binomial(),
                        REML = TRUE)
  
  # Generate data set for predictions
  new_data <- data.frame(
    lat = seq(min(data$lat), max(data$lat), length = 1000),
    proportion_species_overheating_strict95 = NA, 
    n_species = NA)
  
  # Predict for each latitude value
  pred <- predict(model$gam, newdata = new_data, type = "response", se.fit = TRUE)
  new_data$overheating_risk_pred <- pred$fit
  new_data$overheating_risk_pred_se <- pred$se.fit
  
  # Calculate 95% confidence intervals
  new_data <- mutate(new_data, 
                     upper = overheating_risk_pred + 1.96 * overheating_risk_pred_se,
                     lower = overheating_risk_pred - 1.96 * overheating_risk_pred_se)
  
  # Model summaries 
  summary_gam <- capture.output(summary(model$gam)) # Generalised additive model
  summary_mer <- capture.output(summary(model$mer)) # Mixed effect regression
  
  # Save model and predictions
  saveRDS(summary_gam, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_community_lat_proportion_sp_overheating_strict95_", habitat_scenario, ".rds"))
  saveRDS(summary_mer, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_community_lat_proportion_sp_overheating_strict95_", habitat_scenario, ".rds"))
  saveRDS(new_data, file = paste0("RData/Models/prop_species_overheating/sensitivity_analyses/predictions_community_lat_proportion_sp_overheating_strict95_", habitat_scenario, ".rds"))
}

# Set up parallel processing
plan(multicore(workers=3))

# Run function
results <- future_lapply(
  names(dataset_list), 
  function(x) {run_community_proportion_overheating_analysis_strict95(dataset_list[[x]], x)},
  future.packages = c("gamm4", "mgcv", "dplyr")
)

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Vegetated substrate** 


**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_substrate_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_substrate_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_substrate_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_substrate_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_substrate_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_substrate_future4C.rds"))
```

##### **Above-ground vegetation** 

**Current climate**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_arboreal_current.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_arboreal_current.rds"))
```

**Future climate (+2C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_arboreal_future2C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_arboreal_future2C.rds"))
```

**Future climate (+4C)**
```{r}
# Mixed effect regression
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_MER_lat_prop_sp_overheating_strict95_arboreal_future4C.rds"))

# Generalized additive model
print(readRDS("RData/Models/prop_species_overheating/sensitivity_analyses/summary_GAM_lat_prop_sp_overheating_strict95_arboreal_future4C.rds"))
```


#### **Linear mixed models**

```{r, eval=F}
model_prop_strict95 <- glmer(proportion_species_overheating_strict95 ~ habitat_scenario - 1 + (1 |obs), 
                             family = "binomial",
                             weights = n_species,
                             control = glmerControl(optimizer = "bobyqa",
                                                    optCtrl = list(maxfun = 1000000000)),
                             data = all_community_data)



# Get predictions
predictions <- as.data.frame(ggpredict(model_prop_strict95, 
                                       terms = "habitat_scenario", 
                                       type = "random", 
                                       interval = "confidence", 
                                       nsim = 1000))

predictions <- predictions %>% rename(habitat_scenario = x, 
                                      prediction = predicted,
                                      se = std.error, 
                                      lower_CI = conf.low, 
                                      upper_CI = conf.high) %>% dplyr::select(-group)

# Save model and predictions
saveRDS(model_prop_strict95, file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_strict95.rds")
saveRDS(predictions, file = "RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_strict95.rds")


# Contrast 
all_community_data$habitat_scenario <- as.factor(all_community_data$habitat_scenario)

model_prop_strict95_contrast <- glmer(proportion_species_overheating_strict95 ~ relevel(habitat_scenario, ref = "substrate_current") + (1 |obs), 
                                      family = "binomial",
                                      weights = n_species,
                                      control = glmerControl(optimizer = "bobyqa",
                                                             optCtrl = list(maxfun = 1000000000)),
                                      data = all_community_data)

saveRDS(model_prop_strict95_contrast, file = "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_strict95.rds")

```

##### **Model summaries** {.tabset .tabset_fade .tabset_pills}

###### **Overall means** 

```{r}
model_n_sp_strict95 <- readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_strict95.rds")
summary(model_n_sp_strict95)

# Predictions
summary(readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/predictions_lme4_prop_species_overheating_strict95.rds"))
```

###### **Contrasts** 

```{r}
model_n_sp_strict95_contrast <- readRDS( "RData/Models/prop_species_overheating/sensitivity_analyses/model_lme4_prop_species_overheating_contrast_strict95.rds")
summary(model_n_sp_strict95_contrast)
```



# **Main figures** 

Note that cosmetic adjustments were made to all figures in Microsoft Powerpoint and Adobe Illustrator.  

## **Figure 1** 

```{r, width = 20, height = 11}
# Load data from Pottier et al. 2022
data <- read_csv("data/data_Pottier_et_al_2022.csv")

# Load one of the datasets for species richness
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")

world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>% 
  filter(!grepl("Antarctica", name))

# Map
map_diversity <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = log10(n_species)), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "viridis", 
                     na.value = "gray1", name = "Species", 
                     breaks = c(0, log10(10), log10(50), log10(100), log10(150)),
                     labels = c(1, 10, 50, 100, 150), 
                     guide = guide_colorbar(barwidth = 2, barheight = 10),
                     begin=0.1, end=1) +
  ggnewscale::new_scale_fill() +
  geom_point(data = data, 
             aes(y = latitude, x = longitude), 
             alpha = 0.85, 
             size= 4, 
             stroke = 1.5, 
             shape = 21,
             fill = "#CE5B97",
             col = "black")+
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0.5, 0.5), "cm"),
        legend.position = c(0.02, 0.27),
        legend.justification = c(0, 0.5),
        legend.background = element_blank(),
        text = element_text(color = "black"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 20),
        panel.border = element_rect(fill=NA, size = 2))

# Density of points
community_pond_expanded <- community_pond_current %>% 
  uncount(n_species, .remove = FALSE)

density <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
   geom_density(data = data, aes(x = latitude), 
                fill = "#CE5B97", 
                alpha=0.5) +
   geom_density(data = community_pond_expanded, aes(x = lat), 
                fill="#21918c", 
                alpha=0.5) +
  xlim(-55.00099, 72.00064) +
  ylab("Density") + 
  coord_flip() +
  theme_classic() +
  theme(axis.title.x = element_text(size = 25, 
                                    margin = margin(t = 10, 
                                                    r = 0,
                                                    b = 0,
                                                    l = 0)),
        axis.text.x = element_text(size = 20, colour = "black"),
        axis.text.y = element_text(size = 20, colour = "black"),
        axis.title.y = element_blank(),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        panel.border = element_rect(fill=NA, size = 2))

map <- map_diversity + density + plot_layout(ncol = 2)

map

ggsave(map, file="fig/Figure_1.png", width=20, height=11, dpi=500)
```

Fig. 1 | Contrast between the geographical locations at which experimental data were collected, and patterns in species richness. Pink points denote experimental data, while the color gradients refer to species richness calculated in 1 x 1 ° grid cells in the imputed data (5,203 species). Density plots represent the distribution of experimental data (pink) and the number of species inhabiting these areas (blue) across latitudes. Dashed lines represent the equator and tropics. 


## **Figure 2** 

```{r, fig.width=10, fig.height=10}
# Load data 
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Add species-level data to population-level dataset
species_data <- readRDS("RData/General_data/pre_data_for_imputation.rds")
species_data <- dplyr::select(species_data, 
                              tip.label, 
                              order, 
                              imputed)

pop_sub_future4C <- distinct(left_join(pop_sub_future4C, species_data))

# Import tree from Jetz and Pyron (with slight modifications in species names)
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

# Calculate data summary
data_summary <- pop_sub_future4C %>% 
   group_by(tip.label) %>% 
   summarise(mean_CTmax = mean(CTmax),
             mean_TSM = mean(TSM),
             mean_overheating_days = mean(overheating_days),
             log_overheating_days = log2(mean_overheating_days + 1))

# Make overheating risk a binary variable
data_summary <- data_summary %>% 
  mutate(overheating = ifelse(mean_overheating_days > 0, "yes", "no"))

# Add order of the species to the data summary
data_summary <- distinct(left_join(data_summary, dplyr::select(pop_sub_future4C, tip.label, order, imputed))) 

# Flag species that were tested previously or full imputed
data_summary <- data_summary %>% 
  group_by(tip.label) %>% 
  filter(if(any(imputed=="no")) imputed == "no" else TRUE) %>% 
  ungroup()

# Prune tree
pruned_tree <- drop.tip(tree, tree$tip.label[-match(data_summary$tip.label, tree$tip.label)]) 

# Build tree skeleton
p1 <- ggtree(pruned_tree, 
             layout = "fan", 
             lwd = 0.05) + 
       xlim(0,800)

# Match data to the tree
p1 <- p1 %<+% data_summary 

p2 <-  p1 + geom_fruit(geom = geom_tile, # Heat map
                       mapping = aes(fill = order), 
                       width=10, 
                       offset=0.035,
                       alpha = 1)+ 
               scale_fill_manual(values =c("gray60", "gray20"))

p3 <-  p2 + ggnewscale::new_scale_fill() +
            geom_fruit(geom = geom_tile, # Heat map
                       mapping = aes(fill = imputed), 
                       width=20, 
                       offset=0.075,
                       alpha = 1)+ 
               scale_fill_manual(values =c("#CE5B97", "gray85"))

p4 <- p3 + ggnewscale::new_scale_fill()+
           geom_fruit(geom = geom_tile, # Heat map
                      mapping = aes(fill = mean_CTmax), 
                                    width=55, 
                                    offset=0.15,
                                    alpha = 1) + 
           scale_fill_viridis(option="viridis", 
                              begin=0, 
                              end=1, 
                              name="CTmax") 

p5 <- p4 + ggnewscale::new_scale_fill()+
           geom_fruit(geom = geom_tile, # Heat map
                      mapping = aes(fill = mean_TSM), 
                                    width=55, 
                                    offset=0.2,
                                    alpha = 1) + 

           scale_fill_viridis(option="inferno", 
                              direction = -1, 
                              begin=0, 
                              end=0.9, 
                              name="TSM") 

# p5 <- p4 + ggnewscale::new_scale_fill()+
#            geom_fruit(geom = geom_tile, # Heat map
#                       mapping = aes(fill = overheating), 
#                                     width=55, 
#                                     offset=0.2) + 
#            scale_fill_manual(values = c("gray90", "#CE5B97"))

p6 <- p5 + 
  geom_fruit(geom = geom_bar, # Bar plot
             mapping = aes(x = log_overheating_days),
             col = "#fb9b06",
             fill = "#fb9b06",
             size = 0.1,
             stat = "identity", 
             orientation = "y", 
             axis.params = list(axis = "x", # Barplot parameters
                                text.angle = 0, 
                                hjust = 0, 
                                text.size = 1,
                                col="transparent"), 
             grid.params = list(alpha = 0.1),
             offset = 0.11, 
             pwidth = 0.5, 
             alpha = 1)

p6

ggsave(p6, file="fig/Figure_2.png", width=10, height=10, dpi=1000)
```

Fig. 2 | Phylogenetic coverage and taxonomic variation in climate vulnerability. Chronograms show heat tolerance limits (CTmax), thermal safety margins (TSM), and histograms the number of overheating events (days) averaged across each species’ distribution range. Pink bars refer to species with prior knowledge, while gray bars refer to entirely imputed species. This figure was constructed assuming ground-level microclimates occurring under 4°C of global warming above pre-industrial levels. Phylogeny is based on the consensus of 10,000 trees sampled from a posterior distribution (see Jetz & Pyron, 2018 for details).

## **Figure 3**

### **Vegetated Substrate** 

```{r, fig.width=15, fig.height=8}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds") 

# Pond data 
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

# Find limits for colours of the plot
tsm_min <- min(min(community_sub_current$community_TSM, na.rm = TRUE), 
               min(community_sub_future4C$community_TSM, na.rm = TRUE),
               min(community_arb_current$community_TSM, na.rm = TRUE), 
               min(community_arb_future4C$community_TSM, na.rm = TRUE),
               min(community_pond_current$community_TSM, na.rm = TRUE), 
               min(community_pond_future4C$community_TSM, na.rm = TRUE))

tsm_max <- max(max(community_sub_current$community_TSM, na.rm = TRUE), 
               max(community_sub_future4C$community_TSM, na.rm = TRUE),
               max(community_arb_current$community_TSM, na.rm = TRUE), 
               max(community_arb_future4C$community_TSM, na.rm = TRUE),
               max(community_pond_current$community_TSM, na.rm = TRUE), 
               max(community_pond_future4C$community_TSM, na.rm = TRUE))

# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future4C.rds")

lat_sub <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_line(data = pred_community_sub_current, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_sub_current, 
             aes(x = lat, y = TSM_pred),
             color = "#5DC8D9", 
             size = 0.75) + # model predictions
  geom_line(data = pred_community_sub_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_sub_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "#EF4187", 
             size = 0.75) + # model predictions
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- map_sub_TSM_current + 
                  map_sub_TSM_future4C + 
                  lat_sub + 
                  plot_layout(ncol = 3)
```

### **Pond or wetland** 

```{r, fig.width=15, fig.height=8}
# Current
map_pond_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +4C
map_pond_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_pond_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_pond_current.rds")
pred_community_pond_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_pond_future2C.rds")
pred_community_pond_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_pond_future4C.rds")

lat_pond <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_pond_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_pond_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_line(data = pred_community_pond_current, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_pond_current, 
             aes(x = lat, y = TSM_pred),
             color = "#5DC8D9", 
             size = 0.75) + # model predictions
  geom_line(data = pred_community_pond_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_pond_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "#EF4187", 
             size = 0.75) + # model predictions
 xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

pond_plot <- (map_pond_TSM_current + 
              map_pond_TSM_future4C + 
              lat_pond + 
              plot_layout(ncol = 3))
```


### **Above-ground vegetation**

```{r, fig.width=15, fig.height=8}
# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     name = "TSM",
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 14),
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm"),
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))


# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future4C.rds")

lat_arb <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_line(data = pred_community_arb_current, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_arb_current, 
             aes(x = lat, y = TSM_pred),
             color = "#5DC8D9", 
             size = 0.75) + # model predictions
  geom_line(data = pred_community_arb_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "black", 
             size = 1.05) + # black line
  geom_line(data = pred_community_arb_future4C, 
             aes(x = lat, y = TSM_pred),
             color = "#EF4187", 
             size = 0.75) + # model predictions
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("Thermal safety margin") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 13),
        axis.text.x = element_text(color = "black", size = 11),
        axis.line = element_line(color = "black"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18),
        legend.key.height = unit(0.6, "cm"),
        legend.key.width = unit(0.5, "cm"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                  map_arb_TSM_future4C + 
                  lat_arb + 
                  plot_layout(ncol = 3))
```


#### **Final plot**

```{r, fig.width = 14, fig.height = 8}

figure3 <- (substrate_plot /
            pond_plot /
            arboreal_plot /
            plot_layout(ncol = 1))

figure3

ggsave("fig/Figure_3.png", width=14, height=7, dpi = 500)
```

Fig. 3 | Community-level patterns in thermal safety margin for amphibians in terrestrial (top row), aquatic (middle row) or arboreal (bottom row) microhabitats. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature in full shade during the warmest quarters of 2006-2015 in each community (1-degree grid cell). Black color depicts areas with no data. The right panel depicts latitudinal patterns in TSM in current climates (blue) or assuming 4°C of global warming above pre-industrial levels (pink), as predicted from generalized additive mixed models. Dashed lines represent the equator and tropics.


## **Figure 4**

### **Load data** 

```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds") 

# Pond data 
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>% 
  filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_sub_current)
```

#### **Vegetated Substrate** 

```{r, fig.width=15, fig.height=8}
# Set colours
color_palette <- colorRampPalette(colors = c("#FAF218", "#EF4187", "#d90429"))
colors <- color_palette(100)
color_func <- colorRampPalette(c("gray65", colors))
color_palette <- color_func(100)

sp_min <- min(min(community_sub_current$n_species_overheating, na.rm = TRUE),
              min(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              min(community_pond_current$n_species_overheating, na.rm = TRUE),
              min(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              min(community_arb_current$n_species_overheating, na.rm = TRUE),
              min(community_arb_future4C$n_species_overheating, na.rm = TRUE))

sp_max <- max(max(community_sub_current$n_species_overheating, na.rm = TRUE),
              max(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              max(community_pond_current$n_species_overheating, na.rm = TRUE),
              max(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              max(community_arb_current$n_species_overheating, na.rm = TRUE),
              max(community_arb_future4C$n_species_overheating, na.rm = TRUE))

# Substrate (current)
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))


# Substrate (Future +4C)
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
lat_sub <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_sub_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_sub_current, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 84)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- map_sub_TSM_current + 
                  map_sub_TSM_future4C + 
                  lat_sub + 
                  plot_layout(ncol = 3)

```

#### **Above-ground vegetation**

```{r, fig.width=15, fig.height=8}
# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))


# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 14),
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm"),
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
lat_arb <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
      geom_point(data = filter(community_arb_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_arb_current, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) +
  xlim(-55.00099, 72.00064) +
  ylim(0, 84)+
  xlab("") +
  ylab("Species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 13),
        axis.text.x = element_text(color = "black", size = 11),
        axis.line = element_line(color = "black"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18),
        legend.key.height = unit(0.6, "cm"),
        legend.key.width = unit(0.5, "cm"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- map_arb_TSM_current + 
                 map_arb_TSM_future4C + 
                 lat_arb + 
                 plot_layout(ncol = 3)
```

#### **Final plot**

```{r, fig.width=14, fig.height = 5}

figure4  <- (substrate_plot /
             arboreal_plot /
             plot_layout(ncol = 1))

figure4

ggsave("fig/Figure_4.png", width=14, height=5, dpi = 500)
```

Fig. 4 | Number of species predicted to experience overheating events in terrestrial (top row) and arboreal (bottom row) microhabitats. The number of species overheating was assessed as the sum of species overheating at least once in the period surveyed (warmest quarters of 2006-2015) in each community (1-degree grid cell). Black color depicts areas with no data, and gray color communities without species at risk. The right panel depicts latitudinal patterns in the number of species predicted to overheat in current climates (blue) or assuming 4°C of global warming above pre-industrial levels (pink). Dashed lines represent the equator and tropics. No species were predicted to experience overheating events in water bodies, and hence are not displayed.


## **Figure 5**

### **Load data** 
```{r}
# Vegetated substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Arboreal conditions
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")


# Find limits for colours of the plot
days_min <- min(min(pop_sub_current$overheating_days, na.rm = TRUE), 
               min(pop_sub_future4C$overheating_days, na.rm = TRUE),
               min(pop_arb_current$overheating_days, na.rm = TRUE), 
               min(pop_arb_future4C$overheating_days, na.rm = TRUE))

days_max <- max(max(pop_sub_current$overheating_days, na.rm = TRUE), 
               max(pop_sub_future4C$overheating_days, na.rm = TRUE),
               max(pop_arb_current$overheating_days, na.rm = TRUE), 
               max(pop_arb_future4C$overheating_days, na.rm = TRUE))
```

### **Overheating days by latitude - Substrate** 

```{r}
n_days_sub <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Overheating days by latitude - Above-ground vegetation** 

```{r}
n_days_arb <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


### **Overheating days by TSM - Substrate** 
```{r}
days_TSM_sub <- ggplot() + 
  geom_point(data = pop_sub_future4C, 
             aes(x = TSM, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_sub_future2C, 
             aes(x = TSM, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_sub_current, 
             aes(x = TSM, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  ylim(-0.35, days_max+0.35) +
  xlim (0, 18) +
  xlab("Thermal safety margin") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


### **Overheating days by TSM - Above-ground vegetation** 

```{r}
days_TSM_arb <- ggplot() + 
  geom_point(data = pop_arb_future4C, 
             aes(x = TSM, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_arb_future2C, 
             aes(x = TSM, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_arb_current, 
             aes(x = TSM, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  ylim(-0.35, days_max+0.35) +
  xlim (0, 18) +
  xlab("Thermal safety margin") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


### **Final plot** 

```{r, fig.width = 16, fig.height = 12}
figure5 <- (n_days_sub | days_TSM_sub) /
           (n_days_arb | days_TSM_arb) 


figure5

ggsave("fig/Figure_5.png", width=16, height=12, dpi = 500)
```

Fig. 5 | Latitudinal variation in the number of overheating events in terrestrial (top row) and arboreal (bottom row) microhabitats as a function of latitude (left column) and thermal safety margin (right column). The number of overheating events (days) were calculated as the sum of overheating events (when daily maximum temperatures exceed CTmax) during the warmest quarters of 2006-2015 for each population. Blue points depict the number of overheating events in historical microclimates, while orange and pink points depict the number of overheating events assuming 2°C and 4°C of global warming above pre-industrial levels, respectively. For clarity, only the populations predicted to experience overheating events across latitudes are depicted (left column).


# **Extended Data figures** 

## **Extended data - Figure 2** 

```{r, fig.width = 20, fig.height = 16}
# Load data that was used for the imputation
data_for_imp <- readRDS("RData/General_data/pre_data_for_imputation.rds")

# Load datasets from the cross-validation
first_crossV <- readRDS(file = "Rdata/Imputation/results/1st_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "1")
second_crossV <- readRDS(file = "Rdata/Imputation/results/2nd_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "2")
third_crossV <- readRDS(file = "Rdata/Imputation/results/3rd_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "3")
fourth_crossV <- readRDS(file = "Rdata/Imputation/results/4th_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "4")
fifth_crossV <- readRDS(file = "Rdata/Imputation/results/5th_cross_validation_5th_cycle.Rds") %>% mutate(crossV = "5")

all_imputed_dat<- bind_rows(first_crossV,
                            second_crossV,
                            third_crossV,
                            fourth_crossV,
                            fifth_crossV)

# Filter to data that was used for the cross-validation
imp_data <- all_imputed_dat[all_imputed_dat$dat_to_validate=="yes",]
imp_data <- dplyr::filter(imp_data,is.na(tip.label)==FALSE) 

# Add row number
row_n_imp <- data.frame(row_n = imp_data$row_n)

# Filter to original data
original_data <- data_for_imp[data_for_imp$row_n %in% row_n_imp$row_n,]
original_data<- dplyr:::select(original_data, row_n, mean_UTL)

# Combine dataframes
data<- dplyr::left_join(original_data, imp_data, by="row_n")
data <- rename(data, original_CTmax = mean_UTL.x,
                     imputed_CTmax = filled_mean_UTL5)

# Remove observations that were cross-validated twice
duplicates <- data %>% 
  group_by(row_n) %>% 
  summarise(n=n()) %>% 
  filter(n>1) 
duplicates <- duplicates$row_n

data <- data[!(data$row_n %in% duplicates & data$crossV == "5"), ]


data %>% summarise(mean=mean(original_CTmax), 
                   sd=sd(original_CTmax), 
                   n=n())

data %>% summarise(mean=mean(imputed_CTmax), 
                   sd=sd(imputed_CTmax), 
                   n=n())

plot_crossV <- ggplot(data) + 
  geom_density(aes(original_CTmax), 
               fill="#21918c", 
               alpha=0.8)+
  geom_density(aes(imputed_CTmax), 
               fill="#CE5B97", 
               alpha=0.8)+
  xlab("CTmax") +
  ylab("Density") +
  theme_classic() +
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 60, margin = margin(t = 40, r = 0, b = 0, l = 0)),
        axis.title.y = element_text(size = 60, margin = margin(t = 0, r = 40, b = 0, l = 0)),
        axis.text.x = element_text(size = 50, margin = margin(t = 20, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(size = 50, margin = margin(t = 0, r = 20, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 2))

plot_crossV


ggsave(plot_crossV, file="fig/Extended_data_figure_2a.png", width=18, height=16, dpi=500)
```

Extended Data Fig. 2a |  Probability density distributions of experimental CTmax (blue) and CTmax cross-validated using our data imputation procedure (pink).


```{r, fig.width = 20, fig.height = 16}
plot_corr <- ggplot(data) + 
  geom_abline(intercept = 0, slope = 1, linewidth = 1.25) + 
  geom_point(aes(x = imputed_CTmax, y = original_CTmax), 
             fill="#CE5B97", 
             alpha=0.8, 
             shape = 21, 
             size = 10) +
  ylab("Experimental CTmax") +
  xlab("Imputed CTmax") +
  xlim(27,43.5) + 
  ylim(27,43.5)+
  geom_text(aes(x= 40, y = 29), label = "r = 0.86", size = 20) +
  theme_classic() +
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 60, margin = margin(t = 40, r = 0, b = 0, l = 0)),
        axis.title.y = element_text(size = 60, margin = margin(t = 0, r = 40, b = 0, l = 0)),
        axis.text.x = element_text(size = 50, margin = margin(t = 20, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(size = 50, margin = margin(t = 0, r = 20, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 2))
plot_corr

ggsave(plot_corr, file="fig/Extended_data_figure_2b.png", width=18, height=16, dpi=500)

```

Extended Data Fig. 2b |  Correlation between experimental CTmax and CTmax cross-validated using our data imputation procedure. 

```{r, fig.width = 10, fig.height = 10}
# Load imputed data
imputed_data <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")

imputed_data <- filter(imputed_data, imputed=="yes")

# Calculate data summary
data_summary <- imputed_data %>% 
   mutate(SE = (upper_mean_UTL - filled_mean_UTL5)/1.96,
          weights = 1/(SE^2)) %>% 
   group_by(tip.label) %>% 
   summarise(CTmax = (sum(filled_mean_UTL5 * weights)/sum(weights)),
             SE = sqrt(sum(weights) * (n() - 1) / (((sum(weights)^2) - (sum(weights^2))))),
             order = order)

# Calculate data summary for the training data
training_data <- readRDS("RData/General_data/training_data.rds") 

data_summary_exp <- training_data %>% 
   group_by(tip.label) %>% 
   summarise(CTmax_exp = mean(mean_UTL),
             order = order)

data_summary <- distinct(left_join(data_summary, data_summary_exp))

data_summary <- mutate(data_summary, tested = ifelse(is.na(CTmax_exp)== "FALSE", "tested", "not_tested"))

# Set colour
CTmax_min <- min(min(data_summary$CTmax, na.rm = TRUE))

CTmax_max <- max(max(data_summary$CTmax, na.rm = TRUE))


# Import tree from Jetz and Pyron (with slight modifications in species names)
tree <- readRDS("RData/General_data/tree_for_imputation.rds")

# Prune tree
pruned_tree <- drop.tip(tree, tree$tip.label[-match(data_summary$tip.label, tree$tip.label)]) 


# Build tree skeleton
p1 <- ggtree(pruned_tree, 
             layout = "fan", 
             lwd = 0.05) + 
       xlim(0,800)

# Match data to the tree
p1 <- p1 %<+% data_summary 

p2 <-  p1 + geom_fruit(geom = geom_tile, # Heat map
                       mapping = aes(fill = order), 
                       width=10, 
                       offset=0.035)+ 
               scale_fill_manual(values =c("gray60", "gray20"))

p3 <- p2 + ggnewscale::new_scale_fill()+
           geom_fruit(geom = geom_tile, # Heat map
                      mapping = aes(fill = tested), 
                                    width=55, 
                                    offset=0.15) + 
           scale_fill_manual(values = c("gray85", "#21918c"))

p4 <- p3 + ggnewscale::new_scale_fill()+
           geom_fruit(geom = geom_tile, # Heat map
                      mapping = aes(fill = SE), 
                                    width=55, 
                                    offset=0.19) + 
           scale_fill_viridis(option="plasma", 
                              begin=0, 
                              end=1, 
                              name="SE",
                              na.value = "gray85")

p4

ggsave(file="fig/Extended_data_figure_2c.png", width=10, height=10, dpi=1000)
```


Extended Data Fig. 2c | Variation in the uncertainty (standard error, SE) of imputed CTmax predictions (outer chronogram) across studied (blue) and imputed (grey) species.

## **Extended data - Figure 3**

```{r}
# Load data 

## Substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

## Pond
pop_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/population_vulnerability_pond_mean_acc_current.rds")
pop_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/population_vulnerability_pond_mean_acc_future2C.rds")
pop_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/population_vulnerability_pond_mean_acc_future4C.rds")

## Arboreal
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

```

### **TSM** 

#### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_future4C.rds")


pop_TSM_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))
```

#### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_pond_future4C.rds")

pop_TSM_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("Thermal safety margin") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 45),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_arboreal_future4C.rds")


pop_TSM_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = TSM), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = TSM), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = TSM), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 45),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **All habitats** 

```{r, fig.height=20, fig.width=10}
TSM <- pop_TSM_sub / pop_TSM_pond / pop_TSM_arb / plot_layout(ncol = 1)
```

### **CTmax** 

#### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_substrate_future4C.rds")

pop_CTmax_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))
```

#### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_pond_future4C.rds")


pop_CTmax_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("Critical thermal maximum") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 45),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))

```


#### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/CTmax/predictions_pop_lat_CTmax_arboreal_future4C.rds")


pop_CTmax_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = CTmax), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = CTmax), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = CTmax), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 45),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        plot.margin = unit(c(0, 0.25, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **All habitats** 

```{r, fig.height=20, fig.width=10}
CTmax  <- pop_CTmax_sub / pop_CTmax_pond / pop_CTmax_arb / plot_layout(ncol = 1)
```

### **Operative body temperature** 

#### **Vegetated substrate**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_sub_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_current.rds")
pred_sub_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_future2C.rds")
pred_sub_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_substrate_future4C.rds")


pop_max_temp_sub <- ggplot()+
  geom_point(data = pop_sub_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_sub_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_sub_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **Pond or wetland**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_pond_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_current.rds")
pred_pond_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_future2C.rds")
pred_pond_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_pond_future4C.rds")


pop_max_temp_pond <- ggplot()+
  geom_point(data = pop_pond_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_pond_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_pond_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_pond_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_pond_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("") +
  ylab("Operative body temperature") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 45),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


###### **Above-ground vegetation**

```{r, fig.width = 20, fig.height = 11}
# Load model predictions
pred_arb_current <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_current.rds")
pred_arb_future2C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_future2C.rds")
pred_arb_future4C <- readRDS("RData/Models/max_temp/predictions_pop_lat_max_temp_arboreal_future4C.rds")


pop_max_temp_arb <- ggplot()+
  geom_point(data = pop_arb_future4C, 
             aes(x = lat, y = max_temp), 
             colour="#EF4187", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_future2C, 
             aes(x = lat, y = max_temp), 
             colour="#FAA43A", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_point(data = pop_arb_current, 
             aes(x = lat, y = max_temp), 
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 2) +
  geom_ribbon(data = pred_arb_current, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_arb_future2C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#FAA43A", 
              colour="black") +
  geom_ribbon(data = pred_arb_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#EF4187", 
              colour="black") +
  xlab("Latitude") +
  ylab("") +
  ylim(-10, 50) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 45),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **All habitats** 

```{r, fig.height=20, fig.width=10}
body_temp <- pop_max_temp_sub / pop_max_temp_pond / pop_max_temp_arb / plot_layout(ncol = 1)
```

### **Combine TSM, CTmax and body temperature plots**

```{r, fig.width = 30, fig.height = 20}
all_traits <- (TSM|CTmax|body_temp)

all_traits

ggsave(all_traits, file = "fig/Extended_data_figure_3.png", width=30, height=20, dpi = 1000)
```

Extended Data Fig. 3 | Thermal safety margin, critical thermal maximum, and operative body temperatures in different microhabitats and climatic scenarios. Population-level mean thermal safety margins (TSM; left column), critical thermal maximum (CTmax; middle column) and operative body temperatures (right column) in terrestrial (top row), aquatic (middle row) and arboreal (bottom row) microhabitats are depicted in current microclimates (blue data points), or assuming 2°C and 4°C of global warming above pre-industrial levels (orange, and pink data points, respectively) across latitudes. Lines represent 95% confidence intervals of model predictions from generalized additive mixed models.


## **Extended data - Figure 4**

### **Population-level patterns** 

```{r}
# Vegetated substrate
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Pond or wetland
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

# Filter substrate data to only arboreal species
pop_sub_current <- pop_sub_current[pop_sub_current$tip.label %in% pop_arb_current$tip.label,]
pop_sub_future2C <- pop_sub_future2C[pop_sub_future2C$tip.label %in% pop_arb_future2C$tip.label,]
pop_sub_future4C <- pop_sub_future4C[pop_sub_future4C$tip.label %in% pop_arb_future4C$tip.label,]

```

#### **Overheating days by latitude - Substrate** 

```{r}
n_days_sub <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, 80.35) +
  xlab("") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25),
        axis.text.y = element_text(color = "black", 
                                   size = 25),
        panel.border = element_rect(fill=NA, size = 3))
```

#### **Overheating days by latitude - Above-ground vegetation** 

```{r}
n_days_arb <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, 80.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25),
        axis.text.y = element_text(color = "black", 
                                   size = 25),
        panel.border = element_rect(fill=NA, size = 3))

```


#### **Overheating days by TSM - Substrate** 
```{r}
days_TSM_sub <- ggplot() + 
  geom_point(data = pop_sub_future4C, 
             aes(x = TSM, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_sub_future2C, 
             aes(x = TSM, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_sub_current, 
             aes(x = TSM, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  ylim(-0.35, 80.35) +
  xlim (0, 18) +
  xlab("Thermal safety margin") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **Overheating days by TSM - Above-ground vegetation** 

```{r}
days_TSM_arb <- ggplot() + 
  geom_point(data = pop_arb_future4C, 
             aes(x = TSM, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_arb_future2C, 
             aes(x = TSM, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  geom_point(data = pop_arb_current, 
             aes(x = TSM, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5) +
  ylim(-0.35, 80.35) +
  xlim (0, 18) +
  xlab("Thermal safety margin") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


#### **Combine plot** 

```{r, fig.width = 16, fig.height = 12}
ext_fig4 <- (n_days_sub | days_TSM_sub) /
            (n_days_arb | days_TSM_arb) 


ext_fig4

ggsave("fig/Extended_data_figure_4abcd.png", width=16, height=12, dpi = 500)
```


### **Community-level patterns** 
```{r}
# Load data
## Substrate
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells_arboreal_sp.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells_arboreal_sp.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells_arboreal_sp.rds")

## Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

# Set colours
color_palette <- colorRampPalette(colors = c("#FAF218", "#EF4187", "#d90429"))
colors <- color_palette(100)
color_func <- colorRampPalette(c("gray65", colors))
color_palette <- color_func(100)

sp_min <- min(min(community_sub_current$n_species_overheating, na.rm = TRUE),
              min(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              min(community_arb_current$n_species_overheating, na.rm = TRUE),
              min(community_arb_future4C$n_species_overheating, na.rm = TRUE))

sp_max <- max(max(community_sub_current$n_species_overheating, na.rm = TRUE),
              max(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              max(community_arb_current$n_species_overheating, na.rm = TRUE),
              max(community_arb_future4C$n_species_overheating, na.rm = TRUE))

```

Extended Data Fig. 4a-d |  Number of overheating events experienced by arboreal species across latitudes (left column) and in relation to thermal safety margins (right column) in terrestrial (top row) and arboreal microhabitats (bottom row). The number of overheating events were calculated as the sum of overheating events (when daily maximum temperatures exceed CTmax) during the warmest quarters of 2006-2015 for each population. Blue points depict the number of overheating events in historical microclimates, while orange and pink points depict the number of overheating events assuming 2°C and 4°C of global warming above pre-industrial levels, respectively. In the left column, only the populations predicted to overheat are displayed. 


##### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 8}

# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       limits=c(0, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       limits=c(0, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_sub_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_sub_current, n_species_overheating>0),  
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, sp_max)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.text.x = element_text(color = "black", size = 10),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 3))
```


##### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 8}

# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       limits=c(0, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))


# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(0, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

lat_all_arb <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_arb_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_arb_current, n_species_overheating>0),  
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, sp_max)+
  xlab("") +
  ylab("Species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(color = "black", size = 12),
        axis.text.x = element_text(color = "black", size = 10),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                   map_arb_TSM_future4C + 
                   lat_all_arb + 
                   plot_layout(ncol = 3))
```


##### **All habitats** 

```{r, fig.height=5, fig.width = 15}

all_habitats <- (substrate_plot /
                 arboreal_plot /
                 plot_layout(ncol = 1))

all_habitats

ggsave("fig/Extended_data_figure_4ef.png", width=14, height=5, dpi = 500)
```

Extended Data Fig. 4e-f | Number of arboreal species predicted to experience overheating events terrestrial (top row) and arboreal (bottom row) microhabitats in each community. The number of species overheating was assessed as the sum of species overheating at least once in the period surveyed (warmest quarters of 2006-2015) in each community (1-degree grid cell). Black color depicts areas with no data, and gray color communities without species at risk. The right panel depicts latitudinal patterns in the number of species predicted to overheat in current climates (blue) or assuming 4°C of global warming above pre-industrial levels (pink). Dashed lines represent the equator and tropics. No species were predicted to experience overheating events in water bodies, and hence are not displayed.


## **Extended data - Figure 5** 

```{r}
# Load data
## Substrate
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

## Arboreal
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")

```


##### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 8}

# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))


# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_sub_future4C, proportion_species_overheating>0), 
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_sub_current, proportion_species_overheating>0),  
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(-0.01, 1)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.text.x = element_text(color = "black", size = 10),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 3))
```


##### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 8}
# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))


# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = proportion_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Proportion of species overheating", 
                       limits=c(0,1)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns

lat_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_arb_future4C, proportion_species_overheating>0), 
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_arb_current, proportion_species_overheating>0),  
             aes(x = lat, y = proportion_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(-0.01, 1)+
  xlab("") +
  ylab("Proportion of species 
overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(color = "black", size = 12),
        axis.text.x = element_text(color = "black", size = 10),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                   map_arb_TSM_future4C + 
                   lat_all + 
                   plot_layout(ncol = 3))
```


##### **All habitats** 

```{r, fig.height=5, fig.width = 15}

all_habitats <- (substrate_plot /
                 arboreal_plot /
                 plot_layout(ncol = 1))

all_habitats

ggsave("fig/Extended_data_figure_5.png", width=14, height=5, dpi = 500)
```

Extended Data Fig. 5 | Proportion of species predicted to experience overheating events in terrestrial (top row) and arboreal (bottom row) microhabitats. The proportion of species overheating was assessed as the sum of species overheating at least once in the period surveyed (warmest quarters of 2006-2015) divided by the number of species in each community (1-degree grid cell). Black color depicts areas with no data, and gray color communities without species at risk. The right panel depicts latitudinal patterns in the proportion of species predicted to overheat in current climates (blue) or assuming 4°C of global warming above pre-industrial levels (pink). Dashed lines represent the equator and tropics. No species were predicted to experience overheating events in water bodies, and hence are not displayed.

# **Supplementary figures** 

## **Fig. S1 - Imputation convergence**

```{r, fig.width = 20, fig.height = 12}
imputed_data <- readRDS("RData/Imputation/results/imputation_5th_cycle.Rds")

imputed_data <- filter(imputed_data, imputed=="yes")

imp_convergence <- 
ggplot(imputed_data) + 
  geom_jitter(aes(x = 1, y = filled_mean_UTL1), 
              alpha = 0.5, 
              size = 3,
              position = position_jitter(width = 0.2, height = 0),
              col = "#ede0d4") + 
  geom_jitter(aes(x = 2, y = filled_mean_UTL2), 
              alpha = 0.5,
              size = 3, 
              position = position_jitter(width = 0.2, height = 0),
              col = "#c9ada7") + 
  geom_jitter(aes(x = 3, y = filled_mean_UTL3), 
              alpha = 0.5, 
              size = 3,
              position = position_jitter(width = 0.2, height = 0),
              col = "#9a8c98") + 
  geom_jitter(aes(x = 4, y = filled_mean_UTL4), 
              alpha = 0.5,
              size = 3,
              position = position_jitter(width = 0.2, height = 0),
              col = "#4a4e69") + 
  geom_jitter(aes(x = 5, y = filled_mean_UTL5), 
              alpha = 0.5,
              size = 3,
              position = position_jitter(width = 0.2, height = 0),
              col = "#373760") + 
  geom_boxplot(aes(x = 1, y = filled_mean_UTL1), 
               notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) + 
  geom_boxplot(aes(x = 2, y = filled_mean_UTL2), 
               notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) + 
  geom_boxplot(aes(x = 3, y = filled_mean_UTL3), 
               notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) + 
  geom_boxplot(aes(x = 4, y = filled_mean_UTL4), 
               notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) + 
  geom_boxplot(aes(x = 5, y = filled_mean_UTL5), 
               notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) +
  xlab("Imputation cycle") +
  ylab("Predicted CTmax") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 45,
                                    margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.title.y = element_text(size = 45,
                                    margin = margin(t = 0, r = 0, b = 0, l = 8)),
        axis.text.x = element_text(size = 25),
        axis.text.y = element_text(size = 25),
        panel.border = element_rect(fill=NA, size = 2))

imp_convergence

ggsave(imp_convergence, file="fig/Figure_S1.png", width=18, height=12, dpi=500)
```

Fig. S1 | Predicted critical thermal maximum (CTmax) across imputation cycles. Boxplots depict median (horizontal line), interquartile ranges (boxes), and whiskers extend to 1.5 times the interquartile range. 


## **Fig. S2 - Predictors of CTmax**

```{r, fig.width = 20, fig.height = 12}
# Load experimental dataset
training_data <- readRDS("RData/General_data/pre_data_for_imputation.rds") %>% 
  rename(CTmax = mean_UTL) %>%  
  filter(imputed == "no")

# Plot predictors used for the imputation 

## Acclimation temperature
acc <- ggplot(training_data) + 
  geom_smooth(aes(y = CTmax, x = acclimation_temp, group = tip.label), 
              method = "lm", 
              se = FALSE, 
              col = "gray35") +
  geom_point(aes(y = CTmax, x = acclimation_temp, col = acclimation_temp),
             alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.1, height= 0)) + 
  scale_colour_viridis(option = "inferno",
                       name = "Acclimation temperature") + 
  xlab("Acclimation temperature (°C)") +
  ylab("CTmax") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

# Duration of acclimation
dur <- ggplot(training_data, 
              aes(y = CTmax, x = log(acclimation_time), col = log(acclimation_time))) + 
  geom_point(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.1, height= 0)) + 
  geom_smooth(method = "lm", se = FALSE, linewidth = 3, col = "gray35") + 
  scale_colour_viridis(option = "magma",
                       name = "Acclimation time") + 
  xlab("Acclimation time (days, log scale)") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

# Ramping rate
ramp <- ggplot(training_data, 
              aes(y = CTmax, x = ramping, col = ramping)) + 
  geom_point(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.1, height= 0)) + 
  geom_smooth(method = "lm", se = FALSE, linewidth = 3, col = "gray35") + 
  scale_colour_viridis(option = "plasma",
                       name = "Ramping rate") + 
  xlab("Ramping rate (°C)") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

## Endpoint
training_data <- mutate(training_data,
                        endpoint = factor(endpoint, 
                       levels=c("LRR", "OS", "LOE", "prodding", "other", "death"),
                       labels=c("LRR", "OS", "LRR", "other", "other", "other"))) # Reorder and regroup
endp <- ggplot(training_data, 
              aes(y = CTmax, x = endpoint, col = endpoint)) + 
  geom_jitter(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.25, height= 0)) + 
  geom_boxplot(notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25) +
  scale_colour_manual(values = c("#e9d8a6", "#e09f3e", "#9e2a2b")) +
  xlab("Endpoint") +
  ylab("CTmax") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

## Medium 
training_data <- mutate(training_data,
                        medium_test_temp = factor(medium_test_temp, 
                        levels=c("body_water", "ambient"),
                        labels=c("body/water", "ambient"))) # Reorder 
medium <- ggplot(filter(training_data, is.na(medium_test_temp)== FALSE), 
              aes(y = CTmax, x = medium_test_temp, col = medium_test_temp),
              na.rm = TRUE) + 
  geom_jitter(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.25, height= 0),
             na.rm = TRUE) + 
  geom_boxplot(notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) +
  scale_colour_manual(values = c("#84a59d", "#f28482")) +
  xlab("Temperature assayed") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

## Life stage of the animals 
training_data <- mutate(training_data,
                       life_stage_tested = factor(life_stage_tested, 
                        levels=c("larvae", "adults"),
                        labels=c("larvae", "adults"))) # Reorder 

lifestage <- ggplot(training_data, 
              aes(y = CTmax, x = life_stage_tested, col = life_stage_tested),
              na.rm = TRUE) + 
  geom_jitter(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.25, height= 0),
             na.rm = TRUE) + 
  geom_boxplot(notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) +
  scale_colour_manual(values = c("#e09f3e", "#4f772d")) +
  xlab("Life stage") +
  ylab("") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

# Ecotype
training_data$ecotype <- factor(training_data$ecotype, levels = c("Aquatic", "Stream-dwelling", "Semi-aquatic", "Ground-dwelling", "Fossorial", "Arboreal"))


ecotype <- ggplot(training_data, 
              aes(y = CTmax, x = ecotype, col = ecotype),
              na.rm = TRUE) + 
  geom_jitter(alpha = 0.5, 
             size = 4, 
             position = position_jitter(width = 0.25, height= 0),
             na.rm = TRUE) + 
  geom_boxplot(notch = TRUE,
               fill = NA,
               col = "black",
               outlier.colour = NA,
               size = 1.25,
               na.rm = TRUE) +
  scale_colour_manual(values = c("#21918c", "#2c728e", "#472d7b", "#F1AF79", "#995C51", "#28ae80")) +
  xlab("Ecotype") +
  ylab("CTmax") +
  theme_classic() +
  theme(legend.position = "none",
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 25),
        axis.title.y = element_text(size = 25),
        axis.text.x = element_text(size = 15),
        axis.text.y = element_text(size = 15),
        panel.border = element_rect(fill=NA, size = 2))

all <- (acc + dur + ramp) / (endp + medium + lifestage) / ecotype

all

ggsave(all, file="fig/Figure_S2.png", width=20, height=18, dpi=500)
```

Fig. S2 | Correlations between critical thermal maximum (CTmax) and predictors used for the imputation. CTmax from the experimental dataset was plotted against acclimation temperature (a), acclimation time (b, log scale), ramping rate (c). Colours are proportional to the values of the continuous predictors and the line refers to predictions from a simple linear regression between CTmax and the predictors. Individual slopes for each species are depicted for species when CTmax was estimated at different acclimation temperatures (a). Depicted is also the variation in CTmax with different endpoints (d), media used to infer body temperature (e), life stages (f), and ecotypes (g). Boxplots depict median (horizontal line), interquartile ranges (boxes), and whiskers extend to 1.5 times the interquartile range. LRR: loss of righting response. OS: onset of spasms. 

## **Fig. S3 - Variation in plasticity**

```{r, fig.width = 20, fig.height = 15}
# Load estimated intercepts and acclimation response ratios
species_ARR <- readRDS("RData/Climate_vulnerability/Pond/current/species_ARR_pond_current.rds")

# Display data
kable(species_ARR, "html") %>% 
  row_spec(0, background = "white", color = "black", bold = TRUE) %>% 
  kable_styling(fixed_thead = T, position = "left", full_width = F) %>%
    scroll_box(width = "100%", height = "500px") 

# Summary statistics 
summary(species_ARR$slope)

species_ARR %>% summarise(ARR = mean(slope), 
                          sd = sd(slope))

# Figure
ggplot(species_ARR) + 
  geom_density(aes(slope), 
               fill = "#CE5B97",
               alpha = 1) + 
  xlab("Acclimation Response Ratio (ARR)") + 
  ylab("Number of species") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

ggsave(file = "fig/Figure_S3.png", width = 20, height = 15, dpi = 500)
```

Fig. S3 | Variation in plastic responses across species. The acclimation response ratio (ARR) represents the magnitude change in heat tolerance limits for each degree change in environmental temperature. The variation in ARR was low (mean ± standard deviation = 0.134 ± 0.008; range = 0.049 – 0.216; n = 5203).

## **Fig. S4 - Community-level patterns in TSM**

Load data
```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds")

# Pond data
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>%
    filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_pond_current)


# Find limits for colours of the plot
tsm_min <- min(min(community_sub_current$community_TSM, na.rm = TRUE),
               min(community_sub_future4C$community_TSM, na.rm = TRUE), 
               min(community_arb_current$community_TSM, na.rm = TRUE),
               min(community_arb_future4C$community_TSM, na.rm = TRUE),
               min(community_pond_current$community_TSM, na.rm = TRUE),
               min(community_pond_future4C$community_TSM, na.rm = TRUE))

tsm_max <- max(max(community_sub_current$community_TSM, na.rm = TRUE),
               max(community_sub_future4C$community_TSM, na.rm = TRUE), 
               max(community_arb_current$community_TSM, na.rm = TRUE),
               max(community_arb_future4C$community_TSM, na.rm = TRUE), 
               max(community_pond_current$community_TSM, na.rm = TRUE),
               max(community_pond_future4C$community_TSM, na.rm = TRUE))
```

###### **Vegetated substrate**

```{r, fig.width = 15, fig.height = 6}
# Current
map_sub_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_sub_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_sub_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_sub_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_current.rds")
pred_community_sub_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future2C.rds")
pred_community_sub_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future4C.rds")

lat_sub_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_sub_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_sub_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_sub_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_sub_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_sub_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1 ) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- (map_sub_TSM_current + 
                   map_sub_TSM_future2C + 
                   map_sub_TSM_future4C + 
                   lat_sub_all + 
                   plot_layout(ncol = 4))
```

###### **Pond or wetland**

```{r, fig.width = 15, fig.height = 6}
# Current
map_pond_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))



# Future +2C 
map_pond_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_pond_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_pond_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_pond_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_current.rds")
pred_community_pond_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future2C.rds")
pred_community_pond_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_substrate_future4C.rds")

lat_pond_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_pond_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_pond_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_pond_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_pond_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black", 
             size = 0.1) + 
  geom_ribbon(data = pred_community_pond_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 12),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

pond_plot <- (map_pond_TSM_current + 
                map_pond_TSM_future2C +
                map_pond_TSM_future4C + 
                lat_pond_all + 
                plot_layout(ncol = 4))
```


###### **Above-ground vegetation**

```{r, fig.width = 15, fig.height = 6}
# Current
map_arb_TSM_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     name = "TSM",
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C 
map_arb_TSM_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 5), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Future +4C
map_arb_TSM_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = community_TSM), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_viridis(name = "TSM",
                     option = "plasma", 
                     na.value = "gray1", 
                     direction = -1, 
                     breaks = seq(0, 40, by = 10), 
                     limits=c(tsm_min, tsm_max), 
                     begin=0, end=1) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "bottom",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
pred_community_arb_current <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_current.rds")
pred_community_arb_future2C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future2C.rds")
pred_community_arb_future4C <- readRDS("RData/Models/TSM/predictions_community_lat_TSM_arboreal_future4C.rds")

lat_arb_all <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = community_arb_future4C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#EF4187",
             shape = ".") + 
  geom_point(data = community_arb_future2C, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = ".") +
  geom_point(data = community_arb_current, 
             aes(x = lat, y = community_TSM), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = ".") +
  geom_ribbon(data = pred_community_arb_current, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#5DC8D9",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future2C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#FAA43A",
             colour = "black",
             size = 0.1) + 
  geom_ribbon(data = pred_community_arb_future4C, 
             aes(x = lat, ymin = lower, ymax = upper),
             fill = "#EF4187",
             colour = "black",
             size = 0.1) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 40)+
  xlab("") +
  ylab("TSM") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 15),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- (map_arb_TSM_current + 
                  map_arb_TSM_future2C + 
                  map_arb_TSM_future4C + 
                  lat_arb_all + 
                  plot_layout(ncol = 4))
```


###### **All habitats** 

```{r, fig.width = 15, fig.height = 7}

fig_S4 <- (substrate_plot/pond_plot/arboreal_plot/plot_layout(ncol = 1))

fig_S4

ggsave(file = "fig/Figure_S4.png", width=15, height=7, dpi = 500)
```

Fig. S4 | Community-level patterns in thermal safety margin for amphibians on terrestrial (top row), aquatic (middle row), or arboreal (bottom row) microhabitats. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature in full shade during the warmest quarters of 2006-2015 in each community (1-degree grid cell). Black color depicts areas with no data. The right panel depicts latitudinal patterns in TSM in current climates (blue) or assuming 2°C (orange) or 4°C of global warming above pre-industrial levels (pink), as predicted from generalized additive mixed models. Dashed lines represent the equator and tropics.

## **Fig. S5 - Number of species overheating** 

### **Load data** 

```{r}
# Substrate data
community_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_clipped_cells.rds")
community_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_clipped_cells.rds")
community_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_clipped_cells.rds") 

# Pond data 
community_pond_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")
community_pond_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")
community_pond_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")

# Above-ground vegetation
community_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/community_vulnerability_arboreal_mean_acc_current_clipped_cells.rds")
community_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/community_vulnerability_arboreal_mean_acc_future2C_clipped_cells.rds")
community_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/community_vulnerability_arboreal_mean_acc_future4C_clipped_cells.rds")


# Upload high resolution Earth data
world <- ne_countries(scale = "large", returnclass = "sf")
world <- world %>% 
  filter(!grepl("Antarctica", name))
st_crs(world) <- st_crs(community_sub_current)
```

#### **Vegetated Substrate** 

```{r, fig.width=15, fig.height=8}
# Set colours
color_palette <- colorRampPalette(colors = c("#FAF218", "#EF4187", "#d90429"))
colors <- color_palette(100)
color_func <- colorRampPalette(c("gray65", colors))
color_palette <- color_func(100)

sp_min <- min(min(community_sub_current$n_species_overheating, na.rm = TRUE),
              min(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              min(community_pond_current$n_species_overheating, na.rm = TRUE),
              min(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              min(community_arb_current$n_species_overheating, na.rm = TRUE),
              min(community_arb_future4C$n_species_overheating, na.rm = TRUE))

sp_max <- max(max(community_sub_current$n_species_overheating, na.rm = TRUE),
              max(community_sub_future4C$n_species_overheating, na.rm = TRUE),
              max(community_pond_current$n_species_overheating, na.rm = TRUE),
              max(community_pond_future4C$n_species_overheating, na.rm = TRUE),
              max(community_arb_current$n_species_overheating, na.rm = TRUE),
              max(community_arb_future4C$n_species_overheating, na.rm = TRUE))

# Substrate (current)
map_sub_sp_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Substrate (Future +2C)
map_sub_sp_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future2C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))

# Substrate (Future +4C)
map_sub_sp_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_sub_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
lat_sub <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_sub_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_sub_future2C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_sub_current, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) + 
  xlim(-55.00099, 72.00064) +
  ylim(0, 84)+
  xlab("") +
  ylab("") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(color = "black", size = 11),        
        axis.line = element_line(color = "black"),
        panel.border = element_rect(fill=NA, size = 2))

substrate_plot <- map_sub_sp_current + 
                  map_sub_sp_future2C + 
                  map_sub_sp_future4C + 
                  lat_sub + 
                  plot_layout(ncol = 4)

```

#### **Above-ground vegetation**

```{r, fig.width=15, fig.height=8}
# Current
map_arb_sp_current <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_current, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#5DC8D9"))

# Future +2C
map_arb_sp_future2C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future2C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 14),
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm"),
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0.1, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#FAA43A"))


# Future +4C
map_arb_sp_future4C <- ggplot() +
  geom_hline(yintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_hline(yintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_sf(data = world, 
          fill = "black",  
          col="black") +
  geom_sf(data = community_arb_future4C, 
          aes(fill = n_species_overheating), 
          color = NA, 
          alpha = 1) +
  coord_sf(ylim = c(-55.00099, 72.00064), 
           xlim = c(-166.82905, 178.56617)) +
  scale_fill_gradientn(colours = color_palette, 
                       na.value = "gray1", 
                       name = "Species overheating", 
                       limits=c(sp_min, sp_max)) +
  theme_void() +
  theme(legend.position = "bottom",
        legend.text = element_text(size = 11),
        legend.title = element_text(size = 14),
        legend.key.height = unit(0.5, "cm"),
        legend.key.width = unit(1, "cm"),
        plot.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        panel.border = element_rect(fill=NA, size = 2, colour = "#EF4187"))

# Latitudinal patterns
lat_arb <- ggplot() +
  geom_vline(xintercept = 0, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = 23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_vline(xintercept = -23.43663, 
             colour = "gray", 
             linetype = "dashed", 
             size = 0.5) +
  geom_point(data = filter(community_arb_future4C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#EF4187",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_arb_future2C, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#FAA43A",
             shape = 15,
             size = 0.5) + 
  geom_point(data = filter(community_arb_current, n_species_overheating>0), 
             aes(x = lat, y = n_species_overheating), 
             alpha = 0.85,
             col = "#5DC8D9",
             shape = 15,
             size = 0.5) +
  xlim(-55.00099, 72.00064) +
  ylim(0, 84)+
  xlab("") +
  ylab("Species overheating") +
  coord_flip() +
  theme_classic() +
  theme(axis.text.y = element_text(color = "black", size = 11),
        aspect.ratio = 1,
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        plot.margin = unit(c(0, 0, 0, 0), "cm"),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 13),
        axis.text.x = element_text(color = "black", size = 11),
        axis.line = element_line(color = "black"),
        legend.text = element_text(size = 15),
        legend.title = element_text(size = 18),
        legend.key.height = unit(0.6, "cm"),
        legend.key.width = unit(0.5, "cm"),
        panel.border = element_rect(fill=NA, size = 2))

arboreal_plot <- map_arb_sp_current + 
                 map_arb_sp_future2C + 
                 map_arb_sp_future4C + 
                 lat_arb + 
                 plot_layout(ncol = 4)
```

#### **Final plot**

```{r, fig.width=14, fig.height=5}

fig_S5   <- (substrate_plot /
             arboreal_plot /
             plot_layout(ncol = 1))

fig_S5

ggsave("fig/Figure_S5.png", width=14, height=4.5, dpi = 500)
```

Fig. S5 | Number of species predicted to experience overheating events in terrestrial (top row) and arboreal (bottom row) microhabitats. The number of species overheating was assessed as the sum of species overheating at least once in the period surveyed (warmest quarters of 2006-2015) in each community (1-degree grid cell). Black color depicts areas with no data, and gray color communities without species at risk. The right panel depicts latitudinal patterns in the number of species predicted to overheat in current climates (blue) or assuming 2°C (orange) or 4°C of global warming above pre-industrial levels (pink). Dashed lines represent the equator and tropics. No species were predicted to experience overheating events in water bodies, and hence are not displayed.

## **Fig. S6 - TSM predictions using different assumptions** 

```{r, fig.width = 16, fig.height = 11}
# Load current data
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Load sensitivity analysis data 
pop_sub_future4C_sens <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_sensitivity_analysis.rds")


# Load current model predictions
pred_sub_future4C <- readRDS("RData/Models/TSM/predictions_pop_lat_TSM_substrate_future4C.rds") # # Load model predictions after removing outliers (temperatures below the 5th and above the 95th percentile body temperatures)
pred_sub_future4C_no_outliers <- readRDS("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_substrate_future4C_without_outliers.rds")
# Load model predictions without averaging (taking TSM as the difference between the 95th percentile body temperature and the corresponding CTmax)
pred_sub_future4C_95th_perc <- readRDS("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_substrate_future4C_95th_percentile.rds")
# Load model predictions without averaging (taking TSM as the difference between the maximum hourly body temperature and the corresponding CTmax; i.e., lowest possible TSM)
pred_sub_future4C_max_temp <- readRDS("RData/Models/TSM/sensitivity_analyses/predictions_pop_lat_TSM_substrate_future4C_max_temp.rds")

# Find limit of the plot
tsm_max <- max(pop_sub_future4C$TSM)
tsm_min <- min(pop_sub_future4C_sens$TSM_extreme)

TSM_sensitivity <- ggplot()+
  geom_point(data = pop_sub_future4C_sens, 
             aes(x = lat, y = TSM_extreme), # No averaging (lowest TSM)
             colour="#bf0603", 
             shape = 20, 
             alpha=0.85,
             size = 3) +
  geom_point(data = pop_sub_future4C_sens,
             aes(x = lat, y = TSM_95), # No averaging (95th percentile)
             colour="#f4d58d", 
             shape = 20, 
             alpha=0.85,
             size = 3) +
  geom_point(data = pop_sub_future4C_sens, 
             aes(x = lat, y = TSM), # Without outliers
             colour="#5DC8D9", 
             shape = 20, 
             alpha=0.85,
             size = 3) +
  geom_point(data = pop_sub_future4C,  
             aes(x = lat, y = TSM),  # Current TSM used in analyses
             colour="#adb5bd", 
             shape = 20, 
             alpha=0.85,
             size = 3) +
  geom_ribbon(data = pred_sub_future4C_max_temp, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#bf0603", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C_95th_perc, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#f4d58d", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C_no_outliers, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#5DC8D9", 
              colour="black") +
  geom_ribbon(data = pred_sub_future4C, 
              aes(x = lat, ymin = lower, ymax = upper), 
              fill="#adb5bd", 
              colour="black") +
  geom_hline(yintercept = 0, linetype = "dashed", size = 1.5) + 
  xlab("Latitude") +
  ylab("Thermal safety margin") +
  ylim(tsm_min, tsm_max) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064)) +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour = NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 30),
        axis.title.y = element_text(size = 30),
        axis.text.x = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 20, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))

TSM_sensitivity 

ggsave("fig/Figure_S6.png", width=16, height=11, dpi = 500)
```

Fig. S6 | Variation in thermal safety margin calculated using different assumptions. Thermal safety margins (TSM) were calculated as the mean difference between CTmax and the predicted operative body temperature in full shade during the warmest quarters of 2006-2015 (grey colour), as the mean difference between CTmax and the predicted operative body temperature in full shade during the warmest quarters of 2006-2015 excluding body temperatures falling outside the 5% and 95% percentile temperatures (blue), as the difference between the 95% percentile operative body temperature and the corresponding CTmax (yellow), or as the difference between the maximum operative body temperature and the corresponding CTmax (red). Lines represented 95% confidence interval ranges predicted from generalized additive mixed models. This figure was constructed assuming ground-level microclimates occurring under 4°C of global warming above pre-industrial levels.

## **Fig. S7 - Number of overheating events - acclimation with maximum temperatures** 

### **Load data** 
```{r}
# Vegetated substrate (acclimation to the mean weekly temperature)
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Arboreal conditions (acclimation to the mean weekly temperature)
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

# Vegetated substrate (acclimation to the max weekly temperature)
pop_sub_current_max <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_max_acc_current.rds")
pop_sub_future2C_max <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_max_acc_future2C.rds")
pop_sub_future4C_max <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_max_acc_future4C.rds")

# Arboreal conditions (acclimation to the max weekly temperature)
pop_arb_current_max <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_max_acc_current.rds")
pop_arb_future2C_max <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_max_acc_future2C.rds")
pop_arb_future4C_max <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_max_acc_future4C.rds")


# Find limits for colours of the plot
days_min <- min(min(pop_sub_current$overheating_days, na.rm = TRUE), 
               min(pop_sub_future4C$overheating_days, na.rm = TRUE),
               min(pop_arb_current$overheating_days, na.rm = TRUE), 
               min(pop_arb_future4C$overheating_days, na.rm = TRUE),
               min(pop_sub_current_max$overheating_days, na.rm = TRUE), 
               min(pop_sub_future4C_max$overheating_days, na.rm = TRUE),
               min(pop_arb_current_max$overheating_days, na.rm = TRUE), 
               min(pop_arb_future4C_max$overheating_days, na.rm = TRUE))

days_max <- max(max(pop_sub_current$overheating_days, na.rm = TRUE), 
               max(pop_sub_future4C$overheating_days, na.rm = TRUE),
               max(pop_arb_current$overheating_days, na.rm = TRUE), 
               max(pop_arb_future4C$overheating_days, na.rm = TRUE),
               max(pop_sub_current_max$overheating_days, na.rm = TRUE), 
               max(pop_sub_future4C_max$overheating_days, na.rm = TRUE),
               max(pop_arb_current_max$overheating_days, na.rm = TRUE), 
               max(pop_arb_future4C_max$overheating_days, na.rm = TRUE))
```

### **Acclimation to the mean weekly temperature - Substrate** 

```{r}
n_days_sub <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Acclimation to the max weekly temperature - Substrate** 

```{r}
n_days_sub_max <- ggplot()+
  geom_point(data = filter(pop_sub_future4C_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


### **Acclimation to the mean weekly temperature - Above-ground vegetation** 

```{r}
n_days_arb <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Acclimation to the max weekly temperature - Above-ground vegetation** 

```{r}
n_days_arb_max <- ggplot()+
  geom_point(data = filter(pop_arb_future4C_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current_max, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Combine plots** 

```{r, fig.width = 16, fig.height = 12}
fig_S7  <- (n_days_sub | n_days_sub_max) /
           (n_days_arb | n_days_arb_max) 

fig_S7

ggsave("fig/Figure_S7.png", width=16, height=12, dpi = 500)
```

Fig. S7 | Latitudinal variation in the number of overheating events when animals are acclimated to the mean (left column) or maximum weekly body temperature experienced in the seven days prior (right column) in terrestrial (top row) and arboreal (bottom row) microhabitats. The number of overheating events (days) were calculated as the sum of overheating events (when daily maximum temperatures exceed CTmax) during the warmest quarters of 2006-2015 for each population. Blue points depict the number of overheating events in historical microclimates, while orange and pink points depict the number of overheating events assuming 2°C and 4°C of global warming above pre-industrial levels, respectively. For clarity, only the populations predicted to experience overheating events across latitudes are depicted.

## **Fig. S8 - Number of overheating events - temperatures not overlapping with 50% of the distribution of CTmax**

### **Load data** 
```{r}
# Vegetated substrate (acclimation to the mean weekly temperature)
pop_sub_current <- readRDS("RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current.rds")
pop_sub_future2C <- readRDS("RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C.rds")
pop_sub_future4C <- readRDS("RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C.rds")

# Arboreal conditions (acclimation to the mean weekly temperature)
pop_arb_current <- readRDS("RData/Climate_vulnerability/Arboreal/current/population_vulnerability_arboreal_mean_acc_current.rds")
pop_arb_future2C <- readRDS("RData/Climate_vulnerability/Arboreal/future2C/population_vulnerability_arboreal_mean_acc_future2C.rds")
pop_arb_future4C <- readRDS("RData/Climate_vulnerability/Arboreal/future4C/population_vulnerability_arboreal_mean_acc_future4C.rds")

# Find limits for colours of the plot
days_min <- min(min(pop_sub_current$overheating_days, na.rm = TRUE), 
               min(pop_sub_future4C$overheating_days, na.rm = TRUE),
               min(pop_arb_current$overheating_days, na.rm = TRUE), 
               min(pop_arb_future4C$overheating_days, na.rm = TRUE))

days_max <- max(max(pop_sub_current$overheating_days, na.rm = TRUE), 
               max(pop_sub_future4C$overheating_days, na.rm = TRUE),
               max(pop_arb_current$overheating_days, na.rm = TRUE), 
               max(pop_arb_future4C$overheating_days, na.rm = TRUE))
```

### **Regular estimates - Substrate** 

```{r}
n_days_sub <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Strict estimates 50% - Substrate** 

```{r}
n_days_sub_strict <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Strict estimates 95% - Substrate** 

```{r}
n_days_sub_strict95 <- ggplot()+
  geom_point(data = filter(pop_sub_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_sub_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```


### **Regular estimates - Above-ground vegetation** 

```{r}
n_days_arb <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Strict estimates 50% - Above-ground vegetation** 

```{r}
n_days_arb_strict <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict50), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Strict estimates 95% - Above-ground vegetation** 

```{r}
n_days_arb_strict95 <- ggplot()+
  geom_point(data = filter(pop_arb_future4C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#EF4187", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_future2C, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#FAA43A", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  geom_point(data = filter(pop_arb_current, overheating_days > 0), 
             aes(x = lat, y = overheating_days_strict95), 
             fill="#5DC8D9", 
             shape = 21, 
             alpha=0.85, 
             size = 3.5, 
             position = position_jitter(width=0.35, height=0.35)) +
  scale_x_continuous(breaks = c(-50, -25, 0, 25, 50), 
                     limits = c(-55.00099, 72.00064))+
  ylim(-0.35, days_max+0.35) +
  xlab("Latitude") +
  ylab("Number of overheating days") +
  theme_classic() +
  theme(legend.position = "none",
        plot.background = element_rect(fill = "transparent", colour=NA),
        panel.background = element_rect(fill = "transparent", colour = NA),
        text = element_text(color = "black"),
        axis.title.x = element_text(size = 35),
        axis.title.y = element_blank(),
        axis.text.x = element_text(color = "black", 
                                   size = 25,
                                   margin = margin(t = 8, r = 0, b = 0, l = 0)),
        axis.text.y = element_text(color = "black", 
                                   size = 25, 
                                   margin = margin(t = 0, r = 10, b = 0, l = 0)),
        panel.border = element_rect(fill=NA, size = 3))
```

### **Combine plots** 

```{r, fig.width = 20, fig.height = 12}
fig_S8  <- (n_days_sub | n_days_sub_strict | n_days_sub_strict95) /
           (n_days_arb | n_days_arb_strict | n_days_arb_strict95) 

fig_S8

ggsave("fig/Figure_S8.png", width=20, height=12, dpi = 500)
```

Fig. S8 | Latitudinal variation in the number of overheating events using regular (left column) or conservative estimates (right column) in terrestrial (top row) and arboreal (bottom row) microhabitats. The number of overheating events (days) were calculated as the sum of overheating events (when daily maximum temperatures exceed CTmax) during the warmest quarters of 2006-2015 for each population. Conservative estimates are those where overheating events were counted only when operative body temperatures exceeded 50% of the predicted distribution of CTmax. Blue points depict the number of overheating events in historical microclimates, while orange and pink points depict the number of overheating events assuming 2°C and 4°C of global warming above pre-industrial levels, respectively. For clarity, only the populations predicted to experience overheating events across latitudes are depicted.

## **Fig. S9 - Terrestrial biophysical models with different parameters**

```{r, fig.height = 20, fig.width = 16}
# Open habitats and burrows
habitat_selection <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_open, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "red") + 
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "2.5cm"), 
               aes(x=daily_TSM), 
               fill = "gold", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "5cm"), 
               aes(x=daily_TSM), 
               fill = "#BA9E49", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "10cm"), 
               aes(x=daily_TSM), 
               fill = "darkorange", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "15cm"), 
               aes(x=daily_TSM), 
               fill = "#F1AF79", 
               alpha = 0.7) +
  geom_density(data = filter(daily_vulnerability_burrow, DEPTH == "20cm"), 
               aes(x=daily_TSM), 
               fill = "#995C51", 
               alpha = 0.7) +
  geom_density(data = daily_vulnerability, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-6.5, 5) + 
  ylim(0, 1.05) +
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))


# Body size
body_size <- 
ggplot()+ 
  geom_density(data = daily_vulnerability_small, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#49BAAE") + 
  geom_density(data = daily_vulnerability_large, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#BA4989") +
  geom_density(data = daily_vulnerability, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))


terrestrial_parameters <- body_size / habitat_selection 

terrestrial_parameters

ggsave(terrestrial_parameters, file = "fig/Figure_S9.png", height = 20, width=16, dpi = 500)
```

Fig. S9 | Influence of biophysical model parameters on the estimation of terrestrial thermal safety margins. Depicted is the variation in daily thermal safety margins (TSM) as density distributions according to body mass (a), shade availability and soil depth (b). All simulations were performed assuming 4°C of global warming above pre-industrial levels in a specific grid cell (latitude, longitude = -9.5, -69.5; where the highest number of overheating events was predicted), for the most vulnerable species (Noblella myrmecoides). Negative daily TSMs were recorded as overheating events, and conditions depicted in dark grey reflect the results presented in the manuscript.

## **Fig. S10 - Aquatic biophysical models with different parameters**
```{r, fig.height = 10, fig.width = 12}
aquatic_parameters <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_pond_shallow, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "lightblue") + 
  geom_density(data = daily_vulnerability_pond_deep, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "darkblue") +
  geom_density(data = daily_vulnerability_pond, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 6) + 
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

aquatic_parameters

ggsave(aquatic_parameters, file = "fig/Figure_S10.png", height = 10, width=12, dpi = 500)
```

Fig. S10 | Influence of pond depth on the estimation of aquatic thermal safety margins. All simulations were performed assuming 4°C of global warming above pre-industrial levels in a specific grid cell (latitude, longitude = -9.5, -69.5; where the highest number of overheating events was predicted), for the most vulnerable species (Noblella myrmecoides). Depicted is the variation in daily thermal safety margins (TSM) as density distributions. Negative daily TSMs were recorded as overheating events, and conditions depicted in dark grey reflect the results presented in the manuscript. 

## **Fig. S11 - Arboreal biophysical models with different parameters**
```{r, fig.height = 30, fig.width = 18}
# Plant height
plant_height <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_tall, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "darkgreen") + 
  geom_density(data = daily_vulnerability_arb_short, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "lightgreen") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

# Diffusion of solar radiation
plant_solar_rad <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_low_diff, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#cc4778") + 
  geom_density(data = daily_vulnerability_arb_mid_diff, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#7e03a8") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

# Wind reduction
plant_wind_reduc <- 
  ggplot()+ 
  geom_density(data = daily_vulnerability_arb_no_wind, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#BA4953") + 
  geom_density(data = daily_vulnerability_arb_high_wind, 
               aes(x=daily_TSM), 
               alpha = 0.5, 
               fill = "#49BAAE") +
  geom_density(data = daily_vulnerability_arb, 
               aes(x=daily_TSM), 
               alpha = 0.6, 
               fill = "black") + 
  geom_vline(xintercept = 0, colour = "black", lwd = 1, alpha = 0.75) + 
  xlim(-5, 5) + 
  xlab("Daily TSM") + 
  ylab("Density") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.x = element_text(size = 50, margin = margin(t = 40, r = 0, b = 0, l = 0)), 
        axis.title.y = element_text(size = 50, margin = margin(t = 0, r = 40, b = 0, l = 0)), 
        axis.text.x = element_text(size = 40, margin = margin(t = 20, r = 0, b = 0, l = 0)), 
        axis.text.y = element_text(size = 40, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        panel.border = element_rect(fill = NA, size = 2))

arboreal_parameters <- plant_height / plant_solar_rad / plant_wind_reduc

arboreal_parameters

ggsave(arboreal_parameters, file = "fig/Figure_S11.png", height = 30, width=18, dpi = 500)
```
Fig. S11 | Influence of biophysical parameters on the estimation of aquatic arboreal safety margins. All simulations were performed assuming 4°C of global warming above pre-industrial levels in a specific grid cell (latitude, longitude = -9.5, -69.5; where the highest number of overheating events was predicted), for the most vulnerable arboreal species (Pristimantis ockendeni). Depicted is the variation in daily thermal safety margins (TSM) as density distributions according to height of the animal in above-ground vegetation (a), the percentage of solar radiation diffused by vegetation (b) and the percentage of wind reduced by vegetation (c). Negative daily TSMs were recorded as overheating events, and conditions depicted in dark grey reflect the results presented in the manuscript. 

## **Fig. S12 - Validation of field body temperatures**
```{r, fig.height = 15, fig.width = 11}
# For details on how to generate the data used in these plots, see **Validation of operative body temperature estimates** in **Sensitivity analyses**

first_site <- 
ggplot() +
  # Add a "ribbon" to represent the range from Min to Max
  geom_rect(data = stats_2013, aes(xmin = x_limits[1], xmax = x_limits[2], ymin = Min, ymax = Max),
            fill = "grey80", alpha = 0.5) +
  # Add a line for the Mean
  geom_hline(data = stats_2015, aes(yintercept = Mean), color = "black", size = 1) +
  geom_pointrange(data = Tb_jittered, aes(x = x_jitter, y = Mean, ymin = Min, ymax = Max, col = Species),
                  size = 1, linewidth = 1) + 
  scale_x_continuous(name = "", labels = NULL, breaks = NULL) +  # This line is duplicated in your code; you only need it once
  theme_classic() + 
  xlab("") + 
  ylab("Temperature (°C)") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.y = element_text(size = 40, margin = margin(t = 0, r = 30, b = 0, l = 0)), 
        axis.text.y = element_text(size = 30, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        legend.text = element_text(size = 15, face = "italic"),
        legend.title = element_text(size = 18),
        panel.border = element_rect(fill = NA, size = 2))

second_site <- 
ggplot() +
  # Add a "ribbon" to represent the range from Min to Max
  geom_rect(data = stats_2013_CD, aes(xmin = x_limits[1], xmax = x_limits[2], ymin = Min, ymax = Max),
            fill = "grey80", alpha = 0.5) +
  # Add a line for the Mean
  geom_hline(data = stats_2013_CD, aes(yintercept = Mean), color = "black", size = 1) +
  geom_pointrange(data = Tb_jittered_CD, aes(x = x_jitter, y = Mean, ymin = Min, ymax = Max, col = Species),
                  size = 1, linewidth = 1) + 
  scale_x_continuous(name = "", labels = NULL, breaks = NULL) +  # This line is duplicated in your code; you only need it once
  theme_classic() + 
  xlab("") + 
  ylab("Temperature (°C)") + 
  theme_classic() + 
  theme(text = element_text(color = "black"),
        axis.title.y = element_text(size = 40, margin = margin(t = 0, r = 30, b = 0, l = 0)), 
        axis.text.y = element_text(size = 30, margin = margin(t = 0, r = 20, b = 0, l = 0)), 
        legend.text = element_text(size = 15, face = "italic"),
        legend.title = element_text(size = 18),
        panel.border = element_rect(fill = NA, size = 2))

validation_OBT <- first_site / second_site

validation_OBT

ggsave(validation_OBT, file = "fig/Figure_S12.png", height = 15, width = 11, dpi = 500)
```


# **Package versions** 

```{r}
sessionInfo()
```

