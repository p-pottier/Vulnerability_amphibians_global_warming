
pacman::p_load(devtools,
               tidyverse,
               purrr,
               parallel,
               doParallel,
               abind,
               curl,
               zoo,
               data.table,
               metafor,
               future,
               furrr,
               future.apply,
               parallel)

# Set the seed for reproducibility
set.seed(123)

##############################################################################################################
############### Acclimation to mean weekly temperature in terrestrial conditions, current climate ######################

daily_CTmax_mean_current <- readRDS(file="RData/Climate_vulnerability/Substrate/current/daily_CTmax_substrate_mean_acc_current.rds")

# Assign a maximum se for observations with very large error. 
# This is capped to the "biological range" of CTmax, defined as the standard deviation of CTmax estimates across species.
# Note that this may overestimate overheating probabilities in some cases.
cap_se <- sd(daily_CTmax_mean_current$predicted_CTmax)

# Function to calculate overheating probability and SE
calculate_overheating_probability <- function(predicted_CTmax, predicted_CTmax_se, max_temp) {
  capped_se <- min(predicted_CTmax_se, cap_se)  # Take the predicted SE if under the capped SE
  prob_overheating <- pnorm(max_temp, mean = predicted_CTmax, sd = capped_se) # Probability that max temp exceeds CTmax distribution
  return(list(prob_overheating = prob_overheating))
}

###### Daily TSM and overheating risk ##########
daily_vulnerability_mean_current <- daily_CTmax_mean_current %>%
  rowwise() %>%
  mutate(overheating_result = list(calculate_overheating_probability(predicted_CTmax, predicted_CTmax_se, max_temp)), # Apply function
         overheating_prob = overheating_result$prob_overheating, # retrieve overheating probability
         overheating_day = ifelse(overheating_prob>0.5, 1, 0), # Consider overheating day when overheating probability > 0.5
         daily_TSM = predicted_CTmax - max_temp, # calculate TSM
         daily_TSM_se = predicted_CTmax_se) %>% 
  ungroup() %>% 
  dplyr::select(-overheating_result)


# Number of consecutive days of overheating
daily_consecutive_mean_current <- daily_vulnerability_mean_current %>%  
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })

# Set number of days
n_days <- 910

rm(daily_CTmax_mean_current)

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_current <- daily_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    # Mean max temp and SE
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Combine daily overheating probabilities for each population
    overheating_probability = mean(overheating_prob),
    overheating_probability_se = sqrt(overheating_probability * (1 - overheating_probability)),
    .groups = 'drop'
  ) %>%
  rowwise() %>%
  mutate(
    overheating_days = n_days * overheating_probability,
    overheating_days_se = sqrt(n_days * overheating_probability * (1 - overheating_probability)), # SE in overheating days
    overheating_risk = ifelse(overheating_days >= 1, 1, 0), # Overheating risk when overheating days >= 1
    lower_CI = overheating_days - (1.96 * overheating_days_se), 
    overheating_risk_strict = ifelse(lower_CI > 0, 1, 0) # Conservative estimates when 95% CI don't overlap with zero
  ) %>%
  ungroup() %>% 
  dplyr::select(-lower_CI)

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_current)

## Calculate number of consecutive overheating days
consecutive_overheating_days_current <- daily_consecutive_mean_current %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_current)

pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  left_join(consecutive_overheating_days_current, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_current)

## Add original coordinates
pop_vulnerability_mean_current  <- pop_vulnerability_mean_current %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_current <- left_join(pop_vulnerability_mean_current, distinct_coord, by="lon_lat")
pop_vulnerability_mean_current <- pop_vulnerability_mean_current %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_current, file="RData/Climate_vulnerability/Substrate/current/population_vulnerability_substrate_mean_acc_current_large_se.rds")

######## Community-level patterns ################

community_vulnerability_mean_current <- pop_vulnerability_mean_current %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Conservative metrics for sensitivity analysis
    n_species_overheating_strict = sum(overheating_risk_strict), 
    proportion_species_overheating_strict = if_else(n() == 1, first(overheating_risk_strict), mean(overheating_risk_strict)), 
    proportion_species_overheating_se_strict = if_else(n() == 1, 0, sd(overheating_risk_strict)),  
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_current)

saveRDS(community_vulnerability_mean_current, file="RData/Climate_vulnerability/Substrate/current/community_vulnerability_substrate_mean_acc_current_large_se.rds")

rm(community_vulnerability_mean_current)


###################################################################################################################
############### Acclimation to mean weekly temperature in terrestrial conditions, future climate (+2C) ######################

daily_CTmax_mean_2C <- readRDS(file="RData/Climate_vulnerability/Substrate/future2C/daily_CTmax_substrate_mean_acc_future2C.rds")

# Assign a maximum se for observations with very large error. 
# This is capped to the "biological range" of CTmax, defined as the standard deviation of CTmax estimates across species.
# Note that this may overestimate overheating probabilities in some cases.
cap_se <- sd(daily_CTmax_mean_2C$predicted_CTmax)

# Function to calculate overheating probability and SE
calculate_overheating_probability <- function(predicted_CTmax, predicted_CTmax_se, max_temp) {
  capped_se <- min(predicted_CTmax_se, cap_se)  # Take the predicted SE if under the capped SE
  prob_overheating <- pnorm(max_temp, mean = predicted_CTmax, sd = capped_se) # Probability that max temp exceeds CTmax distribution
  return(list(prob_overheating = prob_overheating))
}

###### Daily TSM and overheating risk ##########
daily_vulnerability_mean_2C <- daily_CTmax_mean_2C %>%
  rowwise() %>%
  mutate(overheating_result = list(calculate_overheating_probability(predicted_CTmax, predicted_CTmax_se, max_temp)), # Apply function
         overheating_prob = overheating_result$prob_overheating, # retrieve overheating probability
         overheating_day = ifelse(overheating_prob>0.5, 1, 0), # Consider overheating day when overheating probability > 0.5
         daily_TSM = predicted_CTmax - max_temp, # calculate TSM
         daily_TSM_se = predicted_CTmax_se) %>% 
  ungroup() %>% 
  dplyr::select(-overheating_result)


# Number of consecutive days of overheating
daily_consecutive_mean_2C <- daily_vulnerability_mean_2C %>%  
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })

# Set number of days
n_days <- 910

rm(daily_CTmax_mean_2C)

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_2C <- daily_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    # Mean max temp and SE
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Combine daily overheating probabilities for each population
    overheating_probability = mean(overheating_prob),
    overheating_probability_se = sqrt(overheating_probability * (1 - overheating_probability)),
    .groups = 'drop'
  ) %>%
  rowwise() %>%
  mutate(
    overheating_days = n_days * overheating_probability,
    overheating_days_se = sqrt(n_days * overheating_probability * (1 - overheating_probability)), # SE in overheating days
    overheating_risk = ifelse(overheating_days >= 1, 1, 0), # Overheating risk when overheating days >= 1
    lower_CI = overheating_days - (1.96 * overheating_days_se), 
    overheating_risk_strict = ifelse(lower_CI > 0, 1, 0) # Conservative estimates when 95% CI don't overlap with zero
  ) %>%
  ungroup() %>% 
  dplyr::select(-lower_CI)

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_2C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_2C <- daily_consecutive_mean_2C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_2C)

pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  left_join(consecutive_overheating_days_2C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_2C)

## Add original coordinates
pop_vulnerability_mean_2C  <- pop_vulnerability_mean_2C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_2C <- left_join(pop_vulnerability_mean_2C, distinct_coord, by="lon_lat")
pop_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_2C, file="RData/Climate_vulnerability/Substrate/future2C/population_vulnerability_substrate_mean_acc_future2C_large_se.rds")

######## Community-level patterns ################

community_vulnerability_mean_2C <- pop_vulnerability_mean_2C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Conservative metrics for sensitivity analysis
    n_species_overheating_strict = sum(overheating_risk_strict), 
    proportion_species_overheating_strict = if_else(n() == 1, first(overheating_risk_strict), mean(overheating_risk_strict)), 
    proportion_species_overheating_se_strict = if_else(n() == 1, 0, sd(overheating_risk_strict)),  
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_2C)

saveRDS(community_vulnerability_mean_2C, file="RData/Climate_vulnerability/Substrate/future2C/community_vulnerability_substrate_mean_acc_future2C_large_se.rds")

rm(community_vulnerability_mean_2C)


###################################################################################################################
############### Acclimation to mean weekly temperature in terrestrial conditions, future climate (+4C) ######################


daily_CTmax_mean_4C <- readRDS(file="RData/Climate_vulnerability/Substrate/future4C/daily_CTmax_substrate_mean_acc_future4C.rds")

# Assign a maximum se for observations with very large error. 
# This is capped to the "biological range" of CTmax, defined as the standard deviation of CTmax estimates across species.
# Note that this may overestimate overheating probabilities in some cases.
cap_se <- sd(daily_CTmax_mean_4C$predicted_CTmax)

# Function to calculate overheating probability and SE
calculate_overheating_probability <- function(predicted_CTmax, predicted_CTmax_se, max_temp) {
  capped_se <- min(predicted_CTmax_se, cap_se)  # Take the predicted SE if under the capped SE
  prob_overheating <- pnorm(max_temp, mean = predicted_CTmax, sd = capped_se) # Probability that max temp exceeds CTmax distribution
  return(list(prob_overheating = prob_overheating))
}

###### Daily TSM and overheating risk ##########
daily_vulnerability_mean_4C <- daily_CTmax_mean_4C %>%
  rowwise() %>%
  mutate(overheating_result = list(calculate_overheating_probability(predicted_CTmax, predicted_CTmax_se, max_temp)), # Apply function
         overheating_prob = overheating_result$prob_overheating, # retrieve overheating probability
         overheating_day = ifelse(overheating_prob>0.5, 1, 0), # Consider overheating day when overheating probability > 0.5
         daily_TSM = predicted_CTmax - max_temp, # calculate TSM
         daily_TSM_se = predicted_CTmax_se) %>% 
  ungroup() %>% 
  dplyr::select(-overheating_result)


# Number of consecutive days of overheating
daily_consecutive_mean_4C <- daily_vulnerability_mean_4C %>%  
  # Arrange by day and year
  group_by(tip.label, lon, lat, YEAR) %>%
  arrange(DOY) %>%
  # Calculate consecutive days of overheating
  mutate(consecutive_overheating_day = {
    rle_run <- rle(overheating_day)
    rep(rle_run$lengths * rle_run$values, times = rle_run$lengths)
  })

# Set number of days
n_days <- 910

rm(daily_CTmax_mean_4C)

########## Climate vulnerability metrics at the population-level  ###########
pop_vulnerability_mean_4C <- daily_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(daily_TSM_se^2),
         CTmax_weights = 1/(predicted_CTmax_se^2)) %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(
    # Mean CTmax and maximum temperature (weighted average and SE)
    CTmax = sum(predicted_CTmax * CTmax_weights)/sum(CTmax_weights), 
    CTmax_se = sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2))))),
    # Mean max temp and SE
    mean_max_temp = mean(max_temp),
    max_temp_se = sd(max_temp),
    # Mean TSM (weighted average and SE)
    TSM = sum(daily_TSM * TSM_weights)/sum(TSM_weights), 
    TSM_se = sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2))))),
    # Combine daily overheating probabilities for each population
    overheating_probability = mean(overheating_prob),
    overheating_probability_se = sqrt(overheating_probability * (1 - overheating_probability)),
    .groups = 'drop'
  ) %>%
  rowwise() %>%
  mutate(
    overheating_days = n_days * overheating_probability,
    overheating_days_se = sqrt(n_days * overheating_probability * (1 - overheating_probability)), # SE in overheating days
    overheating_risk = ifelse(overheating_days >= 1, 1, 0), # Overheating risk when overheating days >= 1
    lower_CI = overheating_days - (1.96 * overheating_days_se), 
    overheating_risk_strict = ifelse(lower_CI > 0, 1, 0) # Conservative estimates when 95% CI don't overlap with zero
  ) %>%
  ungroup() %>% 
  dplyr::select(-lower_CI)

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% rename(max_temp = mean_max_temp)

rm(daily_vulnerability_mean_4C)

## Calculate number of consecutive overheating days
consecutive_overheating_days_4C <- daily_consecutive_mean_4C %>% 
  group_by(tip.label, lon, lat) %>%
  summarise(consecutive_overheating_days = max(consecutive_overheating_day),
            .groups = 'drop')

rm(daily_consecutive_mean_4C)

pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  left_join(consecutive_overheating_days_4C, by = c("tip.label", "lon", "lat"))

rm(consecutive_overheating_days_4C)

## Add original coordinates
pop_vulnerability_mean_4C  <- pop_vulnerability_mean_4C %>% 
  rename(lon_adj = lon, lat_adj = lat) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) 

distinct_coord <- readRDS("RData/General_data/distinct_coordinates_adjusted.rds")
distinct_coord <- distinct_coord %>% 
  dplyr::select(lon_adj = lon, lat_adj = lat, lon = x, lat = y) %>% 
  mutate(lon_lat = paste(lon_adj, lat_adj)) %>% 
  dplyr::select(-lon_adj, -lat_adj)

pop_vulnerability_mean_4C <- left_join(pop_vulnerability_mean_4C, distinct_coord, by="lon_lat")
pop_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>% 
  dplyr::select(-lon_lat)

saveRDS(pop_vulnerability_mean_4C, file="RData/Climate_vulnerability/Substrate/future4C/population_vulnerability_substrate_mean_acc_future4C_large_se.rds")

######## Community-level patterns ################

community_vulnerability_mean_4C <- pop_vulnerability_mean_4C %>%
  mutate(TSM_weights = 1/(TSM_se^2),
         CTmax_weights = 1/(CTmax_se^2)) %>%
  group_by(lon, lat) %>%
  summarise(# ifelse statement is used here because in some locations, only one species is present.
    # Mean CTmax and maximum temperature at the community-level (weighted average and SE)
    community_CTmax = if_else(n() == 1, first(CTmax), sum(CTmax * CTmax_weights)/sum(CTmax_weights)), 
    community_CTmax_se = if_else(n() == 1, first(CTmax_se), sqrt(sum(CTmax_weights) * (n() - 1) / (((sum(CTmax_weights)^2) - (sum(CTmax_weights^2)))))),
    community_max_temp = first(max_temp),  
    community_max_temp_se = first(max_temp_se), 
    # Mean TSM (weighted average and SE)
    community_TSM = if_else(n() == 1, first(TSM), sum(TSM * TSM_weights)/sum(TSM_weights)), 
    community_TSM_se = if_else(n() == 1, first(TSM_se), sqrt(sum(TSM_weights) * (n() - 1) / (((sum(TSM_weights)^2) - (sum(TSM_weights^2)))))),
    # Number of species
    n_species = n_distinct(tip.label), 
    # Number of species overheating
    n_species_overheating = sum(overheating_risk), 
    # Proportion of species overheating
    proportion_species_overheating = if_else(n() == 1, first(overheating_risk), mean(overheating_risk)), 
    proportion_species_overheating_se = if_else(n() == 1, 0, sd(overheating_risk)),
    # Conservative metrics for sensitivity analysis
    n_species_overheating_strict = sum(overheating_risk_strict), 
    proportion_species_overheating_strict = if_else(n() == 1, first(overheating_risk_strict), mean(overheating_risk_strict)), 
    proportion_species_overheating_se_strict = if_else(n() == 1, 0, sd(overheating_risk_strict)),  
    .groups = 'drop'
  )

rm(pop_vulnerability_mean_4C)

saveRDS(community_vulnerability_mean_4C, file="RData/Climate_vulnerability/Substrate/future4C/community_vulnerability_substrate_mean_acc_future4C_large_se.rds")
