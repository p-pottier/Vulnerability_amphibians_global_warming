pacman::p_load(tidyverse,
               cowplot,
               viridis,
               sf,
               rnaturalearth,
               rnaturalearthdata,
               rnaturalearthhires,
               lwgeom,
               ggspatial,
               scales,
               parallel)


community_df_max_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_current), function(i) {
  row <- community_df_max_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_max_acc_current_clipped_cells.rds")



################################# Do the same for the future climate #########################

community_df_max_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future2C), function(i) {
  row <- community_df_max_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_max_acc_future2C_clipped_cells.rds")

################

community_df_max_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_max_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_max_future4C), function(i) {
  row <- community_df_max_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_max_acc_future4C_clipped_cells.rds")




################################# Do the same for mean current #########################

community_df_mean_current <- readRDS("RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_current", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_current), function(i) {
  row <- community_df_mean_current[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/current/community_vulnerability_pond_mean_acc_current_clipped_cells.rds")


################################# Do the same for mean future 2C #########################

community_df_mean_future2C <- readRDS("RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future2C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future2C), function(i) {
  row <- community_df_mean_future2C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future2C/community_vulnerability_pond_mean_acc_future2C_clipped_cells.rds")



################################# Do the same for mean future 4C #########################

community_df_mean_future4C <- readRDS("RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C.rds")

# Create land polygon
world_sf <- ne_countries(scale = "large", returnclass = "sf")
world_sf$geometry <- st_make_valid(world_sf$geometry)
land_polygon <- st_union(world_sf)


# Loop to create the clipped grid cells and keep the geometry column
create_grid_cell_polygon <- function(lon, lat, dx = 0.5, dy = 0.5) {
  cell_polygon <- st_polygon(list(matrix(c(lon - dx, lat - dy,
                                           lon + dx, lat - dy,
                                           lon + dx, lat + dy,
                                           lon - dx, lat + dy,
                                           lon - dx, lat - dy), ncol = 2, byrow = TRUE)))
  cell_sf <- st_sf(geometry = st_sfc(cell_polygon))
  st_set_crs(cell_sf, st_crs(land_polygon))
}

cl <- makeCluster(16)
clusterExport(cl, c("community_df_mean_future4C", "land_polygon", "create_grid_cell_polygon"))
clusterEvalQ(cl, {
  library(tidyverse)
  library(sf)
  library(rnaturalearth)
  library(rnaturalearthhires)
  library(lwgeom)
  library(ggspatial)
})

clipped_grid_cells_list <- parLapply(cl, 1:nrow(community_df_mean_future4C), function(i) {
  row <- community_df_mean_future4C[i, ]
  cell_polygon <- create_grid_cell_polygon(row$lon, row$lat)
  clipped_cell <- st_intersection(cell_polygon, land_polygon)
  
  if (nrow(clipped_cell) > 0) {  # check that clipped_cell is not an empty sf data frame
    clipped_cell$lon <- row$lon
    clipped_cell$lat <- row$lat
    clipped_cell$community_CTmax <- row$community_CTmax
    clipped_cell$community_CTmax_se <- row$community_CTmax_se
    clipped_cell$community_max_temp <- row$community_max_temp
    clipped_cell$community_max_temp_se <- row$community_max_temp_se
    clipped_cell$community_TSM <- row$community_TSM
    clipped_cell$community_TSM_se <- row$community_TSM_se
    clipped_cell$n_species <- row$n_species
    clipped_cell$n_species_overheating <- row$n_species_overheating
    clipped_cell$proportion_species_overheating <- row$proportion_species_overheating
    clipped_cell$proportion_species_overheating_se <- row$proportion_species_overheating_se
    clipped_cell$n_species_overheating_strict95 <- row$n_species_overheating_strict95
    clipped_cell$n_species_overheating_strict50 <- row$n_species_overheating_strict50
    clipped_cell$proportion_species_overheating_strict95 <- row$proportion_species_overheating_strict95
    clipped_cell$proportion_species_overheating_se_strict95 <- row$proportion_species_overheating_se_strict95
    clipped_cell$proportion_species_overheating_strict50 <- row$proportion_species_overheating_strict50
    clipped_cell$proportion_species_overheating_se_strict50 <- row$proportion_species_overheating_se_strict50
    
    return(clipped_cell)
  } else {
    return(NULL)
  }
})

# Stop the cluster
stopCluster(cl)

# Create a list of clipped grid cells
clipped_grid_cells_list <- Filter(Negate(is.null), clipped_grid_cells_list)

# Merge the list of clipped grid cells into a single sf data frame
clipped_grid_cells <- do.call(rbind, clipped_grid_cells_list)

saveRDS(clipped_grid_cells, file="RData/Climate_vulnerability/Pond/future4C/community_vulnerability_pond_mean_acc_future4C_clipped_cells.rds")
